
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantDomain
 * 
 */
export type TenantDomain = $Result.DefaultSelection<Prisma.$TenantDomainPayload>
/**
 * Model WebsiteConfig
 * 
 */
export type WebsiteConfig = $Result.DefaultSelection<Prisma.$WebsiteConfigPayload>
/**
 * Model TenantControlSettings
 * 
 */
export type TenantControlSettings = $Result.DefaultSelection<Prisma.$TenantControlSettingsPayload>
/**
 * Model TenantBillingSubscription
 * 
 */
export type TenantBillingSubscription = $Result.DefaultSelection<Prisma.$TenantBillingSubscriptionPayload>
/**
 * Model TenantBillingSyncEvent
 * 
 */
export type TenantBillingSyncEvent = $Result.DefaultSelection<Prisma.$TenantBillingSyncEventPayload>
/**
 * Model TenantControlActor
 * 
 */
export type TenantControlActor = $Result.DefaultSelection<Prisma.$TenantControlActorPayload>
/**
 * Model TenantOnboardingPlan
 * 
 */
export type TenantOnboardingPlan = $Result.DefaultSelection<Prisma.$TenantOnboardingPlanPayload>
/**
 * Model TenantOnboardingTask
 * 
 */
export type TenantOnboardingTask = $Result.DefaultSelection<Prisma.$TenantOnboardingTaskPayload>
/**
 * Model ModuleConfig
 * 
 */
export type ModuleConfig = $Result.DefaultSelection<Prisma.$ModuleConfigPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model IngestedEvent
 * 
 */
export type IngestedEvent = $Result.DefaultSelection<Prisma.$IngestedEventPayload>
/**
 * Model IngestionQueueJob
 * 
 */
export type IngestionQueueJob = $Result.DefaultSelection<Prisma.$IngestionQueueJobPayload>
/**
 * Model AdminAuditEvent
 * 
 */
export type AdminAuditEvent = $Result.DefaultSelection<Prisma.$AdminAuditEventPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionParty
 * 
 */
export type TransactionParty = $Result.DefaultSelection<Prisma.$TransactionPartyPayload>
/**
 * Model TransactionDocument
 * 
 */
export type TransactionDocument = $Result.DefaultSelection<Prisma.$TransactionDocumentPayload>
/**
 * Model TransactionMilestone
 * 
 */
export type TransactionMilestone = $Result.DefaultSelection<Prisma.$TransactionMilestonePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantDomain`: Exposes CRUD operations for the **TenantDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantDomains
    * const tenantDomains = await prisma.tenantDomain.findMany()
    * ```
    */
  get tenantDomain(): Prisma.TenantDomainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websiteConfig`: Exposes CRUD operations for the **WebsiteConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebsiteConfigs
    * const websiteConfigs = await prisma.websiteConfig.findMany()
    * ```
    */
  get websiteConfig(): Prisma.WebsiteConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantControlSettings`: Exposes CRUD operations for the **TenantControlSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantControlSettings
    * const tenantControlSettings = await prisma.tenantControlSettings.findMany()
    * ```
    */
  get tenantControlSettings(): Prisma.TenantControlSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantBillingSubscription`: Exposes CRUD operations for the **TenantBillingSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantBillingSubscriptions
    * const tenantBillingSubscriptions = await prisma.tenantBillingSubscription.findMany()
    * ```
    */
  get tenantBillingSubscription(): Prisma.TenantBillingSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantBillingSyncEvent`: Exposes CRUD operations for the **TenantBillingSyncEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantBillingSyncEvents
    * const tenantBillingSyncEvents = await prisma.tenantBillingSyncEvent.findMany()
    * ```
    */
  get tenantBillingSyncEvent(): Prisma.TenantBillingSyncEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantControlActor`: Exposes CRUD operations for the **TenantControlActor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantControlActors
    * const tenantControlActors = await prisma.tenantControlActor.findMany()
    * ```
    */
  get tenantControlActor(): Prisma.TenantControlActorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantOnboardingPlan`: Exposes CRUD operations for the **TenantOnboardingPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantOnboardingPlans
    * const tenantOnboardingPlans = await prisma.tenantOnboardingPlan.findMany()
    * ```
    */
  get tenantOnboardingPlan(): Prisma.TenantOnboardingPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantOnboardingTask`: Exposes CRUD operations for the **TenantOnboardingTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantOnboardingTasks
    * const tenantOnboardingTasks = await prisma.tenantOnboardingTask.findMany()
    * ```
    */
  get tenantOnboardingTask(): Prisma.TenantOnboardingTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleConfig`: Exposes CRUD operations for the **ModuleConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleConfigs
    * const moduleConfigs = await prisma.moduleConfig.findMany()
    * ```
    */
  get moduleConfig(): Prisma.ModuleConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ingestedEvent`: Exposes CRUD operations for the **IngestedEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngestedEvents
    * const ingestedEvents = await prisma.ingestedEvent.findMany()
    * ```
    */
  get ingestedEvent(): Prisma.IngestedEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ingestionQueueJob`: Exposes CRUD operations for the **IngestionQueueJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngestionQueueJobs
    * const ingestionQueueJobs = await prisma.ingestionQueueJob.findMany()
    * ```
    */
  get ingestionQueueJob(): Prisma.IngestionQueueJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuditEvent`: Exposes CRUD operations for the **AdminAuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditEvents
    * const adminAuditEvents = await prisma.adminAuditEvent.findMany()
    * ```
    */
  get adminAuditEvent(): Prisma.AdminAuditEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionParty`: Exposes CRUD operations for the **TransactionParty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionParties
    * const transactionParties = await prisma.transactionParty.findMany()
    * ```
    */
  get transactionParty(): Prisma.TransactionPartyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionDocument`: Exposes CRUD operations for the **TransactionDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionDocuments
    * const transactionDocuments = await prisma.transactionDocument.findMany()
    * ```
    */
  get transactionDocument(): Prisma.TransactionDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionMilestone`: Exposes CRUD operations for the **TransactionMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionMilestones
    * const transactionMilestones = await prisma.transactionMilestone.findMany()
    * ```
    */
  get transactionMilestone(): Prisma.TransactionMilestoneDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    TenantDomain: 'TenantDomain',
    WebsiteConfig: 'WebsiteConfig',
    TenantControlSettings: 'TenantControlSettings',
    TenantBillingSubscription: 'TenantBillingSubscription',
    TenantBillingSyncEvent: 'TenantBillingSyncEvent',
    TenantControlActor: 'TenantControlActor',
    TenantOnboardingPlan: 'TenantOnboardingPlan',
    TenantOnboardingTask: 'TenantOnboardingTask',
    ModuleConfig: 'ModuleConfig',
    Contact: 'Contact',
    Lead: 'Lead',
    Activity: 'Activity',
    IngestedEvent: 'IngestedEvent',
    IngestionQueueJob: 'IngestionQueueJob',
    AdminAuditEvent: 'AdminAuditEvent',
    Transaction: 'Transaction',
    TransactionParty: 'TransactionParty',
    TransactionDocument: 'TransactionDocument',
    TransactionMilestone: 'TransactionMilestone'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "tenantDomain" | "websiteConfig" | "tenantControlSettings" | "tenantBillingSubscription" | "tenantBillingSyncEvent" | "tenantControlActor" | "tenantOnboardingPlan" | "tenantOnboardingTask" | "moduleConfig" | "contact" | "lead" | "activity" | "ingestedEvent" | "ingestionQueueJob" | "adminAuditEvent" | "transaction" | "transactionParty" | "transactionDocument" | "transactionMilestone"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantDomain: {
        payload: Prisma.$TenantDomainPayload<ExtArgs>
        fields: Prisma.TenantDomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantDomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantDomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          findFirst: {
            args: Prisma.TenantDomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantDomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          findMany: {
            args: Prisma.TenantDomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
          }
          create: {
            args: Prisma.TenantDomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          createMany: {
            args: Prisma.TenantDomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantDomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
          }
          delete: {
            args: Prisma.TenantDomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          update: {
            args: Prisma.TenantDomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          deleteMany: {
            args: Prisma.TenantDomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantDomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantDomainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>[]
          }
          upsert: {
            args: Prisma.TenantDomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantDomainPayload>
          }
          aggregate: {
            args: Prisma.TenantDomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantDomain>
          }
          groupBy: {
            args: Prisma.TenantDomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantDomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantDomainCountArgs<ExtArgs>
            result: $Utils.Optional<TenantDomainCountAggregateOutputType> | number
          }
        }
      }
      WebsiteConfig: {
        payload: Prisma.$WebsiteConfigPayload<ExtArgs>
        fields: Prisma.WebsiteConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsiteConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsiteConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          findFirst: {
            args: Prisma.WebsiteConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsiteConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          findMany: {
            args: Prisma.WebsiteConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>[]
          }
          create: {
            args: Prisma.WebsiteConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          createMany: {
            args: Prisma.WebsiteConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebsiteConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>[]
          }
          delete: {
            args: Prisma.WebsiteConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          update: {
            args: Prisma.WebsiteConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          deleteMany: {
            args: Prisma.WebsiteConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsiteConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebsiteConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>[]
          }
          upsert: {
            args: Prisma.WebsiteConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsiteConfigPayload>
          }
          aggregate: {
            args: Prisma.WebsiteConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsiteConfig>
          }
          groupBy: {
            args: Prisma.WebsiteConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsiteConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsiteConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WebsiteConfigCountAggregateOutputType> | number
          }
        }
      }
      TenantControlSettings: {
        payload: Prisma.$TenantControlSettingsPayload<ExtArgs>
        fields: Prisma.TenantControlSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantControlSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantControlSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          findFirst: {
            args: Prisma.TenantControlSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantControlSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          findMany: {
            args: Prisma.TenantControlSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>[]
          }
          create: {
            args: Prisma.TenantControlSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          createMany: {
            args: Prisma.TenantControlSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantControlSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>[]
          }
          delete: {
            args: Prisma.TenantControlSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          update: {
            args: Prisma.TenantControlSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          deleteMany: {
            args: Prisma.TenantControlSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantControlSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantControlSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>[]
          }
          upsert: {
            args: Prisma.TenantControlSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlSettingsPayload>
          }
          aggregate: {
            args: Prisma.TenantControlSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantControlSettings>
          }
          groupBy: {
            args: Prisma.TenantControlSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantControlSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantControlSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<TenantControlSettingsCountAggregateOutputType> | number
          }
        }
      }
      TenantBillingSubscription: {
        payload: Prisma.$TenantBillingSubscriptionPayload<ExtArgs>
        fields: Prisma.TenantBillingSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantBillingSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantBillingSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.TenantBillingSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantBillingSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          findMany: {
            args: Prisma.TenantBillingSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>[]
          }
          create: {
            args: Prisma.TenantBillingSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          createMany: {
            args: Prisma.TenantBillingSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantBillingSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.TenantBillingSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          update: {
            args: Prisma.TenantBillingSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.TenantBillingSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantBillingSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantBillingSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.TenantBillingSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.TenantBillingSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantBillingSubscription>
          }
          groupBy: {
            args: Prisma.TenantBillingSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantBillingSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantBillingSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<TenantBillingSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      TenantBillingSyncEvent: {
        payload: Prisma.$TenantBillingSyncEventPayload<ExtArgs>
        fields: Prisma.TenantBillingSyncEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantBillingSyncEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantBillingSyncEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          findFirst: {
            args: Prisma.TenantBillingSyncEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantBillingSyncEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          findMany: {
            args: Prisma.TenantBillingSyncEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>[]
          }
          create: {
            args: Prisma.TenantBillingSyncEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          createMany: {
            args: Prisma.TenantBillingSyncEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantBillingSyncEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>[]
          }
          delete: {
            args: Prisma.TenantBillingSyncEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          update: {
            args: Prisma.TenantBillingSyncEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          deleteMany: {
            args: Prisma.TenantBillingSyncEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantBillingSyncEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantBillingSyncEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>[]
          }
          upsert: {
            args: Prisma.TenantBillingSyncEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantBillingSyncEventPayload>
          }
          aggregate: {
            args: Prisma.TenantBillingSyncEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantBillingSyncEvent>
          }
          groupBy: {
            args: Prisma.TenantBillingSyncEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantBillingSyncEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantBillingSyncEventCountArgs<ExtArgs>
            result: $Utils.Optional<TenantBillingSyncEventCountAggregateOutputType> | number
          }
        }
      }
      TenantControlActor: {
        payload: Prisma.$TenantControlActorPayload<ExtArgs>
        fields: Prisma.TenantControlActorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantControlActorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantControlActorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          findFirst: {
            args: Prisma.TenantControlActorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantControlActorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          findMany: {
            args: Prisma.TenantControlActorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>[]
          }
          create: {
            args: Prisma.TenantControlActorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          createMany: {
            args: Prisma.TenantControlActorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantControlActorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>[]
          }
          delete: {
            args: Prisma.TenantControlActorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          update: {
            args: Prisma.TenantControlActorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          deleteMany: {
            args: Prisma.TenantControlActorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantControlActorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantControlActorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>[]
          }
          upsert: {
            args: Prisma.TenantControlActorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantControlActorPayload>
          }
          aggregate: {
            args: Prisma.TenantControlActorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantControlActor>
          }
          groupBy: {
            args: Prisma.TenantControlActorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantControlActorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantControlActorCountArgs<ExtArgs>
            result: $Utils.Optional<TenantControlActorCountAggregateOutputType> | number
          }
        }
      }
      TenantOnboardingPlan: {
        payload: Prisma.$TenantOnboardingPlanPayload<ExtArgs>
        fields: Prisma.TenantOnboardingPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantOnboardingPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantOnboardingPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          findFirst: {
            args: Prisma.TenantOnboardingPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantOnboardingPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          findMany: {
            args: Prisma.TenantOnboardingPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>[]
          }
          create: {
            args: Prisma.TenantOnboardingPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          createMany: {
            args: Prisma.TenantOnboardingPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantOnboardingPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>[]
          }
          delete: {
            args: Prisma.TenantOnboardingPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          update: {
            args: Prisma.TenantOnboardingPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          deleteMany: {
            args: Prisma.TenantOnboardingPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantOnboardingPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantOnboardingPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>[]
          }
          upsert: {
            args: Prisma.TenantOnboardingPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingPlanPayload>
          }
          aggregate: {
            args: Prisma.TenantOnboardingPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantOnboardingPlan>
          }
          groupBy: {
            args: Prisma.TenantOnboardingPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantOnboardingPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantOnboardingPlanCountArgs<ExtArgs>
            result: $Utils.Optional<TenantOnboardingPlanCountAggregateOutputType> | number
          }
        }
      }
      TenantOnboardingTask: {
        payload: Prisma.$TenantOnboardingTaskPayload<ExtArgs>
        fields: Prisma.TenantOnboardingTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantOnboardingTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantOnboardingTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          findFirst: {
            args: Prisma.TenantOnboardingTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantOnboardingTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          findMany: {
            args: Prisma.TenantOnboardingTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>[]
          }
          create: {
            args: Prisma.TenantOnboardingTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          createMany: {
            args: Prisma.TenantOnboardingTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantOnboardingTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>[]
          }
          delete: {
            args: Prisma.TenantOnboardingTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          update: {
            args: Prisma.TenantOnboardingTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          deleteMany: {
            args: Prisma.TenantOnboardingTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantOnboardingTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantOnboardingTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>[]
          }
          upsert: {
            args: Prisma.TenantOnboardingTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantOnboardingTaskPayload>
          }
          aggregate: {
            args: Prisma.TenantOnboardingTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantOnboardingTask>
          }
          groupBy: {
            args: Prisma.TenantOnboardingTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantOnboardingTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantOnboardingTaskCountArgs<ExtArgs>
            result: $Utils.Optional<TenantOnboardingTaskCountAggregateOutputType> | number
          }
        }
      }
      ModuleConfig: {
        payload: Prisma.$ModuleConfigPayload<ExtArgs>
        fields: Prisma.ModuleConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          findFirst: {
            args: Prisma.ModuleConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          findMany: {
            args: Prisma.ModuleConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>[]
          }
          create: {
            args: Prisma.ModuleConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          createMany: {
            args: Prisma.ModuleConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>[]
          }
          delete: {
            args: Prisma.ModuleConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          update: {
            args: Prisma.ModuleConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          deleteMany: {
            args: Prisma.ModuleConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>[]
          }
          upsert: {
            args: Prisma.ModuleConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleConfigPayload>
          }
          aggregate: {
            args: Prisma.ModuleConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleConfig>
          }
          groupBy: {
            args: Prisma.ModuleConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleConfigCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      IngestedEvent: {
        payload: Prisma.$IngestedEventPayload<ExtArgs>
        fields: Prisma.IngestedEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestedEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestedEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          findFirst: {
            args: Prisma.IngestedEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestedEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          findMany: {
            args: Prisma.IngestedEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>[]
          }
          create: {
            args: Prisma.IngestedEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          createMany: {
            args: Prisma.IngestedEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestedEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>[]
          }
          delete: {
            args: Prisma.IngestedEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          update: {
            args: Prisma.IngestedEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          deleteMany: {
            args: Prisma.IngestedEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestedEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngestedEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>[]
          }
          upsert: {
            args: Prisma.IngestedEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestedEventPayload>
          }
          aggregate: {
            args: Prisma.IngestedEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestedEvent>
          }
          groupBy: {
            args: Prisma.IngestedEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestedEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestedEventCountArgs<ExtArgs>
            result: $Utils.Optional<IngestedEventCountAggregateOutputType> | number
          }
        }
      }
      IngestionQueueJob: {
        payload: Prisma.$IngestionQueueJobPayload<ExtArgs>
        fields: Prisma.IngestionQueueJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestionQueueJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestionQueueJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          findFirst: {
            args: Prisma.IngestionQueueJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestionQueueJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          findMany: {
            args: Prisma.IngestionQueueJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>[]
          }
          create: {
            args: Prisma.IngestionQueueJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          createMany: {
            args: Prisma.IngestionQueueJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestionQueueJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>[]
          }
          delete: {
            args: Prisma.IngestionQueueJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          update: {
            args: Prisma.IngestionQueueJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          deleteMany: {
            args: Prisma.IngestionQueueJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestionQueueJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngestionQueueJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>[]
          }
          upsert: {
            args: Prisma.IngestionQueueJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionQueueJobPayload>
          }
          aggregate: {
            args: Prisma.IngestionQueueJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestionQueueJob>
          }
          groupBy: {
            args: Prisma.IngestionQueueJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestionQueueJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestionQueueJobCountArgs<ExtArgs>
            result: $Utils.Optional<IngestionQueueJobCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditEvent: {
        payload: Prisma.$AdminAuditEventPayload<ExtArgs>
        fields: Prisma.AdminAuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          findMany: {
            args: Prisma.AdminAuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>[]
          }
          create: {
            args: Prisma.AdminAuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          createMany: {
            args: Prisma.AdminAuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          update: {
            args: Prisma.AdminAuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditEventPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditEvent>
          }
          groupBy: {
            args: Prisma.AdminAuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditEventCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionParty: {
        payload: Prisma.$TransactionPartyPayload<ExtArgs>
        fields: Prisma.TransactionPartyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionPartyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionPartyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          findFirst: {
            args: Prisma.TransactionPartyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionPartyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          findMany: {
            args: Prisma.TransactionPartyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>[]
          }
          create: {
            args: Prisma.TransactionPartyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          createMany: {
            args: Prisma.TransactionPartyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionPartyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>[]
          }
          delete: {
            args: Prisma.TransactionPartyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          update: {
            args: Prisma.TransactionPartyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          deleteMany: {
            args: Prisma.TransactionPartyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionPartyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionPartyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>[]
          }
          upsert: {
            args: Prisma.TransactionPartyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPartyPayload>
          }
          aggregate: {
            args: Prisma.TransactionPartyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionParty>
          }
          groupBy: {
            args: Prisma.TransactionPartyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionPartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionPartyCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionPartyCountAggregateOutputType> | number
          }
        }
      }
      TransactionDocument: {
        payload: Prisma.$TransactionDocumentPayload<ExtArgs>
        fields: Prisma.TransactionDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          findFirst: {
            args: Prisma.TransactionDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          findMany: {
            args: Prisma.TransactionDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>[]
          }
          create: {
            args: Prisma.TransactionDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          createMany: {
            args: Prisma.TransactionDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>[]
          }
          delete: {
            args: Prisma.TransactionDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          update: {
            args: Prisma.TransactionDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>[]
          }
          upsert: {
            args: Prisma.TransactionDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionDocumentPayload>
          }
          aggregate: {
            args: Prisma.TransactionDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionDocument>
          }
          groupBy: {
            args: Prisma.TransactionDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionDocumentCountAggregateOutputType> | number
          }
        }
      }
      TransactionMilestone: {
        payload: Prisma.$TransactionMilestonePayload<ExtArgs>
        fields: Prisma.TransactionMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          findFirst: {
            args: Prisma.TransactionMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          findMany: {
            args: Prisma.TransactionMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>[]
          }
          create: {
            args: Prisma.TransactionMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          createMany: {
            args: Prisma.TransactionMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionMilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>[]
          }
          delete: {
            args: Prisma.TransactionMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          update: {
            args: Prisma.TransactionMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          deleteMany: {
            args: Prisma.TransactionMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionMilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>[]
          }
          upsert: {
            args: Prisma.TransactionMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionMilestonePayload>
          }
          aggregate: {
            args: Prisma.TransactionMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionMilestone>
          }
          groupBy: {
            args: Prisma.TransactionMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionMilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionMilestoneCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    tenantDomain?: TenantDomainOmit
    websiteConfig?: WebsiteConfigOmit
    tenantControlSettings?: TenantControlSettingsOmit
    tenantBillingSubscription?: TenantBillingSubscriptionOmit
    tenantBillingSyncEvent?: TenantBillingSyncEventOmit
    tenantControlActor?: TenantControlActorOmit
    tenantOnboardingPlan?: TenantOnboardingPlanOmit
    tenantOnboardingTask?: TenantOnboardingTaskOmit
    moduleConfig?: ModuleConfigOmit
    contact?: ContactOmit
    lead?: LeadOmit
    activity?: ActivityOmit
    ingestedEvent?: IngestedEventOmit
    ingestionQueueJob?: IngestionQueueJobOmit
    adminAuditEvent?: AdminAuditEventOmit
    transaction?: TransactionOmit
    transactionParty?: TransactionPartyOmit
    transactionDocument?: TransactionDocumentOmit
    transactionMilestone?: TransactionMilestoneOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    domains: number
    controlActors: number
    onboardingPlans: number
    onboardingTasks: number
    contacts: number
    leads: number
    activities: number
    ingestedEvents: number
    ingestionQueueJobs: number
    transactions: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domains?: boolean | TenantCountOutputTypeCountDomainsArgs
    controlActors?: boolean | TenantCountOutputTypeCountControlActorsArgs
    onboardingPlans?: boolean | TenantCountOutputTypeCountOnboardingPlansArgs
    onboardingTasks?: boolean | TenantCountOutputTypeCountOnboardingTasksArgs
    contacts?: boolean | TenantCountOutputTypeCountContactsArgs
    leads?: boolean | TenantCountOutputTypeCountLeadsArgs
    activities?: boolean | TenantCountOutputTypeCountActivitiesArgs
    ingestedEvents?: boolean | TenantCountOutputTypeCountIngestedEventsArgs
    ingestionQueueJobs?: boolean | TenantCountOutputTypeCountIngestionQueueJobsArgs
    transactions?: boolean | TenantCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantDomainWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountControlActorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantControlActorWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOnboardingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantOnboardingPlanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountOnboardingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantOnboardingTaskWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIngestedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestedEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIngestionQueueJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionQueueJobWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type WebsiteConfigCountOutputType
   */

  export type WebsiteConfigCountOutputType = {
    modules: number
  }

  export type WebsiteConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | WebsiteConfigCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * WebsiteConfigCountOutputType without action
   */
  export type WebsiteConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfigCountOutputType
     */
    select?: WebsiteConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WebsiteConfigCountOutputType without action
   */
  export type WebsiteConfigCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleConfigWhereInput
  }


  /**
   * Count Type TenantOnboardingPlanCountOutputType
   */

  export type TenantOnboardingPlanCountOutputType = {
    tasks: number
  }

  export type TenantOnboardingPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TenantOnboardingPlanCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * TenantOnboardingPlanCountOutputType without action
   */
  export type TenantOnboardingPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlanCountOutputType
     */
    select?: TenantOnboardingPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantOnboardingPlanCountOutputType without action
   */
  export type TenantOnboardingPlanCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantOnboardingTaskWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    leads: number
    activities: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | ContactCountOutputTypeCountLeadsArgs
    activities?: boolean | ContactCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    activities: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | LeadCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    parties: number
    documents: number
    milestones: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parties?: boolean | TransactionCountOutputTypeCountPartiesArgs
    documents?: boolean | TransactionCountOutputTypeCountDocumentsArgs
    milestones?: boolean | TransactionCountOutputTypeCountMilestonesArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountPartiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionPartyWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionDocumentWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionMilestoneWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domains?: boolean | Tenant$domainsArgs<ExtArgs>
    websiteConfig?: boolean | Tenant$websiteConfigArgs<ExtArgs>
    controlSettings?: boolean | Tenant$controlSettingsArgs<ExtArgs>
    billingSubscription?: boolean | Tenant$billingSubscriptionArgs<ExtArgs>
    controlActors?: boolean | Tenant$controlActorsArgs<ExtArgs>
    onboardingPlans?: boolean | Tenant$onboardingPlansArgs<ExtArgs>
    onboardingTasks?: boolean | Tenant$onboardingTasksArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    activities?: boolean | Tenant$activitiesArgs<ExtArgs>
    ingestedEvents?: boolean | Tenant$ingestedEventsArgs<ExtArgs>
    ingestionQueueJobs?: boolean | Tenant$ingestionQueueJobsArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domains?: boolean | Tenant$domainsArgs<ExtArgs>
    websiteConfig?: boolean | Tenant$websiteConfigArgs<ExtArgs>
    controlSettings?: boolean | Tenant$controlSettingsArgs<ExtArgs>
    billingSubscription?: boolean | Tenant$billingSubscriptionArgs<ExtArgs>
    controlActors?: boolean | Tenant$controlActorsArgs<ExtArgs>
    onboardingPlans?: boolean | Tenant$onboardingPlansArgs<ExtArgs>
    onboardingTasks?: boolean | Tenant$onboardingTasksArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    activities?: boolean | Tenant$activitiesArgs<ExtArgs>
    ingestedEvents?: boolean | Tenant$ingestedEventsArgs<ExtArgs>
    ingestionQueueJobs?: boolean | Tenant$ingestionQueueJobsArgs<ExtArgs>
    transactions?: boolean | Tenant$transactionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      domains: Prisma.$TenantDomainPayload<ExtArgs>[]
      websiteConfig: Prisma.$WebsiteConfigPayload<ExtArgs> | null
      controlSettings: Prisma.$TenantControlSettingsPayload<ExtArgs> | null
      billingSubscription: Prisma.$TenantBillingSubscriptionPayload<ExtArgs> | null
      controlActors: Prisma.$TenantControlActorPayload<ExtArgs>[]
      onboardingPlans: Prisma.$TenantOnboardingPlanPayload<ExtArgs>[]
      onboardingTasks: Prisma.$TenantOnboardingTaskPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      ingestedEvents: Prisma.$IngestedEventPayload<ExtArgs>[]
      ingestionQueueJobs: Prisma.$IngestionQueueJobPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domains<T extends Tenant$domainsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$domainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    websiteConfig<T extends Tenant$websiteConfigArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$websiteConfigArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    controlSettings<T extends Tenant$controlSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$controlSettingsArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    billingSubscription<T extends Tenant$billingSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$billingSubscriptionArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    controlActors<T extends Tenant$controlActorsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$controlActorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onboardingPlans<T extends Tenant$onboardingPlansArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$onboardingPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    onboardingTasks<T extends Tenant$onboardingTasksArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$onboardingTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Tenant$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Tenant$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Tenant$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ingestedEvents<T extends Tenant$ingestedEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ingestedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ingestionQueueJobs<T extends Tenant$ingestionQueueJobsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ingestionQueueJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Tenant$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.domains
   */
  export type Tenant$domainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    where?: TenantDomainWhereInput
    orderBy?: TenantDomainOrderByWithRelationInput | TenantDomainOrderByWithRelationInput[]
    cursor?: TenantDomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantDomainScalarFieldEnum | TenantDomainScalarFieldEnum[]
  }

  /**
   * Tenant.websiteConfig
   */
  export type Tenant$websiteConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    where?: WebsiteConfigWhereInput
  }

  /**
   * Tenant.controlSettings
   */
  export type Tenant$controlSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    where?: TenantControlSettingsWhereInput
  }

  /**
   * Tenant.billingSubscription
   */
  export type Tenant$billingSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    where?: TenantBillingSubscriptionWhereInput
  }

  /**
   * Tenant.controlActors
   */
  export type Tenant$controlActorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    where?: TenantControlActorWhereInput
    orderBy?: TenantControlActorOrderByWithRelationInput | TenantControlActorOrderByWithRelationInput[]
    cursor?: TenantControlActorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantControlActorScalarFieldEnum | TenantControlActorScalarFieldEnum[]
  }

  /**
   * Tenant.onboardingPlans
   */
  export type Tenant$onboardingPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    where?: TenantOnboardingPlanWhereInput
    orderBy?: TenantOnboardingPlanOrderByWithRelationInput | TenantOnboardingPlanOrderByWithRelationInput[]
    cursor?: TenantOnboardingPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantOnboardingPlanScalarFieldEnum | TenantOnboardingPlanScalarFieldEnum[]
  }

  /**
   * Tenant.onboardingTasks
   */
  export type Tenant$onboardingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    where?: TenantOnboardingTaskWhereInput
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    cursor?: TenantOnboardingTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantOnboardingTaskScalarFieldEnum | TenantOnboardingTaskScalarFieldEnum[]
  }

  /**
   * Tenant.contacts
   */
  export type Tenant$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Tenant.leads
   */
  export type Tenant$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Tenant.activities
   */
  export type Tenant$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Tenant.ingestedEvents
   */
  export type Tenant$ingestedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    where?: IngestedEventWhereInput
    orderBy?: IngestedEventOrderByWithRelationInput | IngestedEventOrderByWithRelationInput[]
    cursor?: IngestedEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestedEventScalarFieldEnum | IngestedEventScalarFieldEnum[]
  }

  /**
   * Tenant.ingestionQueueJobs
   */
  export type Tenant$ingestionQueueJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    where?: IngestionQueueJobWhereInput
    orderBy?: IngestionQueueJobOrderByWithRelationInput | IngestionQueueJobOrderByWithRelationInput[]
    cursor?: IngestionQueueJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestionQueueJobScalarFieldEnum | IngestionQueueJobScalarFieldEnum[]
  }

  /**
   * Tenant.transactions
   */
  export type Tenant$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantDomain
   */

  export type AggregateTenantDomain = {
    _count: TenantDomainCountAggregateOutputType | null
    _min: TenantDomainMinAggregateOutputType | null
    _max: TenantDomainMaxAggregateOutputType | null
  }

  export type TenantDomainMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    hostname: string | null
    hostnameNormalized: string | null
    status: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantDomainMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    hostname: string | null
    hostnameNormalized: string | null
    status: string | null
    isPrimary: boolean | null
    isVerified: boolean | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantDomainCountAggregateOutputType = {
    id: number
    tenantId: number
    hostname: number
    hostnameNormalized: number
    status: number
    isPrimary: number
    isVerified: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantDomainMinAggregateInputType = {
    id?: true
    tenantId?: true
    hostname?: true
    hostnameNormalized?: true
    status?: true
    isPrimary?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantDomainMaxAggregateInputType = {
    id?: true
    tenantId?: true
    hostname?: true
    hostnameNormalized?: true
    status?: true
    isPrimary?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantDomainCountAggregateInputType = {
    id?: true
    tenantId?: true
    hostname?: true
    hostnameNormalized?: true
    status?: true
    isPrimary?: true
    isVerified?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantDomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantDomain to aggregate.
     */
    where?: TenantDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDomains to fetch.
     */
    orderBy?: TenantDomainOrderByWithRelationInput | TenantDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantDomains
    **/
    _count?: true | TenantDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantDomainMaxAggregateInputType
  }

  export type GetTenantDomainAggregateType<T extends TenantDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantDomain[P]>
      : GetScalarType<T[P], AggregateTenantDomain[P]>
  }




  export type TenantDomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantDomainWhereInput
    orderBy?: TenantDomainOrderByWithAggregationInput | TenantDomainOrderByWithAggregationInput[]
    by: TenantDomainScalarFieldEnum[] | TenantDomainScalarFieldEnum
    having?: TenantDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantDomainCountAggregateInputType | true
    _min?: TenantDomainMinAggregateInputType
    _max?: TenantDomainMaxAggregateInputType
  }

  export type TenantDomainGroupByOutputType = {
    id: string
    tenantId: string
    hostname: string
    hostnameNormalized: string
    status: string
    isPrimary: boolean
    isVerified: boolean
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TenantDomainCountAggregateOutputType | null
    _min: TenantDomainMinAggregateOutputType | null
    _max: TenantDomainMaxAggregateOutputType | null
  }

  type GetTenantDomainGroupByPayload<T extends TenantDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantDomainGroupByOutputType[P]>
            : GetScalarType<T[P], TenantDomainGroupByOutputType[P]>
        }
      >
    >


  export type TenantDomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hostname?: boolean
    hostnameNormalized?: boolean
    status?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDomain"]>

  export type TenantDomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hostname?: boolean
    hostnameNormalized?: boolean
    status?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDomain"]>

  export type TenantDomainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    hostname?: boolean
    hostnameNormalized?: boolean
    status?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantDomain"]>

  export type TenantDomainSelectScalar = {
    id?: boolean
    tenantId?: boolean
    hostname?: boolean
    hostnameNormalized?: boolean
    status?: boolean
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantDomainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "hostname" | "hostnameNormalized" | "status" | "isPrimary" | "isVerified" | "verifiedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantDomain"]>
  export type TenantDomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantDomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantDomainIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantDomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantDomain"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      hostname: string
      hostnameNormalized: string
      status: string
      isPrimary: boolean
      isVerified: boolean
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantDomain"]>
    composites: {}
  }

  type TenantDomainGetPayload<S extends boolean | null | undefined | TenantDomainDefaultArgs> = $Result.GetResult<Prisma.$TenantDomainPayload, S>

  type TenantDomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantDomainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantDomainCountAggregateInputType | true
    }

  export interface TenantDomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantDomain'], meta: { name: 'TenantDomain' } }
    /**
     * Find zero or one TenantDomain that matches the filter.
     * @param {TenantDomainFindUniqueArgs} args - Arguments to find a TenantDomain
     * @example
     * // Get one TenantDomain
     * const tenantDomain = await prisma.tenantDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantDomainFindUniqueArgs>(args: SelectSubset<T, TenantDomainFindUniqueArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantDomain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantDomainFindUniqueOrThrowArgs} args - Arguments to find a TenantDomain
     * @example
     * // Get one TenantDomain
     * const tenantDomain = await prisma.tenantDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantDomainFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantDomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainFindFirstArgs} args - Arguments to find a TenantDomain
     * @example
     * // Get one TenantDomain
     * const tenantDomain = await prisma.tenantDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantDomainFindFirstArgs>(args?: SelectSubset<T, TenantDomainFindFirstArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantDomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainFindFirstOrThrowArgs} args - Arguments to find a TenantDomain
     * @example
     * // Get one TenantDomain
     * const tenantDomain = await prisma.tenantDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantDomainFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantDomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantDomains
     * const tenantDomains = await prisma.tenantDomain.findMany()
     * 
     * // Get first 10 TenantDomains
     * const tenantDomains = await prisma.tenantDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantDomainWithIdOnly = await prisma.tenantDomain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantDomainFindManyArgs>(args?: SelectSubset<T, TenantDomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantDomain.
     * @param {TenantDomainCreateArgs} args - Arguments to create a TenantDomain.
     * @example
     * // Create one TenantDomain
     * const TenantDomain = await prisma.tenantDomain.create({
     *   data: {
     *     // ... data to create a TenantDomain
     *   }
     * })
     * 
     */
    create<T extends TenantDomainCreateArgs>(args: SelectSubset<T, TenantDomainCreateArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantDomains.
     * @param {TenantDomainCreateManyArgs} args - Arguments to create many TenantDomains.
     * @example
     * // Create many TenantDomains
     * const tenantDomain = await prisma.tenantDomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantDomainCreateManyArgs>(args?: SelectSubset<T, TenantDomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantDomains and returns the data saved in the database.
     * @param {TenantDomainCreateManyAndReturnArgs} args - Arguments to create many TenantDomains.
     * @example
     * // Create many TenantDomains
     * const tenantDomain = await prisma.tenantDomain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantDomains and only return the `id`
     * const tenantDomainWithIdOnly = await prisma.tenantDomain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantDomainCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantDomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantDomain.
     * @param {TenantDomainDeleteArgs} args - Arguments to delete one TenantDomain.
     * @example
     * // Delete one TenantDomain
     * const TenantDomain = await prisma.tenantDomain.delete({
     *   where: {
     *     // ... filter to delete one TenantDomain
     *   }
     * })
     * 
     */
    delete<T extends TenantDomainDeleteArgs>(args: SelectSubset<T, TenantDomainDeleteArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantDomain.
     * @param {TenantDomainUpdateArgs} args - Arguments to update one TenantDomain.
     * @example
     * // Update one TenantDomain
     * const tenantDomain = await prisma.tenantDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantDomainUpdateArgs>(args: SelectSubset<T, TenantDomainUpdateArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantDomains.
     * @param {TenantDomainDeleteManyArgs} args - Arguments to filter TenantDomains to delete.
     * @example
     * // Delete a few TenantDomains
     * const { count } = await prisma.tenantDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDomainDeleteManyArgs>(args?: SelectSubset<T, TenantDomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantDomains
     * const tenantDomain = await prisma.tenantDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantDomainUpdateManyArgs>(args: SelectSubset<T, TenantDomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantDomains and returns the data updated in the database.
     * @param {TenantDomainUpdateManyAndReturnArgs} args - Arguments to update many TenantDomains.
     * @example
     * // Update many TenantDomains
     * const tenantDomain = await prisma.tenantDomain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantDomains and only return the `id`
     * const tenantDomainWithIdOnly = await prisma.tenantDomain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantDomainUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantDomainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantDomain.
     * @param {TenantDomainUpsertArgs} args - Arguments to update or create a TenantDomain.
     * @example
     * // Update or create a TenantDomain
     * const tenantDomain = await prisma.tenantDomain.upsert({
     *   create: {
     *     // ... data to create a TenantDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantDomain we want to update
     *   }
     * })
     */
    upsert<T extends TenantDomainUpsertArgs>(args: SelectSubset<T, TenantDomainUpsertArgs<ExtArgs>>): Prisma__TenantDomainClient<$Result.GetResult<Prisma.$TenantDomainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainCountArgs} args - Arguments to filter TenantDomains to count.
     * @example
     * // Count the number of TenantDomains
     * const count = await prisma.tenantDomain.count({
     *   where: {
     *     // ... the filter for the TenantDomains we want to count
     *   }
     * })
    **/
    count<T extends TenantDomainCountArgs>(
      args?: Subset<T, TenantDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantDomainAggregateArgs>(args: Subset<T, TenantDomainAggregateArgs>): Prisma.PrismaPromise<GetTenantDomainAggregateType<T>>

    /**
     * Group by TenantDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantDomainGroupByArgs['orderBy'] }
        : { orderBy?: TenantDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantDomain model
   */
  readonly fields: TenantDomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantDomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantDomain model
   */
  interface TenantDomainFieldRefs {
    readonly id: FieldRef<"TenantDomain", 'String'>
    readonly tenantId: FieldRef<"TenantDomain", 'String'>
    readonly hostname: FieldRef<"TenantDomain", 'String'>
    readonly hostnameNormalized: FieldRef<"TenantDomain", 'String'>
    readonly status: FieldRef<"TenantDomain", 'String'>
    readonly isPrimary: FieldRef<"TenantDomain", 'Boolean'>
    readonly isVerified: FieldRef<"TenantDomain", 'Boolean'>
    readonly verifiedAt: FieldRef<"TenantDomain", 'DateTime'>
    readonly createdAt: FieldRef<"TenantDomain", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantDomain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantDomain findUnique
   */
  export type TenantDomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter, which TenantDomain to fetch.
     */
    where: TenantDomainWhereUniqueInput
  }

  /**
   * TenantDomain findUniqueOrThrow
   */
  export type TenantDomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter, which TenantDomain to fetch.
     */
    where: TenantDomainWhereUniqueInput
  }

  /**
   * TenantDomain findFirst
   */
  export type TenantDomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter, which TenantDomain to fetch.
     */
    where?: TenantDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDomains to fetch.
     */
    orderBy?: TenantDomainOrderByWithRelationInput | TenantDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantDomains.
     */
    cursor?: TenantDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantDomains.
     */
    distinct?: TenantDomainScalarFieldEnum | TenantDomainScalarFieldEnum[]
  }

  /**
   * TenantDomain findFirstOrThrow
   */
  export type TenantDomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter, which TenantDomain to fetch.
     */
    where?: TenantDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDomains to fetch.
     */
    orderBy?: TenantDomainOrderByWithRelationInput | TenantDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantDomains.
     */
    cursor?: TenantDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantDomains.
     */
    distinct?: TenantDomainScalarFieldEnum | TenantDomainScalarFieldEnum[]
  }

  /**
   * TenantDomain findMany
   */
  export type TenantDomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter, which TenantDomains to fetch.
     */
    where?: TenantDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantDomains to fetch.
     */
    orderBy?: TenantDomainOrderByWithRelationInput | TenantDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantDomains.
     */
    cursor?: TenantDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantDomains.
     */
    skip?: number
    distinct?: TenantDomainScalarFieldEnum | TenantDomainScalarFieldEnum[]
  }

  /**
   * TenantDomain create
   */
  export type TenantDomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantDomain.
     */
    data: XOR<TenantDomainCreateInput, TenantDomainUncheckedCreateInput>
  }

  /**
   * TenantDomain createMany
   */
  export type TenantDomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantDomains.
     */
    data: TenantDomainCreateManyInput | TenantDomainCreateManyInput[]
  }

  /**
   * TenantDomain createManyAndReturn
   */
  export type TenantDomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * The data used to create many TenantDomains.
     */
    data: TenantDomainCreateManyInput | TenantDomainCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantDomain update
   */
  export type TenantDomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantDomain.
     */
    data: XOR<TenantDomainUpdateInput, TenantDomainUncheckedUpdateInput>
    /**
     * Choose, which TenantDomain to update.
     */
    where: TenantDomainWhereUniqueInput
  }

  /**
   * TenantDomain updateMany
   */
  export type TenantDomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantDomains.
     */
    data: XOR<TenantDomainUpdateManyMutationInput, TenantDomainUncheckedUpdateManyInput>
    /**
     * Filter which TenantDomains to update
     */
    where?: TenantDomainWhereInput
    /**
     * Limit how many TenantDomains to update.
     */
    limit?: number
  }

  /**
   * TenantDomain updateManyAndReturn
   */
  export type TenantDomainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * The data used to update TenantDomains.
     */
    data: XOR<TenantDomainUpdateManyMutationInput, TenantDomainUncheckedUpdateManyInput>
    /**
     * Filter which TenantDomains to update
     */
    where?: TenantDomainWhereInput
    /**
     * Limit how many TenantDomains to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantDomain upsert
   */
  export type TenantDomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantDomain to update in case it exists.
     */
    where: TenantDomainWhereUniqueInput
    /**
     * In case the TenantDomain found by the `where` argument doesn't exist, create a new TenantDomain with this data.
     */
    create: XOR<TenantDomainCreateInput, TenantDomainUncheckedCreateInput>
    /**
     * In case the TenantDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantDomainUpdateInput, TenantDomainUncheckedUpdateInput>
  }

  /**
   * TenantDomain delete
   */
  export type TenantDomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
    /**
     * Filter which TenantDomain to delete.
     */
    where: TenantDomainWhereUniqueInput
  }

  /**
   * TenantDomain deleteMany
   */
  export type TenantDomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantDomains to delete
     */
    where?: TenantDomainWhereInput
    /**
     * Limit how many TenantDomains to delete.
     */
    limit?: number
  }

  /**
   * TenantDomain without action
   */
  export type TenantDomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantDomain
     */
    select?: TenantDomainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantDomain
     */
    omit?: TenantDomainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantDomainInclude<ExtArgs> | null
  }


  /**
   * Model WebsiteConfig
   */

  export type AggregateWebsiteConfig = {
    _count: WebsiteConfigCountAggregateOutputType | null
    _min: WebsiteConfigMinAggregateOutputType | null
    _max: WebsiteConfigMaxAggregateOutputType | null
  }

  export type WebsiteConfigMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteConfigMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebsiteConfigCountAggregateOutputType = {
    id: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebsiteConfigMinAggregateInputType = {
    id?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteConfigMaxAggregateInputType = {
    id?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebsiteConfigCountAggregateInputType = {
    id?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebsiteConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteConfig to aggregate.
     */
    where?: WebsiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteConfigs to fetch.
     */
    orderBy?: WebsiteConfigOrderByWithRelationInput | WebsiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebsiteConfigs
    **/
    _count?: true | WebsiteConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsiteConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsiteConfigMaxAggregateInputType
  }

  export type GetWebsiteConfigAggregateType<T extends WebsiteConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsiteConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsiteConfig[P]>
      : GetScalarType<T[P], AggregateWebsiteConfig[P]>
  }




  export type WebsiteConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsiteConfigWhereInput
    orderBy?: WebsiteConfigOrderByWithAggregationInput | WebsiteConfigOrderByWithAggregationInput[]
    by: WebsiteConfigScalarFieldEnum[] | WebsiteConfigScalarFieldEnum
    having?: WebsiteConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsiteConfigCountAggregateInputType | true
    _min?: WebsiteConfigMinAggregateInputType
    _max?: WebsiteConfigMaxAggregateInputType
  }

  export type WebsiteConfigGroupByOutputType = {
    id: string
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: WebsiteConfigCountAggregateOutputType | null
    _min: WebsiteConfigMinAggregateOutputType | null
    _max: WebsiteConfigMaxAggregateOutputType | null
  }

  type GetWebsiteConfigGroupByPayload<T extends WebsiteConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsiteConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsiteConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsiteConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WebsiteConfigGroupByOutputType[P]>
        }
      >
    >


  export type WebsiteConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    modules?: boolean | WebsiteConfig$modulesArgs<ExtArgs>
    _count?: boolean | WebsiteConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteConfig"]>

  export type WebsiteConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteConfig"]>

  export type WebsiteConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websiteConfig"]>

  export type WebsiteConfigSelectScalar = {
    id?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebsiteConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["websiteConfig"]>
  export type WebsiteConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    modules?: boolean | WebsiteConfig$modulesArgs<ExtArgs>
    _count?: boolean | WebsiteConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WebsiteConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type WebsiteConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WebsiteConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebsiteConfig"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      modules: Prisma.$ModuleConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["websiteConfig"]>
    composites: {}
  }

  type WebsiteConfigGetPayload<S extends boolean | null | undefined | WebsiteConfigDefaultArgs> = $Result.GetResult<Prisma.$WebsiteConfigPayload, S>

  type WebsiteConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsiteConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsiteConfigCountAggregateInputType | true
    }

  export interface WebsiteConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebsiteConfig'], meta: { name: 'WebsiteConfig' } }
    /**
     * Find zero or one WebsiteConfig that matches the filter.
     * @param {WebsiteConfigFindUniqueArgs} args - Arguments to find a WebsiteConfig
     * @example
     * // Get one WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsiteConfigFindUniqueArgs>(args: SelectSubset<T, WebsiteConfigFindUniqueArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebsiteConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsiteConfigFindUniqueOrThrowArgs} args - Arguments to find a WebsiteConfig
     * @example
     * // Get one WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsiteConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsiteConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigFindFirstArgs} args - Arguments to find a WebsiteConfig
     * @example
     * // Get one WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsiteConfigFindFirstArgs>(args?: SelectSubset<T, WebsiteConfigFindFirstArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebsiteConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigFindFirstOrThrowArgs} args - Arguments to find a WebsiteConfig
     * @example
     * // Get one WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsiteConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsiteConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebsiteConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebsiteConfigs
     * const websiteConfigs = await prisma.websiteConfig.findMany()
     * 
     * // Get first 10 WebsiteConfigs
     * const websiteConfigs = await prisma.websiteConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websiteConfigWithIdOnly = await prisma.websiteConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsiteConfigFindManyArgs>(args?: SelectSubset<T, WebsiteConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebsiteConfig.
     * @param {WebsiteConfigCreateArgs} args - Arguments to create a WebsiteConfig.
     * @example
     * // Create one WebsiteConfig
     * const WebsiteConfig = await prisma.websiteConfig.create({
     *   data: {
     *     // ... data to create a WebsiteConfig
     *   }
     * })
     * 
     */
    create<T extends WebsiteConfigCreateArgs>(args: SelectSubset<T, WebsiteConfigCreateArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebsiteConfigs.
     * @param {WebsiteConfigCreateManyArgs} args - Arguments to create many WebsiteConfigs.
     * @example
     * // Create many WebsiteConfigs
     * const websiteConfig = await prisma.websiteConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsiteConfigCreateManyArgs>(args?: SelectSubset<T, WebsiteConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebsiteConfigs and returns the data saved in the database.
     * @param {WebsiteConfigCreateManyAndReturnArgs} args - Arguments to create many WebsiteConfigs.
     * @example
     * // Create many WebsiteConfigs
     * const websiteConfig = await prisma.websiteConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebsiteConfigs and only return the `id`
     * const websiteConfigWithIdOnly = await prisma.websiteConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebsiteConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WebsiteConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebsiteConfig.
     * @param {WebsiteConfigDeleteArgs} args - Arguments to delete one WebsiteConfig.
     * @example
     * // Delete one WebsiteConfig
     * const WebsiteConfig = await prisma.websiteConfig.delete({
     *   where: {
     *     // ... filter to delete one WebsiteConfig
     *   }
     * })
     * 
     */
    delete<T extends WebsiteConfigDeleteArgs>(args: SelectSubset<T, WebsiteConfigDeleteArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebsiteConfig.
     * @param {WebsiteConfigUpdateArgs} args - Arguments to update one WebsiteConfig.
     * @example
     * // Update one WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsiteConfigUpdateArgs>(args: SelectSubset<T, WebsiteConfigUpdateArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebsiteConfigs.
     * @param {WebsiteConfigDeleteManyArgs} args - Arguments to filter WebsiteConfigs to delete.
     * @example
     * // Delete a few WebsiteConfigs
     * const { count } = await prisma.websiteConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsiteConfigDeleteManyArgs>(args?: SelectSubset<T, WebsiteConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebsiteConfigs
     * const websiteConfig = await prisma.websiteConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsiteConfigUpdateManyArgs>(args: SelectSubset<T, WebsiteConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebsiteConfigs and returns the data updated in the database.
     * @param {WebsiteConfigUpdateManyAndReturnArgs} args - Arguments to update many WebsiteConfigs.
     * @example
     * // Update many WebsiteConfigs
     * const websiteConfig = await prisma.websiteConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebsiteConfigs and only return the `id`
     * const websiteConfigWithIdOnly = await prisma.websiteConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebsiteConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, WebsiteConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebsiteConfig.
     * @param {WebsiteConfigUpsertArgs} args - Arguments to update or create a WebsiteConfig.
     * @example
     * // Update or create a WebsiteConfig
     * const websiteConfig = await prisma.websiteConfig.upsert({
     *   create: {
     *     // ... data to create a WebsiteConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebsiteConfig we want to update
     *   }
     * })
     */
    upsert<T extends WebsiteConfigUpsertArgs>(args: SelectSubset<T, WebsiteConfigUpsertArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebsiteConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigCountArgs} args - Arguments to filter WebsiteConfigs to count.
     * @example
     * // Count the number of WebsiteConfigs
     * const count = await prisma.websiteConfig.count({
     *   where: {
     *     // ... the filter for the WebsiteConfigs we want to count
     *   }
     * })
    **/
    count<T extends WebsiteConfigCountArgs>(
      args?: Subset<T, WebsiteConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsiteConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebsiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsiteConfigAggregateArgs>(args: Subset<T, WebsiteConfigAggregateArgs>): Prisma.PrismaPromise<GetWebsiteConfigAggregateType<T>>

    /**
     * Group by WebsiteConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsiteConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsiteConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsiteConfigGroupByArgs['orderBy'] }
        : { orderBy?: WebsiteConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsiteConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsiteConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebsiteConfig model
   */
  readonly fields: WebsiteConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebsiteConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsiteConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modules<T extends WebsiteConfig$modulesArgs<ExtArgs> = {}>(args?: Subset<T, WebsiteConfig$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebsiteConfig model
   */
  interface WebsiteConfigFieldRefs {
    readonly id: FieldRef<"WebsiteConfig", 'String'>
    readonly tenantId: FieldRef<"WebsiteConfig", 'String'>
    readonly createdAt: FieldRef<"WebsiteConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"WebsiteConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebsiteConfig findUnique
   */
  export type WebsiteConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteConfig to fetch.
     */
    where: WebsiteConfigWhereUniqueInput
  }

  /**
   * WebsiteConfig findUniqueOrThrow
   */
  export type WebsiteConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteConfig to fetch.
     */
    where: WebsiteConfigWhereUniqueInput
  }

  /**
   * WebsiteConfig findFirst
   */
  export type WebsiteConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteConfig to fetch.
     */
    where?: WebsiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteConfigs to fetch.
     */
    orderBy?: WebsiteConfigOrderByWithRelationInput | WebsiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteConfigs.
     */
    cursor?: WebsiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteConfigs.
     */
    distinct?: WebsiteConfigScalarFieldEnum | WebsiteConfigScalarFieldEnum[]
  }

  /**
   * WebsiteConfig findFirstOrThrow
   */
  export type WebsiteConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteConfig to fetch.
     */
    where?: WebsiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteConfigs to fetch.
     */
    orderBy?: WebsiteConfigOrderByWithRelationInput | WebsiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebsiteConfigs.
     */
    cursor?: WebsiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebsiteConfigs.
     */
    distinct?: WebsiteConfigScalarFieldEnum | WebsiteConfigScalarFieldEnum[]
  }

  /**
   * WebsiteConfig findMany
   */
  export type WebsiteConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebsiteConfigs to fetch.
     */
    where?: WebsiteConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebsiteConfigs to fetch.
     */
    orderBy?: WebsiteConfigOrderByWithRelationInput | WebsiteConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebsiteConfigs.
     */
    cursor?: WebsiteConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebsiteConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebsiteConfigs.
     */
    skip?: number
    distinct?: WebsiteConfigScalarFieldEnum | WebsiteConfigScalarFieldEnum[]
  }

  /**
   * WebsiteConfig create
   */
  export type WebsiteConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WebsiteConfig.
     */
    data: XOR<WebsiteConfigCreateInput, WebsiteConfigUncheckedCreateInput>
  }

  /**
   * WebsiteConfig createMany
   */
  export type WebsiteConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebsiteConfigs.
     */
    data: WebsiteConfigCreateManyInput | WebsiteConfigCreateManyInput[]
  }

  /**
   * WebsiteConfig createManyAndReturn
   */
  export type WebsiteConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * The data used to create many WebsiteConfigs.
     */
    data: WebsiteConfigCreateManyInput | WebsiteConfigCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteConfig update
   */
  export type WebsiteConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WebsiteConfig.
     */
    data: XOR<WebsiteConfigUpdateInput, WebsiteConfigUncheckedUpdateInput>
    /**
     * Choose, which WebsiteConfig to update.
     */
    where: WebsiteConfigWhereUniqueInput
  }

  /**
   * WebsiteConfig updateMany
   */
  export type WebsiteConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebsiteConfigs.
     */
    data: XOR<WebsiteConfigUpdateManyMutationInput, WebsiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteConfigs to update
     */
    where?: WebsiteConfigWhereInput
    /**
     * Limit how many WebsiteConfigs to update.
     */
    limit?: number
  }

  /**
   * WebsiteConfig updateManyAndReturn
   */
  export type WebsiteConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * The data used to update WebsiteConfigs.
     */
    data: XOR<WebsiteConfigUpdateManyMutationInput, WebsiteConfigUncheckedUpdateManyInput>
    /**
     * Filter which WebsiteConfigs to update
     */
    where?: WebsiteConfigWhereInput
    /**
     * Limit how many WebsiteConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebsiteConfig upsert
   */
  export type WebsiteConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WebsiteConfig to update in case it exists.
     */
    where: WebsiteConfigWhereUniqueInput
    /**
     * In case the WebsiteConfig found by the `where` argument doesn't exist, create a new WebsiteConfig with this data.
     */
    create: XOR<WebsiteConfigCreateInput, WebsiteConfigUncheckedCreateInput>
    /**
     * In case the WebsiteConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsiteConfigUpdateInput, WebsiteConfigUncheckedUpdateInput>
  }

  /**
   * WebsiteConfig delete
   */
  export type WebsiteConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
    /**
     * Filter which WebsiteConfig to delete.
     */
    where: WebsiteConfigWhereUniqueInput
  }

  /**
   * WebsiteConfig deleteMany
   */
  export type WebsiteConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebsiteConfigs to delete
     */
    where?: WebsiteConfigWhereInput
    /**
     * Limit how many WebsiteConfigs to delete.
     */
    limit?: number
  }

  /**
   * WebsiteConfig.modules
   */
  export type WebsiteConfig$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    where?: ModuleConfigWhereInput
    orderBy?: ModuleConfigOrderByWithRelationInput | ModuleConfigOrderByWithRelationInput[]
    cursor?: ModuleConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleConfigScalarFieldEnum | ModuleConfigScalarFieldEnum[]
  }

  /**
   * WebsiteConfig without action
   */
  export type WebsiteConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebsiteConfig
     */
    select?: WebsiteConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebsiteConfig
     */
    omit?: WebsiteConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsiteConfigInclude<ExtArgs> | null
  }


  /**
   * Model TenantControlSettings
   */

  export type AggregateTenantControlSettings = {
    _count: TenantControlSettingsCountAggregateOutputType | null
    _min: TenantControlSettingsMinAggregateOutputType | null
    _max: TenantControlSettingsMaxAggregateOutputType | null
  }

  export type TenantControlSettingsMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    planCode: string | null
    featureFlagsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantControlSettingsMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    planCode: string | null
    featureFlagsJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantControlSettingsCountAggregateOutputType = {
    id: number
    tenantId: number
    status: number
    planCode: number
    featureFlagsJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantControlSettingsMinAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    featureFlagsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantControlSettingsMaxAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    featureFlagsJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantControlSettingsCountAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    featureFlagsJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantControlSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantControlSettings to aggregate.
     */
    where?: TenantControlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlSettings to fetch.
     */
    orderBy?: TenantControlSettingsOrderByWithRelationInput | TenantControlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantControlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantControlSettings
    **/
    _count?: true | TenantControlSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantControlSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantControlSettingsMaxAggregateInputType
  }

  export type GetTenantControlSettingsAggregateType<T extends TenantControlSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantControlSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantControlSettings[P]>
      : GetScalarType<T[P], AggregateTenantControlSettings[P]>
  }




  export type TenantControlSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantControlSettingsWhereInput
    orderBy?: TenantControlSettingsOrderByWithAggregationInput | TenantControlSettingsOrderByWithAggregationInput[]
    by: TenantControlSettingsScalarFieldEnum[] | TenantControlSettingsScalarFieldEnum
    having?: TenantControlSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantControlSettingsCountAggregateInputType | true
    _min?: TenantControlSettingsMinAggregateInputType
    _max?: TenantControlSettingsMaxAggregateInputType
  }

  export type TenantControlSettingsGroupByOutputType = {
    id: string
    tenantId: string
    status: string
    planCode: string
    featureFlagsJson: string
    createdAt: Date
    updatedAt: Date
    _count: TenantControlSettingsCountAggregateOutputType | null
    _min: TenantControlSettingsMinAggregateOutputType | null
    _max: TenantControlSettingsMaxAggregateOutputType | null
  }

  type GetTenantControlSettingsGroupByPayload<T extends TenantControlSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantControlSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantControlSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantControlSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], TenantControlSettingsGroupByOutputType[P]>
        }
      >
    >


  export type TenantControlSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    featureFlagsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlSettings"]>

  export type TenantControlSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    featureFlagsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlSettings"]>

  export type TenantControlSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    featureFlagsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlSettings"]>

  export type TenantControlSettingsSelectScalar = {
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    featureFlagsJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantControlSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "status" | "planCode" | "featureFlagsJson" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantControlSettings"]>
  export type TenantControlSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantControlSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantControlSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantControlSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantControlSettings"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      status: string
      planCode: string
      featureFlagsJson: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantControlSettings"]>
    composites: {}
  }

  type TenantControlSettingsGetPayload<S extends boolean | null | undefined | TenantControlSettingsDefaultArgs> = $Result.GetResult<Prisma.$TenantControlSettingsPayload, S>

  type TenantControlSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantControlSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantControlSettingsCountAggregateInputType | true
    }

  export interface TenantControlSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantControlSettings'], meta: { name: 'TenantControlSettings' } }
    /**
     * Find zero or one TenantControlSettings that matches the filter.
     * @param {TenantControlSettingsFindUniqueArgs} args - Arguments to find a TenantControlSettings
     * @example
     * // Get one TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantControlSettingsFindUniqueArgs>(args: SelectSubset<T, TenantControlSettingsFindUniqueArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantControlSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantControlSettingsFindUniqueOrThrowArgs} args - Arguments to find a TenantControlSettings
     * @example
     * // Get one TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantControlSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantControlSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantControlSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsFindFirstArgs} args - Arguments to find a TenantControlSettings
     * @example
     * // Get one TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantControlSettingsFindFirstArgs>(args?: SelectSubset<T, TenantControlSettingsFindFirstArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantControlSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsFindFirstOrThrowArgs} args - Arguments to find a TenantControlSettings
     * @example
     * // Get one TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantControlSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantControlSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantControlSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findMany()
     * 
     * // Get first 10 TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantControlSettingsWithIdOnly = await prisma.tenantControlSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantControlSettingsFindManyArgs>(args?: SelectSubset<T, TenantControlSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantControlSettings.
     * @param {TenantControlSettingsCreateArgs} args - Arguments to create a TenantControlSettings.
     * @example
     * // Create one TenantControlSettings
     * const TenantControlSettings = await prisma.tenantControlSettings.create({
     *   data: {
     *     // ... data to create a TenantControlSettings
     *   }
     * })
     * 
     */
    create<T extends TenantControlSettingsCreateArgs>(args: SelectSubset<T, TenantControlSettingsCreateArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantControlSettings.
     * @param {TenantControlSettingsCreateManyArgs} args - Arguments to create many TenantControlSettings.
     * @example
     * // Create many TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantControlSettingsCreateManyArgs>(args?: SelectSubset<T, TenantControlSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantControlSettings and returns the data saved in the database.
     * @param {TenantControlSettingsCreateManyAndReturnArgs} args - Arguments to create many TenantControlSettings.
     * @example
     * // Create many TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantControlSettings and only return the `id`
     * const tenantControlSettingsWithIdOnly = await prisma.tenantControlSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantControlSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantControlSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantControlSettings.
     * @param {TenantControlSettingsDeleteArgs} args - Arguments to delete one TenantControlSettings.
     * @example
     * // Delete one TenantControlSettings
     * const TenantControlSettings = await prisma.tenantControlSettings.delete({
     *   where: {
     *     // ... filter to delete one TenantControlSettings
     *   }
     * })
     * 
     */
    delete<T extends TenantControlSettingsDeleteArgs>(args: SelectSubset<T, TenantControlSettingsDeleteArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantControlSettings.
     * @param {TenantControlSettingsUpdateArgs} args - Arguments to update one TenantControlSettings.
     * @example
     * // Update one TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantControlSettingsUpdateArgs>(args: SelectSubset<T, TenantControlSettingsUpdateArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantControlSettings.
     * @param {TenantControlSettingsDeleteManyArgs} args - Arguments to filter TenantControlSettings to delete.
     * @example
     * // Delete a few TenantControlSettings
     * const { count } = await prisma.tenantControlSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantControlSettingsDeleteManyArgs>(args?: SelectSubset<T, TenantControlSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantControlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantControlSettingsUpdateManyArgs>(args: SelectSubset<T, TenantControlSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantControlSettings and returns the data updated in the database.
     * @param {TenantControlSettingsUpdateManyAndReturnArgs} args - Arguments to update many TenantControlSettings.
     * @example
     * // Update many TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantControlSettings and only return the `id`
     * const tenantControlSettingsWithIdOnly = await prisma.tenantControlSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantControlSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantControlSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantControlSettings.
     * @param {TenantControlSettingsUpsertArgs} args - Arguments to update or create a TenantControlSettings.
     * @example
     * // Update or create a TenantControlSettings
     * const tenantControlSettings = await prisma.tenantControlSettings.upsert({
     *   create: {
     *     // ... data to create a TenantControlSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantControlSettings we want to update
     *   }
     * })
     */
    upsert<T extends TenantControlSettingsUpsertArgs>(args: SelectSubset<T, TenantControlSettingsUpsertArgs<ExtArgs>>): Prisma__TenantControlSettingsClient<$Result.GetResult<Prisma.$TenantControlSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantControlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsCountArgs} args - Arguments to filter TenantControlSettings to count.
     * @example
     * // Count the number of TenantControlSettings
     * const count = await prisma.tenantControlSettings.count({
     *   where: {
     *     // ... the filter for the TenantControlSettings we want to count
     *   }
     * })
    **/
    count<T extends TenantControlSettingsCountArgs>(
      args?: Subset<T, TenantControlSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantControlSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantControlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantControlSettingsAggregateArgs>(args: Subset<T, TenantControlSettingsAggregateArgs>): Prisma.PrismaPromise<GetTenantControlSettingsAggregateType<T>>

    /**
     * Group by TenantControlSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantControlSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantControlSettingsGroupByArgs['orderBy'] }
        : { orderBy?: TenantControlSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantControlSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantControlSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantControlSettings model
   */
  readonly fields: TenantControlSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantControlSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantControlSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantControlSettings model
   */
  interface TenantControlSettingsFieldRefs {
    readonly id: FieldRef<"TenantControlSettings", 'String'>
    readonly tenantId: FieldRef<"TenantControlSettings", 'String'>
    readonly status: FieldRef<"TenantControlSettings", 'String'>
    readonly planCode: FieldRef<"TenantControlSettings", 'String'>
    readonly featureFlagsJson: FieldRef<"TenantControlSettings", 'String'>
    readonly createdAt: FieldRef<"TenantControlSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantControlSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantControlSettings findUnique
   */
  export type TenantControlSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlSettings to fetch.
     */
    where: TenantControlSettingsWhereUniqueInput
  }

  /**
   * TenantControlSettings findUniqueOrThrow
   */
  export type TenantControlSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlSettings to fetch.
     */
    where: TenantControlSettingsWhereUniqueInput
  }

  /**
   * TenantControlSettings findFirst
   */
  export type TenantControlSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlSettings to fetch.
     */
    where?: TenantControlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlSettings to fetch.
     */
    orderBy?: TenantControlSettingsOrderByWithRelationInput | TenantControlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantControlSettings.
     */
    cursor?: TenantControlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantControlSettings.
     */
    distinct?: TenantControlSettingsScalarFieldEnum | TenantControlSettingsScalarFieldEnum[]
  }

  /**
   * TenantControlSettings findFirstOrThrow
   */
  export type TenantControlSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlSettings to fetch.
     */
    where?: TenantControlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlSettings to fetch.
     */
    orderBy?: TenantControlSettingsOrderByWithRelationInput | TenantControlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantControlSettings.
     */
    cursor?: TenantControlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantControlSettings.
     */
    distinct?: TenantControlSettingsScalarFieldEnum | TenantControlSettingsScalarFieldEnum[]
  }

  /**
   * TenantControlSettings findMany
   */
  export type TenantControlSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlSettings to fetch.
     */
    where?: TenantControlSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlSettings to fetch.
     */
    orderBy?: TenantControlSettingsOrderByWithRelationInput | TenantControlSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantControlSettings.
     */
    cursor?: TenantControlSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlSettings.
     */
    skip?: number
    distinct?: TenantControlSettingsScalarFieldEnum | TenantControlSettingsScalarFieldEnum[]
  }

  /**
   * TenantControlSettings create
   */
  export type TenantControlSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantControlSettings.
     */
    data: XOR<TenantControlSettingsCreateInput, TenantControlSettingsUncheckedCreateInput>
  }

  /**
   * TenantControlSettings createMany
   */
  export type TenantControlSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantControlSettings.
     */
    data: TenantControlSettingsCreateManyInput | TenantControlSettingsCreateManyInput[]
  }

  /**
   * TenantControlSettings createManyAndReturn
   */
  export type TenantControlSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many TenantControlSettings.
     */
    data: TenantControlSettingsCreateManyInput | TenantControlSettingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantControlSettings update
   */
  export type TenantControlSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantControlSettings.
     */
    data: XOR<TenantControlSettingsUpdateInput, TenantControlSettingsUncheckedUpdateInput>
    /**
     * Choose, which TenantControlSettings to update.
     */
    where: TenantControlSettingsWhereUniqueInput
  }

  /**
   * TenantControlSettings updateMany
   */
  export type TenantControlSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantControlSettings.
     */
    data: XOR<TenantControlSettingsUpdateManyMutationInput, TenantControlSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantControlSettings to update
     */
    where?: TenantControlSettingsWhereInput
    /**
     * Limit how many TenantControlSettings to update.
     */
    limit?: number
  }

  /**
   * TenantControlSettings updateManyAndReturn
   */
  export type TenantControlSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * The data used to update TenantControlSettings.
     */
    data: XOR<TenantControlSettingsUpdateManyMutationInput, TenantControlSettingsUncheckedUpdateManyInput>
    /**
     * Filter which TenantControlSettings to update
     */
    where?: TenantControlSettingsWhereInput
    /**
     * Limit how many TenantControlSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantControlSettings upsert
   */
  export type TenantControlSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantControlSettings to update in case it exists.
     */
    where: TenantControlSettingsWhereUniqueInput
    /**
     * In case the TenantControlSettings found by the `where` argument doesn't exist, create a new TenantControlSettings with this data.
     */
    create: XOR<TenantControlSettingsCreateInput, TenantControlSettingsUncheckedCreateInput>
    /**
     * In case the TenantControlSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantControlSettingsUpdateInput, TenantControlSettingsUncheckedUpdateInput>
  }

  /**
   * TenantControlSettings delete
   */
  export type TenantControlSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
    /**
     * Filter which TenantControlSettings to delete.
     */
    where: TenantControlSettingsWhereUniqueInput
  }

  /**
   * TenantControlSettings deleteMany
   */
  export type TenantControlSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantControlSettings to delete
     */
    where?: TenantControlSettingsWhereInput
    /**
     * Limit how many TenantControlSettings to delete.
     */
    limit?: number
  }

  /**
   * TenantControlSettings without action
   */
  export type TenantControlSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlSettings
     */
    select?: TenantControlSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlSettings
     */
    omit?: TenantControlSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlSettingsInclude<ExtArgs> | null
  }


  /**
   * Model TenantBillingSubscription
   */

  export type AggregateTenantBillingSubscription = {
    _count: TenantBillingSubscriptionCountAggregateOutputType | null
    _min: TenantBillingSubscriptionMinAggregateOutputType | null
    _max: TenantBillingSubscriptionMaxAggregateOutputType | null
  }

  export type TenantBillingSubscriptionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    planCode: string | null
    status: string | null
    paymentStatus: string | null
    billingProvider: string | null
    billingCustomerId: string | null
    billingSubscriptionId: string | null
    trialEndsAt: Date | null
    currentPeriodEndsAt: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantBillingSubscriptionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    planCode: string | null
    status: string | null
    paymentStatus: string | null
    billingProvider: string | null
    billingCustomerId: string | null
    billingSubscriptionId: string | null
    trialEndsAt: Date | null
    currentPeriodEndsAt: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantBillingSubscriptionCountAggregateOutputType = {
    id: number
    tenantId: number
    planCode: number
    status: number
    paymentStatus: number
    billingProvider: number
    billingCustomerId: number
    billingSubscriptionId: number
    trialEndsAt: number
    currentPeriodEndsAt: number
    cancelAtPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantBillingSubscriptionMinAggregateInputType = {
    id?: true
    tenantId?: true
    planCode?: true
    status?: true
    paymentStatus?: true
    billingProvider?: true
    billingCustomerId?: true
    billingSubscriptionId?: true
    trialEndsAt?: true
    currentPeriodEndsAt?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantBillingSubscriptionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    planCode?: true
    status?: true
    paymentStatus?: true
    billingProvider?: true
    billingCustomerId?: true
    billingSubscriptionId?: true
    trialEndsAt?: true
    currentPeriodEndsAt?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantBillingSubscriptionCountAggregateInputType = {
    id?: true
    tenantId?: true
    planCode?: true
    status?: true
    paymentStatus?: true
    billingProvider?: true
    billingCustomerId?: true
    billingSubscriptionId?: true
    trialEndsAt?: true
    currentPeriodEndsAt?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantBillingSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBillingSubscription to aggregate.
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSubscriptions to fetch.
     */
    orderBy?: TenantBillingSubscriptionOrderByWithRelationInput | TenantBillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantBillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantBillingSubscriptions
    **/
    _count?: true | TenantBillingSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantBillingSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantBillingSubscriptionMaxAggregateInputType
  }

  export type GetTenantBillingSubscriptionAggregateType<T extends TenantBillingSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantBillingSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantBillingSubscription[P]>
      : GetScalarType<T[P], AggregateTenantBillingSubscription[P]>
  }




  export type TenantBillingSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantBillingSubscriptionWhereInput
    orderBy?: TenantBillingSubscriptionOrderByWithAggregationInput | TenantBillingSubscriptionOrderByWithAggregationInput[]
    by: TenantBillingSubscriptionScalarFieldEnum[] | TenantBillingSubscriptionScalarFieldEnum
    having?: TenantBillingSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantBillingSubscriptionCountAggregateInputType | true
    _min?: TenantBillingSubscriptionMinAggregateInputType
    _max?: TenantBillingSubscriptionMaxAggregateInputType
  }

  export type TenantBillingSubscriptionGroupByOutputType = {
    id: string
    tenantId: string
    planCode: string
    status: string
    paymentStatus: string
    billingProvider: string
    billingCustomerId: string | null
    billingSubscriptionId: string | null
    trialEndsAt: Date | null
    currentPeriodEndsAt: Date | null
    cancelAtPeriodEnd: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantBillingSubscriptionCountAggregateOutputType | null
    _min: TenantBillingSubscriptionMinAggregateOutputType | null
    _max: TenantBillingSubscriptionMaxAggregateOutputType | null
  }

  type GetTenantBillingSubscriptionGroupByPayload<T extends TenantBillingSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantBillingSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantBillingSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantBillingSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], TenantBillingSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type TenantBillingSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planCode?: boolean
    status?: boolean
    paymentStatus?: boolean
    billingProvider?: boolean
    billingCustomerId?: boolean
    billingSubscriptionId?: boolean
    trialEndsAt?: boolean
    currentPeriodEndsAt?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantBillingSubscription"]>

  export type TenantBillingSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planCode?: boolean
    status?: boolean
    paymentStatus?: boolean
    billingProvider?: boolean
    billingCustomerId?: boolean
    billingSubscriptionId?: boolean
    trialEndsAt?: boolean
    currentPeriodEndsAt?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantBillingSubscription"]>

  export type TenantBillingSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    planCode?: boolean
    status?: boolean
    paymentStatus?: boolean
    billingProvider?: boolean
    billingCustomerId?: boolean
    billingSubscriptionId?: boolean
    trialEndsAt?: boolean
    currentPeriodEndsAt?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantBillingSubscription"]>

  export type TenantBillingSubscriptionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    planCode?: boolean
    status?: boolean
    paymentStatus?: boolean
    billingProvider?: boolean
    billingCustomerId?: boolean
    billingSubscriptionId?: boolean
    trialEndsAt?: boolean
    currentPeriodEndsAt?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantBillingSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "planCode" | "status" | "paymentStatus" | "billingProvider" | "billingCustomerId" | "billingSubscriptionId" | "trialEndsAt" | "currentPeriodEndsAt" | "cancelAtPeriodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantBillingSubscription"]>
  export type TenantBillingSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantBillingSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantBillingSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantBillingSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantBillingSubscription"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      planCode: string
      status: string
      paymentStatus: string
      billingProvider: string
      billingCustomerId: string | null
      billingSubscriptionId: string | null
      trialEndsAt: Date | null
      currentPeriodEndsAt: Date | null
      cancelAtPeriodEnd: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantBillingSubscription"]>
    composites: {}
  }

  type TenantBillingSubscriptionGetPayload<S extends boolean | null | undefined | TenantBillingSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$TenantBillingSubscriptionPayload, S>

  type TenantBillingSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantBillingSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantBillingSubscriptionCountAggregateInputType | true
    }

  export interface TenantBillingSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantBillingSubscription'], meta: { name: 'TenantBillingSubscription' } }
    /**
     * Find zero or one TenantBillingSubscription that matches the filter.
     * @param {TenantBillingSubscriptionFindUniqueArgs} args - Arguments to find a TenantBillingSubscription
     * @example
     * // Get one TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantBillingSubscriptionFindUniqueArgs>(args: SelectSubset<T, TenantBillingSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantBillingSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantBillingSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a TenantBillingSubscription
     * @example
     * // Get one TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantBillingSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantBillingSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantBillingSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionFindFirstArgs} args - Arguments to find a TenantBillingSubscription
     * @example
     * // Get one TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantBillingSubscriptionFindFirstArgs>(args?: SelectSubset<T, TenantBillingSubscriptionFindFirstArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantBillingSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionFindFirstOrThrowArgs} args - Arguments to find a TenantBillingSubscription
     * @example
     * // Get one TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantBillingSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantBillingSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantBillingSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantBillingSubscriptions
     * const tenantBillingSubscriptions = await prisma.tenantBillingSubscription.findMany()
     * 
     * // Get first 10 TenantBillingSubscriptions
     * const tenantBillingSubscriptions = await prisma.tenantBillingSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantBillingSubscriptionWithIdOnly = await prisma.tenantBillingSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantBillingSubscriptionFindManyArgs>(args?: SelectSubset<T, TenantBillingSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantBillingSubscription.
     * @param {TenantBillingSubscriptionCreateArgs} args - Arguments to create a TenantBillingSubscription.
     * @example
     * // Create one TenantBillingSubscription
     * const TenantBillingSubscription = await prisma.tenantBillingSubscription.create({
     *   data: {
     *     // ... data to create a TenantBillingSubscription
     *   }
     * })
     * 
     */
    create<T extends TenantBillingSubscriptionCreateArgs>(args: SelectSubset<T, TenantBillingSubscriptionCreateArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantBillingSubscriptions.
     * @param {TenantBillingSubscriptionCreateManyArgs} args - Arguments to create many TenantBillingSubscriptions.
     * @example
     * // Create many TenantBillingSubscriptions
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantBillingSubscriptionCreateManyArgs>(args?: SelectSubset<T, TenantBillingSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantBillingSubscriptions and returns the data saved in the database.
     * @param {TenantBillingSubscriptionCreateManyAndReturnArgs} args - Arguments to create many TenantBillingSubscriptions.
     * @example
     * // Create many TenantBillingSubscriptions
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantBillingSubscriptions and only return the `id`
     * const tenantBillingSubscriptionWithIdOnly = await prisma.tenantBillingSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantBillingSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantBillingSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantBillingSubscription.
     * @param {TenantBillingSubscriptionDeleteArgs} args - Arguments to delete one TenantBillingSubscription.
     * @example
     * // Delete one TenantBillingSubscription
     * const TenantBillingSubscription = await prisma.tenantBillingSubscription.delete({
     *   where: {
     *     // ... filter to delete one TenantBillingSubscription
     *   }
     * })
     * 
     */
    delete<T extends TenantBillingSubscriptionDeleteArgs>(args: SelectSubset<T, TenantBillingSubscriptionDeleteArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantBillingSubscription.
     * @param {TenantBillingSubscriptionUpdateArgs} args - Arguments to update one TenantBillingSubscription.
     * @example
     * // Update one TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantBillingSubscriptionUpdateArgs>(args: SelectSubset<T, TenantBillingSubscriptionUpdateArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantBillingSubscriptions.
     * @param {TenantBillingSubscriptionDeleteManyArgs} args - Arguments to filter TenantBillingSubscriptions to delete.
     * @example
     * // Delete a few TenantBillingSubscriptions
     * const { count } = await prisma.tenantBillingSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantBillingSubscriptionDeleteManyArgs>(args?: SelectSubset<T, TenantBillingSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantBillingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantBillingSubscriptions
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantBillingSubscriptionUpdateManyArgs>(args: SelectSubset<T, TenantBillingSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantBillingSubscriptions and returns the data updated in the database.
     * @param {TenantBillingSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many TenantBillingSubscriptions.
     * @example
     * // Update many TenantBillingSubscriptions
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantBillingSubscriptions and only return the `id`
     * const tenantBillingSubscriptionWithIdOnly = await prisma.tenantBillingSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantBillingSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantBillingSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantBillingSubscription.
     * @param {TenantBillingSubscriptionUpsertArgs} args - Arguments to update or create a TenantBillingSubscription.
     * @example
     * // Update or create a TenantBillingSubscription
     * const tenantBillingSubscription = await prisma.tenantBillingSubscription.upsert({
     *   create: {
     *     // ... data to create a TenantBillingSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantBillingSubscription we want to update
     *   }
     * })
     */
    upsert<T extends TenantBillingSubscriptionUpsertArgs>(args: SelectSubset<T, TenantBillingSubscriptionUpsertArgs<ExtArgs>>): Prisma__TenantBillingSubscriptionClient<$Result.GetResult<Prisma.$TenantBillingSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantBillingSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionCountArgs} args - Arguments to filter TenantBillingSubscriptions to count.
     * @example
     * // Count the number of TenantBillingSubscriptions
     * const count = await prisma.tenantBillingSubscription.count({
     *   where: {
     *     // ... the filter for the TenantBillingSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends TenantBillingSubscriptionCountArgs>(
      args?: Subset<T, TenantBillingSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantBillingSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantBillingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantBillingSubscriptionAggregateArgs>(args: Subset<T, TenantBillingSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetTenantBillingSubscriptionAggregateType<T>>

    /**
     * Group by TenantBillingSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantBillingSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantBillingSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: TenantBillingSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantBillingSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantBillingSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantBillingSubscription model
   */
  readonly fields: TenantBillingSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantBillingSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantBillingSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantBillingSubscription model
   */
  interface TenantBillingSubscriptionFieldRefs {
    readonly id: FieldRef<"TenantBillingSubscription", 'String'>
    readonly tenantId: FieldRef<"TenantBillingSubscription", 'String'>
    readonly planCode: FieldRef<"TenantBillingSubscription", 'String'>
    readonly status: FieldRef<"TenantBillingSubscription", 'String'>
    readonly paymentStatus: FieldRef<"TenantBillingSubscription", 'String'>
    readonly billingProvider: FieldRef<"TenantBillingSubscription", 'String'>
    readonly billingCustomerId: FieldRef<"TenantBillingSubscription", 'String'>
    readonly billingSubscriptionId: FieldRef<"TenantBillingSubscription", 'String'>
    readonly trialEndsAt: FieldRef<"TenantBillingSubscription", 'DateTime'>
    readonly currentPeriodEndsAt: FieldRef<"TenantBillingSubscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"TenantBillingSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"TenantBillingSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantBillingSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantBillingSubscription findUnique
   */
  export type TenantBillingSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TenantBillingSubscription to fetch.
     */
    where: TenantBillingSubscriptionWhereUniqueInput
  }

  /**
   * TenantBillingSubscription findUniqueOrThrow
   */
  export type TenantBillingSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TenantBillingSubscription to fetch.
     */
    where: TenantBillingSubscriptionWhereUniqueInput
  }

  /**
   * TenantBillingSubscription findFirst
   */
  export type TenantBillingSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TenantBillingSubscription to fetch.
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSubscriptions to fetch.
     */
    orderBy?: TenantBillingSubscriptionOrderByWithRelationInput | TenantBillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBillingSubscriptions.
     */
    cursor?: TenantBillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBillingSubscriptions.
     */
    distinct?: TenantBillingSubscriptionScalarFieldEnum | TenantBillingSubscriptionScalarFieldEnum[]
  }

  /**
   * TenantBillingSubscription findFirstOrThrow
   */
  export type TenantBillingSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TenantBillingSubscription to fetch.
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSubscriptions to fetch.
     */
    orderBy?: TenantBillingSubscriptionOrderByWithRelationInput | TenantBillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBillingSubscriptions.
     */
    cursor?: TenantBillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBillingSubscriptions.
     */
    distinct?: TenantBillingSubscriptionScalarFieldEnum | TenantBillingSubscriptionScalarFieldEnum[]
  }

  /**
   * TenantBillingSubscription findMany
   */
  export type TenantBillingSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TenantBillingSubscriptions to fetch.
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSubscriptions to fetch.
     */
    orderBy?: TenantBillingSubscriptionOrderByWithRelationInput | TenantBillingSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantBillingSubscriptions.
     */
    cursor?: TenantBillingSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSubscriptions.
     */
    skip?: number
    distinct?: TenantBillingSubscriptionScalarFieldEnum | TenantBillingSubscriptionScalarFieldEnum[]
  }

  /**
   * TenantBillingSubscription create
   */
  export type TenantBillingSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantBillingSubscription.
     */
    data: XOR<TenantBillingSubscriptionCreateInput, TenantBillingSubscriptionUncheckedCreateInput>
  }

  /**
   * TenantBillingSubscription createMany
   */
  export type TenantBillingSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantBillingSubscriptions.
     */
    data: TenantBillingSubscriptionCreateManyInput | TenantBillingSubscriptionCreateManyInput[]
  }

  /**
   * TenantBillingSubscription createManyAndReturn
   */
  export type TenantBillingSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many TenantBillingSubscriptions.
     */
    data: TenantBillingSubscriptionCreateManyInput | TenantBillingSubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantBillingSubscription update
   */
  export type TenantBillingSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantBillingSubscription.
     */
    data: XOR<TenantBillingSubscriptionUpdateInput, TenantBillingSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which TenantBillingSubscription to update.
     */
    where: TenantBillingSubscriptionWhereUniqueInput
  }

  /**
   * TenantBillingSubscription updateMany
   */
  export type TenantBillingSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantBillingSubscriptions.
     */
    data: XOR<TenantBillingSubscriptionUpdateManyMutationInput, TenantBillingSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which TenantBillingSubscriptions to update
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * Limit how many TenantBillingSubscriptions to update.
     */
    limit?: number
  }

  /**
   * TenantBillingSubscription updateManyAndReturn
   */
  export type TenantBillingSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update TenantBillingSubscriptions.
     */
    data: XOR<TenantBillingSubscriptionUpdateManyMutationInput, TenantBillingSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which TenantBillingSubscriptions to update
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * Limit how many TenantBillingSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantBillingSubscription upsert
   */
  export type TenantBillingSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantBillingSubscription to update in case it exists.
     */
    where: TenantBillingSubscriptionWhereUniqueInput
    /**
     * In case the TenantBillingSubscription found by the `where` argument doesn't exist, create a new TenantBillingSubscription with this data.
     */
    create: XOR<TenantBillingSubscriptionCreateInput, TenantBillingSubscriptionUncheckedCreateInput>
    /**
     * In case the TenantBillingSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantBillingSubscriptionUpdateInput, TenantBillingSubscriptionUncheckedUpdateInput>
  }

  /**
   * TenantBillingSubscription delete
   */
  export type TenantBillingSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which TenantBillingSubscription to delete.
     */
    where: TenantBillingSubscriptionWhereUniqueInput
  }

  /**
   * TenantBillingSubscription deleteMany
   */
  export type TenantBillingSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBillingSubscriptions to delete
     */
    where?: TenantBillingSubscriptionWhereInput
    /**
     * Limit how many TenantBillingSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * TenantBillingSubscription without action
   */
  export type TenantBillingSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSubscription
     */
    select?: TenantBillingSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSubscription
     */
    omit?: TenantBillingSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantBillingSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model TenantBillingSyncEvent
   */

  export type AggregateTenantBillingSyncEvent = {
    _count: TenantBillingSyncEventCountAggregateOutputType | null
    _min: TenantBillingSyncEventMinAggregateOutputType | null
    _max: TenantBillingSyncEventMaxAggregateOutputType | null
  }

  export type TenantBillingSyncEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    eventId: string | null
    eventType: string | null
    payloadJson: string | null
    resultStatus: string | null
    resultMessage: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type TenantBillingSyncEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    provider: string | null
    eventId: string | null
    eventType: string | null
    payloadJson: string | null
    resultStatus: string | null
    resultMessage: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type TenantBillingSyncEventCountAggregateOutputType = {
    id: number
    tenantId: number
    provider: number
    eventId: number
    eventType: number
    payloadJson: number
    resultStatus: number
    resultMessage: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type TenantBillingSyncEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    eventId?: true
    eventType?: true
    payloadJson?: true
    resultStatus?: true
    resultMessage?: true
    createdAt?: true
    processedAt?: true
  }

  export type TenantBillingSyncEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    eventId?: true
    eventType?: true
    payloadJson?: true
    resultStatus?: true
    resultMessage?: true
    createdAt?: true
    processedAt?: true
  }

  export type TenantBillingSyncEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    provider?: true
    eventId?: true
    eventType?: true
    payloadJson?: true
    resultStatus?: true
    resultMessage?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type TenantBillingSyncEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBillingSyncEvent to aggregate.
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSyncEvents to fetch.
     */
    orderBy?: TenantBillingSyncEventOrderByWithRelationInput | TenantBillingSyncEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantBillingSyncEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSyncEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSyncEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantBillingSyncEvents
    **/
    _count?: true | TenantBillingSyncEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantBillingSyncEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantBillingSyncEventMaxAggregateInputType
  }

  export type GetTenantBillingSyncEventAggregateType<T extends TenantBillingSyncEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantBillingSyncEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantBillingSyncEvent[P]>
      : GetScalarType<T[P], AggregateTenantBillingSyncEvent[P]>
  }




  export type TenantBillingSyncEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantBillingSyncEventWhereInput
    orderBy?: TenantBillingSyncEventOrderByWithAggregationInput | TenantBillingSyncEventOrderByWithAggregationInput[]
    by: TenantBillingSyncEventScalarFieldEnum[] | TenantBillingSyncEventScalarFieldEnum
    having?: TenantBillingSyncEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantBillingSyncEventCountAggregateInputType | true
    _min?: TenantBillingSyncEventMinAggregateInputType
    _max?: TenantBillingSyncEventMaxAggregateInputType
  }

  export type TenantBillingSyncEventGroupByOutputType = {
    id: string
    tenantId: string | null
    provider: string
    eventId: string
    eventType: string
    payloadJson: string
    resultStatus: string
    resultMessage: string | null
    createdAt: Date
    processedAt: Date
    _count: TenantBillingSyncEventCountAggregateOutputType | null
    _min: TenantBillingSyncEventMinAggregateOutputType | null
    _max: TenantBillingSyncEventMaxAggregateOutputType | null
  }

  type GetTenantBillingSyncEventGroupByPayload<T extends TenantBillingSyncEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantBillingSyncEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantBillingSyncEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantBillingSyncEventGroupByOutputType[P]>
            : GetScalarType<T[P], TenantBillingSyncEventGroupByOutputType[P]>
        }
      >
    >


  export type TenantBillingSyncEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    eventId?: boolean
    eventType?: boolean
    payloadJson?: boolean
    resultStatus?: boolean
    resultMessage?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["tenantBillingSyncEvent"]>

  export type TenantBillingSyncEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    eventId?: boolean
    eventType?: boolean
    payloadJson?: boolean
    resultStatus?: boolean
    resultMessage?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["tenantBillingSyncEvent"]>

  export type TenantBillingSyncEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    eventId?: boolean
    eventType?: boolean
    payloadJson?: boolean
    resultStatus?: boolean
    resultMessage?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }, ExtArgs["result"]["tenantBillingSyncEvent"]>

  export type TenantBillingSyncEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    provider?: boolean
    eventId?: boolean
    eventType?: boolean
    payloadJson?: boolean
    resultStatus?: boolean
    resultMessage?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type TenantBillingSyncEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "provider" | "eventId" | "eventType" | "payloadJson" | "resultStatus" | "resultMessage" | "createdAt" | "processedAt", ExtArgs["result"]["tenantBillingSyncEvent"]>

  export type $TenantBillingSyncEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantBillingSyncEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      provider: string
      eventId: string
      eventType: string
      payloadJson: string
      resultStatus: string
      resultMessage: string | null
      createdAt: Date
      processedAt: Date
    }, ExtArgs["result"]["tenantBillingSyncEvent"]>
    composites: {}
  }

  type TenantBillingSyncEventGetPayload<S extends boolean | null | undefined | TenantBillingSyncEventDefaultArgs> = $Result.GetResult<Prisma.$TenantBillingSyncEventPayload, S>

  type TenantBillingSyncEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantBillingSyncEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantBillingSyncEventCountAggregateInputType | true
    }

  export interface TenantBillingSyncEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantBillingSyncEvent'], meta: { name: 'TenantBillingSyncEvent' } }
    /**
     * Find zero or one TenantBillingSyncEvent that matches the filter.
     * @param {TenantBillingSyncEventFindUniqueArgs} args - Arguments to find a TenantBillingSyncEvent
     * @example
     * // Get one TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantBillingSyncEventFindUniqueArgs>(args: SelectSubset<T, TenantBillingSyncEventFindUniqueArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantBillingSyncEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantBillingSyncEventFindUniqueOrThrowArgs} args - Arguments to find a TenantBillingSyncEvent
     * @example
     * // Get one TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantBillingSyncEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantBillingSyncEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantBillingSyncEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventFindFirstArgs} args - Arguments to find a TenantBillingSyncEvent
     * @example
     * // Get one TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantBillingSyncEventFindFirstArgs>(args?: SelectSubset<T, TenantBillingSyncEventFindFirstArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantBillingSyncEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventFindFirstOrThrowArgs} args - Arguments to find a TenantBillingSyncEvent
     * @example
     * // Get one TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantBillingSyncEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantBillingSyncEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantBillingSyncEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantBillingSyncEvents
     * const tenantBillingSyncEvents = await prisma.tenantBillingSyncEvent.findMany()
     * 
     * // Get first 10 TenantBillingSyncEvents
     * const tenantBillingSyncEvents = await prisma.tenantBillingSyncEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantBillingSyncEventWithIdOnly = await prisma.tenantBillingSyncEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantBillingSyncEventFindManyArgs>(args?: SelectSubset<T, TenantBillingSyncEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantBillingSyncEvent.
     * @param {TenantBillingSyncEventCreateArgs} args - Arguments to create a TenantBillingSyncEvent.
     * @example
     * // Create one TenantBillingSyncEvent
     * const TenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.create({
     *   data: {
     *     // ... data to create a TenantBillingSyncEvent
     *   }
     * })
     * 
     */
    create<T extends TenantBillingSyncEventCreateArgs>(args: SelectSubset<T, TenantBillingSyncEventCreateArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantBillingSyncEvents.
     * @param {TenantBillingSyncEventCreateManyArgs} args - Arguments to create many TenantBillingSyncEvents.
     * @example
     * // Create many TenantBillingSyncEvents
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantBillingSyncEventCreateManyArgs>(args?: SelectSubset<T, TenantBillingSyncEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantBillingSyncEvents and returns the data saved in the database.
     * @param {TenantBillingSyncEventCreateManyAndReturnArgs} args - Arguments to create many TenantBillingSyncEvents.
     * @example
     * // Create many TenantBillingSyncEvents
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantBillingSyncEvents and only return the `id`
     * const tenantBillingSyncEventWithIdOnly = await prisma.tenantBillingSyncEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantBillingSyncEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantBillingSyncEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantBillingSyncEvent.
     * @param {TenantBillingSyncEventDeleteArgs} args - Arguments to delete one TenantBillingSyncEvent.
     * @example
     * // Delete one TenantBillingSyncEvent
     * const TenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.delete({
     *   where: {
     *     // ... filter to delete one TenantBillingSyncEvent
     *   }
     * })
     * 
     */
    delete<T extends TenantBillingSyncEventDeleteArgs>(args: SelectSubset<T, TenantBillingSyncEventDeleteArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantBillingSyncEvent.
     * @param {TenantBillingSyncEventUpdateArgs} args - Arguments to update one TenantBillingSyncEvent.
     * @example
     * // Update one TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantBillingSyncEventUpdateArgs>(args: SelectSubset<T, TenantBillingSyncEventUpdateArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantBillingSyncEvents.
     * @param {TenantBillingSyncEventDeleteManyArgs} args - Arguments to filter TenantBillingSyncEvents to delete.
     * @example
     * // Delete a few TenantBillingSyncEvents
     * const { count } = await prisma.tenantBillingSyncEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantBillingSyncEventDeleteManyArgs>(args?: SelectSubset<T, TenantBillingSyncEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantBillingSyncEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantBillingSyncEvents
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantBillingSyncEventUpdateManyArgs>(args: SelectSubset<T, TenantBillingSyncEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantBillingSyncEvents and returns the data updated in the database.
     * @param {TenantBillingSyncEventUpdateManyAndReturnArgs} args - Arguments to update many TenantBillingSyncEvents.
     * @example
     * // Update many TenantBillingSyncEvents
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantBillingSyncEvents and only return the `id`
     * const tenantBillingSyncEventWithIdOnly = await prisma.tenantBillingSyncEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantBillingSyncEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantBillingSyncEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantBillingSyncEvent.
     * @param {TenantBillingSyncEventUpsertArgs} args - Arguments to update or create a TenantBillingSyncEvent.
     * @example
     * // Update or create a TenantBillingSyncEvent
     * const tenantBillingSyncEvent = await prisma.tenantBillingSyncEvent.upsert({
     *   create: {
     *     // ... data to create a TenantBillingSyncEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantBillingSyncEvent we want to update
     *   }
     * })
     */
    upsert<T extends TenantBillingSyncEventUpsertArgs>(args: SelectSubset<T, TenantBillingSyncEventUpsertArgs<ExtArgs>>): Prisma__TenantBillingSyncEventClient<$Result.GetResult<Prisma.$TenantBillingSyncEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantBillingSyncEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventCountArgs} args - Arguments to filter TenantBillingSyncEvents to count.
     * @example
     * // Count the number of TenantBillingSyncEvents
     * const count = await prisma.tenantBillingSyncEvent.count({
     *   where: {
     *     // ... the filter for the TenantBillingSyncEvents we want to count
     *   }
     * })
    **/
    count<T extends TenantBillingSyncEventCountArgs>(
      args?: Subset<T, TenantBillingSyncEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantBillingSyncEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantBillingSyncEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantBillingSyncEventAggregateArgs>(args: Subset<T, TenantBillingSyncEventAggregateArgs>): Prisma.PrismaPromise<GetTenantBillingSyncEventAggregateType<T>>

    /**
     * Group by TenantBillingSyncEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantBillingSyncEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantBillingSyncEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantBillingSyncEventGroupByArgs['orderBy'] }
        : { orderBy?: TenantBillingSyncEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantBillingSyncEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantBillingSyncEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantBillingSyncEvent model
   */
  readonly fields: TenantBillingSyncEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantBillingSyncEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantBillingSyncEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantBillingSyncEvent model
   */
  interface TenantBillingSyncEventFieldRefs {
    readonly id: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly tenantId: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly provider: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly eventId: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly eventType: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly payloadJson: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly resultStatus: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly resultMessage: FieldRef<"TenantBillingSyncEvent", 'String'>
    readonly createdAt: FieldRef<"TenantBillingSyncEvent", 'DateTime'>
    readonly processedAt: FieldRef<"TenantBillingSyncEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantBillingSyncEvent findUnique
   */
  export type TenantBillingSyncEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter, which TenantBillingSyncEvent to fetch.
     */
    where: TenantBillingSyncEventWhereUniqueInput
  }

  /**
   * TenantBillingSyncEvent findUniqueOrThrow
   */
  export type TenantBillingSyncEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter, which TenantBillingSyncEvent to fetch.
     */
    where: TenantBillingSyncEventWhereUniqueInput
  }

  /**
   * TenantBillingSyncEvent findFirst
   */
  export type TenantBillingSyncEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter, which TenantBillingSyncEvent to fetch.
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSyncEvents to fetch.
     */
    orderBy?: TenantBillingSyncEventOrderByWithRelationInput | TenantBillingSyncEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBillingSyncEvents.
     */
    cursor?: TenantBillingSyncEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSyncEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSyncEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBillingSyncEvents.
     */
    distinct?: TenantBillingSyncEventScalarFieldEnum | TenantBillingSyncEventScalarFieldEnum[]
  }

  /**
   * TenantBillingSyncEvent findFirstOrThrow
   */
  export type TenantBillingSyncEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter, which TenantBillingSyncEvent to fetch.
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSyncEvents to fetch.
     */
    orderBy?: TenantBillingSyncEventOrderByWithRelationInput | TenantBillingSyncEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantBillingSyncEvents.
     */
    cursor?: TenantBillingSyncEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSyncEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSyncEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantBillingSyncEvents.
     */
    distinct?: TenantBillingSyncEventScalarFieldEnum | TenantBillingSyncEventScalarFieldEnum[]
  }

  /**
   * TenantBillingSyncEvent findMany
   */
  export type TenantBillingSyncEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter, which TenantBillingSyncEvents to fetch.
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantBillingSyncEvents to fetch.
     */
    orderBy?: TenantBillingSyncEventOrderByWithRelationInput | TenantBillingSyncEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantBillingSyncEvents.
     */
    cursor?: TenantBillingSyncEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantBillingSyncEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantBillingSyncEvents.
     */
    skip?: number
    distinct?: TenantBillingSyncEventScalarFieldEnum | TenantBillingSyncEventScalarFieldEnum[]
  }

  /**
   * TenantBillingSyncEvent create
   */
  export type TenantBillingSyncEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * The data needed to create a TenantBillingSyncEvent.
     */
    data: XOR<TenantBillingSyncEventCreateInput, TenantBillingSyncEventUncheckedCreateInput>
  }

  /**
   * TenantBillingSyncEvent createMany
   */
  export type TenantBillingSyncEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantBillingSyncEvents.
     */
    data: TenantBillingSyncEventCreateManyInput | TenantBillingSyncEventCreateManyInput[]
  }

  /**
   * TenantBillingSyncEvent createManyAndReturn
   */
  export type TenantBillingSyncEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * The data used to create many TenantBillingSyncEvents.
     */
    data: TenantBillingSyncEventCreateManyInput | TenantBillingSyncEventCreateManyInput[]
  }

  /**
   * TenantBillingSyncEvent update
   */
  export type TenantBillingSyncEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * The data needed to update a TenantBillingSyncEvent.
     */
    data: XOR<TenantBillingSyncEventUpdateInput, TenantBillingSyncEventUncheckedUpdateInput>
    /**
     * Choose, which TenantBillingSyncEvent to update.
     */
    where: TenantBillingSyncEventWhereUniqueInput
  }

  /**
   * TenantBillingSyncEvent updateMany
   */
  export type TenantBillingSyncEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantBillingSyncEvents.
     */
    data: XOR<TenantBillingSyncEventUpdateManyMutationInput, TenantBillingSyncEventUncheckedUpdateManyInput>
    /**
     * Filter which TenantBillingSyncEvents to update
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * Limit how many TenantBillingSyncEvents to update.
     */
    limit?: number
  }

  /**
   * TenantBillingSyncEvent updateManyAndReturn
   */
  export type TenantBillingSyncEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * The data used to update TenantBillingSyncEvents.
     */
    data: XOR<TenantBillingSyncEventUpdateManyMutationInput, TenantBillingSyncEventUncheckedUpdateManyInput>
    /**
     * Filter which TenantBillingSyncEvents to update
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * Limit how many TenantBillingSyncEvents to update.
     */
    limit?: number
  }

  /**
   * TenantBillingSyncEvent upsert
   */
  export type TenantBillingSyncEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * The filter to search for the TenantBillingSyncEvent to update in case it exists.
     */
    where: TenantBillingSyncEventWhereUniqueInput
    /**
     * In case the TenantBillingSyncEvent found by the `where` argument doesn't exist, create a new TenantBillingSyncEvent with this data.
     */
    create: XOR<TenantBillingSyncEventCreateInput, TenantBillingSyncEventUncheckedCreateInput>
    /**
     * In case the TenantBillingSyncEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantBillingSyncEventUpdateInput, TenantBillingSyncEventUncheckedUpdateInput>
  }

  /**
   * TenantBillingSyncEvent delete
   */
  export type TenantBillingSyncEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
    /**
     * Filter which TenantBillingSyncEvent to delete.
     */
    where: TenantBillingSyncEventWhereUniqueInput
  }

  /**
   * TenantBillingSyncEvent deleteMany
   */
  export type TenantBillingSyncEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantBillingSyncEvents to delete
     */
    where?: TenantBillingSyncEventWhereInput
    /**
     * Limit how many TenantBillingSyncEvents to delete.
     */
    limit?: number
  }

  /**
   * TenantBillingSyncEvent without action
   */
  export type TenantBillingSyncEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantBillingSyncEvent
     */
    select?: TenantBillingSyncEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantBillingSyncEvent
     */
    omit?: TenantBillingSyncEventOmit<ExtArgs> | null
  }


  /**
   * Model TenantControlActor
   */

  export type AggregateTenantControlActor = {
    _count: TenantControlActorCountAggregateOutputType | null
    _min: TenantControlActorMinAggregateOutputType | null
    _max: TenantControlActorMaxAggregateOutputType | null
  }

  export type TenantControlActorMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    actorId: string | null
    displayName: string | null
    email: string | null
    role: string | null
    permissionsJson: string | null
    supportSessionActive: boolean | null
    supportSessionStartedAt: Date | null
    supportSessionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantControlActorMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    actorId: string | null
    displayName: string | null
    email: string | null
    role: string | null
    permissionsJson: string | null
    supportSessionActive: boolean | null
    supportSessionStartedAt: Date | null
    supportSessionExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantControlActorCountAggregateOutputType = {
    id: number
    tenantId: number
    actorId: number
    displayName: number
    email: number
    role: number
    permissionsJson: number
    supportSessionActive: number
    supportSessionStartedAt: number
    supportSessionExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantControlActorMinAggregateInputType = {
    id?: true
    tenantId?: true
    actorId?: true
    displayName?: true
    email?: true
    role?: true
    permissionsJson?: true
    supportSessionActive?: true
    supportSessionStartedAt?: true
    supportSessionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantControlActorMaxAggregateInputType = {
    id?: true
    tenantId?: true
    actorId?: true
    displayName?: true
    email?: true
    role?: true
    permissionsJson?: true
    supportSessionActive?: true
    supportSessionStartedAt?: true
    supportSessionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantControlActorCountAggregateInputType = {
    id?: true
    tenantId?: true
    actorId?: true
    displayName?: true
    email?: true
    role?: true
    permissionsJson?: true
    supportSessionActive?: true
    supportSessionStartedAt?: true
    supportSessionExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantControlActorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantControlActor to aggregate.
     */
    where?: TenantControlActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlActors to fetch.
     */
    orderBy?: TenantControlActorOrderByWithRelationInput | TenantControlActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantControlActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantControlActors
    **/
    _count?: true | TenantControlActorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantControlActorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantControlActorMaxAggregateInputType
  }

  export type GetTenantControlActorAggregateType<T extends TenantControlActorAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantControlActor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantControlActor[P]>
      : GetScalarType<T[P], AggregateTenantControlActor[P]>
  }




  export type TenantControlActorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantControlActorWhereInput
    orderBy?: TenantControlActorOrderByWithAggregationInput | TenantControlActorOrderByWithAggregationInput[]
    by: TenantControlActorScalarFieldEnum[] | TenantControlActorScalarFieldEnum
    having?: TenantControlActorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantControlActorCountAggregateInputType | true
    _min?: TenantControlActorMinAggregateInputType
    _max?: TenantControlActorMaxAggregateInputType
  }

  export type TenantControlActorGroupByOutputType = {
    id: string
    tenantId: string
    actorId: string
    displayName: string | null
    email: string | null
    role: string
    permissionsJson: string
    supportSessionActive: boolean
    supportSessionStartedAt: Date | null
    supportSessionExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TenantControlActorCountAggregateOutputType | null
    _min: TenantControlActorMinAggregateOutputType | null
    _max: TenantControlActorMaxAggregateOutputType | null
  }

  type GetTenantControlActorGroupByPayload<T extends TenantControlActorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantControlActorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantControlActorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantControlActorGroupByOutputType[P]>
            : GetScalarType<T[P], TenantControlActorGroupByOutputType[P]>
        }
      >
    >


  export type TenantControlActorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorId?: boolean
    displayName?: boolean
    email?: boolean
    role?: boolean
    permissionsJson?: boolean
    supportSessionActive?: boolean
    supportSessionStartedAt?: boolean
    supportSessionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlActor"]>

  export type TenantControlActorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorId?: boolean
    displayName?: boolean
    email?: boolean
    role?: boolean
    permissionsJson?: boolean
    supportSessionActive?: boolean
    supportSessionStartedAt?: boolean
    supportSessionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlActor"]>

  export type TenantControlActorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    actorId?: boolean
    displayName?: boolean
    email?: boolean
    role?: boolean
    permissionsJson?: boolean
    supportSessionActive?: boolean
    supportSessionStartedAt?: boolean
    supportSessionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantControlActor"]>

  export type TenantControlActorSelectScalar = {
    id?: boolean
    tenantId?: boolean
    actorId?: boolean
    displayName?: boolean
    email?: boolean
    role?: boolean
    permissionsJson?: boolean
    supportSessionActive?: boolean
    supportSessionStartedAt?: boolean
    supportSessionExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantControlActorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "actorId" | "displayName" | "email" | "role" | "permissionsJson" | "supportSessionActive" | "supportSessionStartedAt" | "supportSessionExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantControlActor"]>
  export type TenantControlActorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantControlActorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantControlActorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantControlActorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantControlActor"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      actorId: string
      displayName: string | null
      email: string | null
      role: string
      permissionsJson: string
      supportSessionActive: boolean
      supportSessionStartedAt: Date | null
      supportSessionExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantControlActor"]>
    composites: {}
  }

  type TenantControlActorGetPayload<S extends boolean | null | undefined | TenantControlActorDefaultArgs> = $Result.GetResult<Prisma.$TenantControlActorPayload, S>

  type TenantControlActorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantControlActorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantControlActorCountAggregateInputType | true
    }

  export interface TenantControlActorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantControlActor'], meta: { name: 'TenantControlActor' } }
    /**
     * Find zero or one TenantControlActor that matches the filter.
     * @param {TenantControlActorFindUniqueArgs} args - Arguments to find a TenantControlActor
     * @example
     * // Get one TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantControlActorFindUniqueArgs>(args: SelectSubset<T, TenantControlActorFindUniqueArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantControlActor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantControlActorFindUniqueOrThrowArgs} args - Arguments to find a TenantControlActor
     * @example
     * // Get one TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantControlActorFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantControlActorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantControlActor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorFindFirstArgs} args - Arguments to find a TenantControlActor
     * @example
     * // Get one TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantControlActorFindFirstArgs>(args?: SelectSubset<T, TenantControlActorFindFirstArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantControlActor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorFindFirstOrThrowArgs} args - Arguments to find a TenantControlActor
     * @example
     * // Get one TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantControlActorFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantControlActorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantControlActors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantControlActors
     * const tenantControlActors = await prisma.tenantControlActor.findMany()
     * 
     * // Get first 10 TenantControlActors
     * const tenantControlActors = await prisma.tenantControlActor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantControlActorWithIdOnly = await prisma.tenantControlActor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantControlActorFindManyArgs>(args?: SelectSubset<T, TenantControlActorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantControlActor.
     * @param {TenantControlActorCreateArgs} args - Arguments to create a TenantControlActor.
     * @example
     * // Create one TenantControlActor
     * const TenantControlActor = await prisma.tenantControlActor.create({
     *   data: {
     *     // ... data to create a TenantControlActor
     *   }
     * })
     * 
     */
    create<T extends TenantControlActorCreateArgs>(args: SelectSubset<T, TenantControlActorCreateArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantControlActors.
     * @param {TenantControlActorCreateManyArgs} args - Arguments to create many TenantControlActors.
     * @example
     * // Create many TenantControlActors
     * const tenantControlActor = await prisma.tenantControlActor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantControlActorCreateManyArgs>(args?: SelectSubset<T, TenantControlActorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantControlActors and returns the data saved in the database.
     * @param {TenantControlActorCreateManyAndReturnArgs} args - Arguments to create many TenantControlActors.
     * @example
     * // Create many TenantControlActors
     * const tenantControlActor = await prisma.tenantControlActor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantControlActors and only return the `id`
     * const tenantControlActorWithIdOnly = await prisma.tenantControlActor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantControlActorCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantControlActorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantControlActor.
     * @param {TenantControlActorDeleteArgs} args - Arguments to delete one TenantControlActor.
     * @example
     * // Delete one TenantControlActor
     * const TenantControlActor = await prisma.tenantControlActor.delete({
     *   where: {
     *     // ... filter to delete one TenantControlActor
     *   }
     * })
     * 
     */
    delete<T extends TenantControlActorDeleteArgs>(args: SelectSubset<T, TenantControlActorDeleteArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantControlActor.
     * @param {TenantControlActorUpdateArgs} args - Arguments to update one TenantControlActor.
     * @example
     * // Update one TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantControlActorUpdateArgs>(args: SelectSubset<T, TenantControlActorUpdateArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantControlActors.
     * @param {TenantControlActorDeleteManyArgs} args - Arguments to filter TenantControlActors to delete.
     * @example
     * // Delete a few TenantControlActors
     * const { count } = await prisma.tenantControlActor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantControlActorDeleteManyArgs>(args?: SelectSubset<T, TenantControlActorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantControlActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantControlActors
     * const tenantControlActor = await prisma.tenantControlActor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantControlActorUpdateManyArgs>(args: SelectSubset<T, TenantControlActorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantControlActors and returns the data updated in the database.
     * @param {TenantControlActorUpdateManyAndReturnArgs} args - Arguments to update many TenantControlActors.
     * @example
     * // Update many TenantControlActors
     * const tenantControlActor = await prisma.tenantControlActor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantControlActors and only return the `id`
     * const tenantControlActorWithIdOnly = await prisma.tenantControlActor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantControlActorUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantControlActorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantControlActor.
     * @param {TenantControlActorUpsertArgs} args - Arguments to update or create a TenantControlActor.
     * @example
     * // Update or create a TenantControlActor
     * const tenantControlActor = await prisma.tenantControlActor.upsert({
     *   create: {
     *     // ... data to create a TenantControlActor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantControlActor we want to update
     *   }
     * })
     */
    upsert<T extends TenantControlActorUpsertArgs>(args: SelectSubset<T, TenantControlActorUpsertArgs<ExtArgs>>): Prisma__TenantControlActorClient<$Result.GetResult<Prisma.$TenantControlActorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantControlActors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorCountArgs} args - Arguments to filter TenantControlActors to count.
     * @example
     * // Count the number of TenantControlActors
     * const count = await prisma.tenantControlActor.count({
     *   where: {
     *     // ... the filter for the TenantControlActors we want to count
     *   }
     * })
    **/
    count<T extends TenantControlActorCountArgs>(
      args?: Subset<T, TenantControlActorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantControlActorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantControlActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantControlActorAggregateArgs>(args: Subset<T, TenantControlActorAggregateArgs>): Prisma.PrismaPromise<GetTenantControlActorAggregateType<T>>

    /**
     * Group by TenantControlActor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantControlActorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantControlActorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantControlActorGroupByArgs['orderBy'] }
        : { orderBy?: TenantControlActorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantControlActorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantControlActorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantControlActor model
   */
  readonly fields: TenantControlActorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantControlActor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantControlActorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantControlActor model
   */
  interface TenantControlActorFieldRefs {
    readonly id: FieldRef<"TenantControlActor", 'String'>
    readonly tenantId: FieldRef<"TenantControlActor", 'String'>
    readonly actorId: FieldRef<"TenantControlActor", 'String'>
    readonly displayName: FieldRef<"TenantControlActor", 'String'>
    readonly email: FieldRef<"TenantControlActor", 'String'>
    readonly role: FieldRef<"TenantControlActor", 'String'>
    readonly permissionsJson: FieldRef<"TenantControlActor", 'String'>
    readonly supportSessionActive: FieldRef<"TenantControlActor", 'Boolean'>
    readonly supportSessionStartedAt: FieldRef<"TenantControlActor", 'DateTime'>
    readonly supportSessionExpiresAt: FieldRef<"TenantControlActor", 'DateTime'>
    readonly createdAt: FieldRef<"TenantControlActor", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantControlActor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantControlActor findUnique
   */
  export type TenantControlActorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlActor to fetch.
     */
    where: TenantControlActorWhereUniqueInput
  }

  /**
   * TenantControlActor findUniqueOrThrow
   */
  export type TenantControlActorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlActor to fetch.
     */
    where: TenantControlActorWhereUniqueInput
  }

  /**
   * TenantControlActor findFirst
   */
  export type TenantControlActorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlActor to fetch.
     */
    where?: TenantControlActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlActors to fetch.
     */
    orderBy?: TenantControlActorOrderByWithRelationInput | TenantControlActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantControlActors.
     */
    cursor?: TenantControlActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantControlActors.
     */
    distinct?: TenantControlActorScalarFieldEnum | TenantControlActorScalarFieldEnum[]
  }

  /**
   * TenantControlActor findFirstOrThrow
   */
  export type TenantControlActorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlActor to fetch.
     */
    where?: TenantControlActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlActors to fetch.
     */
    orderBy?: TenantControlActorOrderByWithRelationInput | TenantControlActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantControlActors.
     */
    cursor?: TenantControlActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlActors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantControlActors.
     */
    distinct?: TenantControlActorScalarFieldEnum | TenantControlActorScalarFieldEnum[]
  }

  /**
   * TenantControlActor findMany
   */
  export type TenantControlActorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter, which TenantControlActors to fetch.
     */
    where?: TenantControlActorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantControlActors to fetch.
     */
    orderBy?: TenantControlActorOrderByWithRelationInput | TenantControlActorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantControlActors.
     */
    cursor?: TenantControlActorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantControlActors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantControlActors.
     */
    skip?: number
    distinct?: TenantControlActorScalarFieldEnum | TenantControlActorScalarFieldEnum[]
  }

  /**
   * TenantControlActor create
   */
  export type TenantControlActorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantControlActor.
     */
    data: XOR<TenantControlActorCreateInput, TenantControlActorUncheckedCreateInput>
  }

  /**
   * TenantControlActor createMany
   */
  export type TenantControlActorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantControlActors.
     */
    data: TenantControlActorCreateManyInput | TenantControlActorCreateManyInput[]
  }

  /**
   * TenantControlActor createManyAndReturn
   */
  export type TenantControlActorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * The data used to create many TenantControlActors.
     */
    data: TenantControlActorCreateManyInput | TenantControlActorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantControlActor update
   */
  export type TenantControlActorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantControlActor.
     */
    data: XOR<TenantControlActorUpdateInput, TenantControlActorUncheckedUpdateInput>
    /**
     * Choose, which TenantControlActor to update.
     */
    where: TenantControlActorWhereUniqueInput
  }

  /**
   * TenantControlActor updateMany
   */
  export type TenantControlActorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantControlActors.
     */
    data: XOR<TenantControlActorUpdateManyMutationInput, TenantControlActorUncheckedUpdateManyInput>
    /**
     * Filter which TenantControlActors to update
     */
    where?: TenantControlActorWhereInput
    /**
     * Limit how many TenantControlActors to update.
     */
    limit?: number
  }

  /**
   * TenantControlActor updateManyAndReturn
   */
  export type TenantControlActorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * The data used to update TenantControlActors.
     */
    data: XOR<TenantControlActorUpdateManyMutationInput, TenantControlActorUncheckedUpdateManyInput>
    /**
     * Filter which TenantControlActors to update
     */
    where?: TenantControlActorWhereInput
    /**
     * Limit how many TenantControlActors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantControlActor upsert
   */
  export type TenantControlActorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantControlActor to update in case it exists.
     */
    where: TenantControlActorWhereUniqueInput
    /**
     * In case the TenantControlActor found by the `where` argument doesn't exist, create a new TenantControlActor with this data.
     */
    create: XOR<TenantControlActorCreateInput, TenantControlActorUncheckedCreateInput>
    /**
     * In case the TenantControlActor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantControlActorUpdateInput, TenantControlActorUncheckedUpdateInput>
  }

  /**
   * TenantControlActor delete
   */
  export type TenantControlActorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
    /**
     * Filter which TenantControlActor to delete.
     */
    where: TenantControlActorWhereUniqueInput
  }

  /**
   * TenantControlActor deleteMany
   */
  export type TenantControlActorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantControlActors to delete
     */
    where?: TenantControlActorWhereInput
    /**
     * Limit how many TenantControlActors to delete.
     */
    limit?: number
  }

  /**
   * TenantControlActor without action
   */
  export type TenantControlActorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantControlActor
     */
    select?: TenantControlActorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantControlActor
     */
    omit?: TenantControlActorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantControlActorInclude<ExtArgs> | null
  }


  /**
   * Model TenantOnboardingPlan
   */

  export type AggregateTenantOnboardingPlan = {
    _count: TenantOnboardingPlanCountAggregateOutputType | null
    _min: TenantOnboardingPlanMinAggregateOutputType | null
    _max: TenantOnboardingPlanMaxAggregateOutputType | null
  }

  export type TenantOnboardingPlanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    planCode: string | null
    startedAt: Date | null
    targetLaunchDate: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    pauseReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantOnboardingPlanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    status: string | null
    planCode: string | null
    startedAt: Date | null
    targetLaunchDate: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    pauseReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantOnboardingPlanCountAggregateOutputType = {
    id: number
    tenantId: number
    status: number
    planCode: number
    startedAt: number
    targetLaunchDate: number
    completedAt: number
    pausedAt: number
    pauseReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantOnboardingPlanMinAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    startedAt?: true
    targetLaunchDate?: true
    completedAt?: true
    pausedAt?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantOnboardingPlanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    startedAt?: true
    targetLaunchDate?: true
    completedAt?: true
    pausedAt?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantOnboardingPlanCountAggregateInputType = {
    id?: true
    tenantId?: true
    status?: true
    planCode?: true
    startedAt?: true
    targetLaunchDate?: true
    completedAt?: true
    pausedAt?: true
    pauseReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantOnboardingPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantOnboardingPlan to aggregate.
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingPlans to fetch.
     */
    orderBy?: TenantOnboardingPlanOrderByWithRelationInput | TenantOnboardingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantOnboardingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantOnboardingPlans
    **/
    _count?: true | TenantOnboardingPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantOnboardingPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantOnboardingPlanMaxAggregateInputType
  }

  export type GetTenantOnboardingPlanAggregateType<T extends TenantOnboardingPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantOnboardingPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantOnboardingPlan[P]>
      : GetScalarType<T[P], AggregateTenantOnboardingPlan[P]>
  }




  export type TenantOnboardingPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantOnboardingPlanWhereInput
    orderBy?: TenantOnboardingPlanOrderByWithAggregationInput | TenantOnboardingPlanOrderByWithAggregationInput[]
    by: TenantOnboardingPlanScalarFieldEnum[] | TenantOnboardingPlanScalarFieldEnum
    having?: TenantOnboardingPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantOnboardingPlanCountAggregateInputType | true
    _min?: TenantOnboardingPlanMinAggregateInputType
    _max?: TenantOnboardingPlanMaxAggregateInputType
  }

  export type TenantOnboardingPlanGroupByOutputType = {
    id: string
    tenantId: string
    status: string
    planCode: string
    startedAt: Date | null
    targetLaunchDate: Date | null
    completedAt: Date | null
    pausedAt: Date | null
    pauseReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantOnboardingPlanCountAggregateOutputType | null
    _min: TenantOnboardingPlanMinAggregateOutputType | null
    _max: TenantOnboardingPlanMaxAggregateOutputType | null
  }

  type GetTenantOnboardingPlanGroupByPayload<T extends TenantOnboardingPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantOnboardingPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantOnboardingPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantOnboardingPlanGroupByOutputType[P]>
            : GetScalarType<T[P], TenantOnboardingPlanGroupByOutputType[P]>
        }
      >
    >


  export type TenantOnboardingPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    startedAt?: boolean
    targetLaunchDate?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tasks?: boolean | TenantOnboardingPlan$tasksArgs<ExtArgs>
    _count?: boolean | TenantOnboardingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingPlan"]>

  export type TenantOnboardingPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    startedAt?: boolean
    targetLaunchDate?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingPlan"]>

  export type TenantOnboardingPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    startedAt?: boolean
    targetLaunchDate?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingPlan"]>

  export type TenantOnboardingPlanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    status?: boolean
    planCode?: boolean
    startedAt?: boolean
    targetLaunchDate?: boolean
    completedAt?: boolean
    pausedAt?: boolean
    pauseReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOnboardingPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "status" | "planCode" | "startedAt" | "targetLaunchDate" | "completedAt" | "pausedAt" | "pauseReason" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantOnboardingPlan"]>
  export type TenantOnboardingPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    tasks?: boolean | TenantOnboardingPlan$tasksArgs<ExtArgs>
    _count?: boolean | TenantOnboardingPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantOnboardingPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantOnboardingPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantOnboardingPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantOnboardingPlan"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      tasks: Prisma.$TenantOnboardingTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      status: string
      planCode: string
      startedAt: Date | null
      targetLaunchDate: Date | null
      completedAt: Date | null
      pausedAt: Date | null
      pauseReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantOnboardingPlan"]>
    composites: {}
  }

  type TenantOnboardingPlanGetPayload<S extends boolean | null | undefined | TenantOnboardingPlanDefaultArgs> = $Result.GetResult<Prisma.$TenantOnboardingPlanPayload, S>

  type TenantOnboardingPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantOnboardingPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantOnboardingPlanCountAggregateInputType | true
    }

  export interface TenantOnboardingPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantOnboardingPlan'], meta: { name: 'TenantOnboardingPlan' } }
    /**
     * Find zero or one TenantOnboardingPlan that matches the filter.
     * @param {TenantOnboardingPlanFindUniqueArgs} args - Arguments to find a TenantOnboardingPlan
     * @example
     * // Get one TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantOnboardingPlanFindUniqueArgs>(args: SelectSubset<T, TenantOnboardingPlanFindUniqueArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantOnboardingPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantOnboardingPlanFindUniqueOrThrowArgs} args - Arguments to find a TenantOnboardingPlan
     * @example
     * // Get one TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantOnboardingPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantOnboardingPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOnboardingPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanFindFirstArgs} args - Arguments to find a TenantOnboardingPlan
     * @example
     * // Get one TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantOnboardingPlanFindFirstArgs>(args?: SelectSubset<T, TenantOnboardingPlanFindFirstArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOnboardingPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanFindFirstOrThrowArgs} args - Arguments to find a TenantOnboardingPlan
     * @example
     * // Get one TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantOnboardingPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantOnboardingPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantOnboardingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantOnboardingPlans
     * const tenantOnboardingPlans = await prisma.tenantOnboardingPlan.findMany()
     * 
     * // Get first 10 TenantOnboardingPlans
     * const tenantOnboardingPlans = await prisma.tenantOnboardingPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantOnboardingPlanWithIdOnly = await prisma.tenantOnboardingPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantOnboardingPlanFindManyArgs>(args?: SelectSubset<T, TenantOnboardingPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantOnboardingPlan.
     * @param {TenantOnboardingPlanCreateArgs} args - Arguments to create a TenantOnboardingPlan.
     * @example
     * // Create one TenantOnboardingPlan
     * const TenantOnboardingPlan = await prisma.tenantOnboardingPlan.create({
     *   data: {
     *     // ... data to create a TenantOnboardingPlan
     *   }
     * })
     * 
     */
    create<T extends TenantOnboardingPlanCreateArgs>(args: SelectSubset<T, TenantOnboardingPlanCreateArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantOnboardingPlans.
     * @param {TenantOnboardingPlanCreateManyArgs} args - Arguments to create many TenantOnboardingPlans.
     * @example
     * // Create many TenantOnboardingPlans
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantOnboardingPlanCreateManyArgs>(args?: SelectSubset<T, TenantOnboardingPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantOnboardingPlans and returns the data saved in the database.
     * @param {TenantOnboardingPlanCreateManyAndReturnArgs} args - Arguments to create many TenantOnboardingPlans.
     * @example
     * // Create many TenantOnboardingPlans
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantOnboardingPlans and only return the `id`
     * const tenantOnboardingPlanWithIdOnly = await prisma.tenantOnboardingPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantOnboardingPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantOnboardingPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantOnboardingPlan.
     * @param {TenantOnboardingPlanDeleteArgs} args - Arguments to delete one TenantOnboardingPlan.
     * @example
     * // Delete one TenantOnboardingPlan
     * const TenantOnboardingPlan = await prisma.tenantOnboardingPlan.delete({
     *   where: {
     *     // ... filter to delete one TenantOnboardingPlan
     *   }
     * })
     * 
     */
    delete<T extends TenantOnboardingPlanDeleteArgs>(args: SelectSubset<T, TenantOnboardingPlanDeleteArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantOnboardingPlan.
     * @param {TenantOnboardingPlanUpdateArgs} args - Arguments to update one TenantOnboardingPlan.
     * @example
     * // Update one TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantOnboardingPlanUpdateArgs>(args: SelectSubset<T, TenantOnboardingPlanUpdateArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantOnboardingPlans.
     * @param {TenantOnboardingPlanDeleteManyArgs} args - Arguments to filter TenantOnboardingPlans to delete.
     * @example
     * // Delete a few TenantOnboardingPlans
     * const { count } = await prisma.tenantOnboardingPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantOnboardingPlanDeleteManyArgs>(args?: SelectSubset<T, TenantOnboardingPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOnboardingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantOnboardingPlans
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantOnboardingPlanUpdateManyArgs>(args: SelectSubset<T, TenantOnboardingPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOnboardingPlans and returns the data updated in the database.
     * @param {TenantOnboardingPlanUpdateManyAndReturnArgs} args - Arguments to update many TenantOnboardingPlans.
     * @example
     * // Update many TenantOnboardingPlans
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantOnboardingPlans and only return the `id`
     * const tenantOnboardingPlanWithIdOnly = await prisma.tenantOnboardingPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantOnboardingPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantOnboardingPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantOnboardingPlan.
     * @param {TenantOnboardingPlanUpsertArgs} args - Arguments to update or create a TenantOnboardingPlan.
     * @example
     * // Update or create a TenantOnboardingPlan
     * const tenantOnboardingPlan = await prisma.tenantOnboardingPlan.upsert({
     *   create: {
     *     // ... data to create a TenantOnboardingPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantOnboardingPlan we want to update
     *   }
     * })
     */
    upsert<T extends TenantOnboardingPlanUpsertArgs>(args: SelectSubset<T, TenantOnboardingPlanUpsertArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantOnboardingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanCountArgs} args - Arguments to filter TenantOnboardingPlans to count.
     * @example
     * // Count the number of TenantOnboardingPlans
     * const count = await prisma.tenantOnboardingPlan.count({
     *   where: {
     *     // ... the filter for the TenantOnboardingPlans we want to count
     *   }
     * })
    **/
    count<T extends TenantOnboardingPlanCountArgs>(
      args?: Subset<T, TenantOnboardingPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantOnboardingPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantOnboardingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantOnboardingPlanAggregateArgs>(args: Subset<T, TenantOnboardingPlanAggregateArgs>): Prisma.PrismaPromise<GetTenantOnboardingPlanAggregateType<T>>

    /**
     * Group by TenantOnboardingPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantOnboardingPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantOnboardingPlanGroupByArgs['orderBy'] }
        : { orderBy?: TenantOnboardingPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantOnboardingPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantOnboardingPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantOnboardingPlan model
   */
  readonly fields: TenantOnboardingPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantOnboardingPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantOnboardingPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends TenantOnboardingPlan$tasksArgs<ExtArgs> = {}>(args?: Subset<T, TenantOnboardingPlan$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantOnboardingPlan model
   */
  interface TenantOnboardingPlanFieldRefs {
    readonly id: FieldRef<"TenantOnboardingPlan", 'String'>
    readonly tenantId: FieldRef<"TenantOnboardingPlan", 'String'>
    readonly status: FieldRef<"TenantOnboardingPlan", 'String'>
    readonly planCode: FieldRef<"TenantOnboardingPlan", 'String'>
    readonly startedAt: FieldRef<"TenantOnboardingPlan", 'DateTime'>
    readonly targetLaunchDate: FieldRef<"TenantOnboardingPlan", 'DateTime'>
    readonly completedAt: FieldRef<"TenantOnboardingPlan", 'DateTime'>
    readonly pausedAt: FieldRef<"TenantOnboardingPlan", 'DateTime'>
    readonly pauseReason: FieldRef<"TenantOnboardingPlan", 'String'>
    readonly createdAt: FieldRef<"TenantOnboardingPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantOnboardingPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantOnboardingPlan findUnique
   */
  export type TenantOnboardingPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingPlan to fetch.
     */
    where: TenantOnboardingPlanWhereUniqueInput
  }

  /**
   * TenantOnboardingPlan findUniqueOrThrow
   */
  export type TenantOnboardingPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingPlan to fetch.
     */
    where: TenantOnboardingPlanWhereUniqueInput
  }

  /**
   * TenantOnboardingPlan findFirst
   */
  export type TenantOnboardingPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingPlan to fetch.
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingPlans to fetch.
     */
    orderBy?: TenantOnboardingPlanOrderByWithRelationInput | TenantOnboardingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantOnboardingPlans.
     */
    cursor?: TenantOnboardingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantOnboardingPlans.
     */
    distinct?: TenantOnboardingPlanScalarFieldEnum | TenantOnboardingPlanScalarFieldEnum[]
  }

  /**
   * TenantOnboardingPlan findFirstOrThrow
   */
  export type TenantOnboardingPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingPlan to fetch.
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingPlans to fetch.
     */
    orderBy?: TenantOnboardingPlanOrderByWithRelationInput | TenantOnboardingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantOnboardingPlans.
     */
    cursor?: TenantOnboardingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantOnboardingPlans.
     */
    distinct?: TenantOnboardingPlanScalarFieldEnum | TenantOnboardingPlanScalarFieldEnum[]
  }

  /**
   * TenantOnboardingPlan findMany
   */
  export type TenantOnboardingPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingPlans to fetch.
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingPlans to fetch.
     */
    orderBy?: TenantOnboardingPlanOrderByWithRelationInput | TenantOnboardingPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantOnboardingPlans.
     */
    cursor?: TenantOnboardingPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingPlans.
     */
    skip?: number
    distinct?: TenantOnboardingPlanScalarFieldEnum | TenantOnboardingPlanScalarFieldEnum[]
  }

  /**
   * TenantOnboardingPlan create
   */
  export type TenantOnboardingPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantOnboardingPlan.
     */
    data: XOR<TenantOnboardingPlanCreateInput, TenantOnboardingPlanUncheckedCreateInput>
  }

  /**
   * TenantOnboardingPlan createMany
   */
  export type TenantOnboardingPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantOnboardingPlans.
     */
    data: TenantOnboardingPlanCreateManyInput | TenantOnboardingPlanCreateManyInput[]
  }

  /**
   * TenantOnboardingPlan createManyAndReturn
   */
  export type TenantOnboardingPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * The data used to create many TenantOnboardingPlans.
     */
    data: TenantOnboardingPlanCreateManyInput | TenantOnboardingPlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantOnboardingPlan update
   */
  export type TenantOnboardingPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantOnboardingPlan.
     */
    data: XOR<TenantOnboardingPlanUpdateInput, TenantOnboardingPlanUncheckedUpdateInput>
    /**
     * Choose, which TenantOnboardingPlan to update.
     */
    where: TenantOnboardingPlanWhereUniqueInput
  }

  /**
   * TenantOnboardingPlan updateMany
   */
  export type TenantOnboardingPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantOnboardingPlans.
     */
    data: XOR<TenantOnboardingPlanUpdateManyMutationInput, TenantOnboardingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TenantOnboardingPlans to update
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * Limit how many TenantOnboardingPlans to update.
     */
    limit?: number
  }

  /**
   * TenantOnboardingPlan updateManyAndReturn
   */
  export type TenantOnboardingPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * The data used to update TenantOnboardingPlans.
     */
    data: XOR<TenantOnboardingPlanUpdateManyMutationInput, TenantOnboardingPlanUncheckedUpdateManyInput>
    /**
     * Filter which TenantOnboardingPlans to update
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * Limit how many TenantOnboardingPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantOnboardingPlan upsert
   */
  export type TenantOnboardingPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantOnboardingPlan to update in case it exists.
     */
    where: TenantOnboardingPlanWhereUniqueInput
    /**
     * In case the TenantOnboardingPlan found by the `where` argument doesn't exist, create a new TenantOnboardingPlan with this data.
     */
    create: XOR<TenantOnboardingPlanCreateInput, TenantOnboardingPlanUncheckedCreateInput>
    /**
     * In case the TenantOnboardingPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantOnboardingPlanUpdateInput, TenantOnboardingPlanUncheckedUpdateInput>
  }

  /**
   * TenantOnboardingPlan delete
   */
  export type TenantOnboardingPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
    /**
     * Filter which TenantOnboardingPlan to delete.
     */
    where: TenantOnboardingPlanWhereUniqueInput
  }

  /**
   * TenantOnboardingPlan deleteMany
   */
  export type TenantOnboardingPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantOnboardingPlans to delete
     */
    where?: TenantOnboardingPlanWhereInput
    /**
     * Limit how many TenantOnboardingPlans to delete.
     */
    limit?: number
  }

  /**
   * TenantOnboardingPlan.tasks
   */
  export type TenantOnboardingPlan$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    where?: TenantOnboardingTaskWhereInput
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    cursor?: TenantOnboardingTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantOnboardingTaskScalarFieldEnum | TenantOnboardingTaskScalarFieldEnum[]
  }

  /**
   * TenantOnboardingPlan without action
   */
  export type TenantOnboardingPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingPlan
     */
    select?: TenantOnboardingPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingPlan
     */
    omit?: TenantOnboardingPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingPlanInclude<ExtArgs> | null
  }


  /**
   * Model TenantOnboardingTask
   */

  export type AggregateTenantOnboardingTask = {
    _count: TenantOnboardingTaskCountAggregateOutputType | null
    _avg: TenantOnboardingTaskAvgAggregateOutputType | null
    _sum: TenantOnboardingTaskSumAggregateOutputType | null
    _min: TenantOnboardingTaskMinAggregateOutputType | null
    _max: TenantOnboardingTaskMaxAggregateOutputType | null
  }

  export type TenantOnboardingTaskAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type TenantOnboardingTaskSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type TenantOnboardingTaskMinAggregateOutputType = {
    id: string | null
    tenantOnboardingPlanId: string | null
    tenantId: string | null
    taskKey: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    required: boolean | null
    ownerRole: string | null
    ownerActorId: string | null
    dueAt: Date | null
    blockedByClient: boolean | null
    blockerReason: string | null
    sortOrder: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantOnboardingTaskMaxAggregateOutputType = {
    id: string | null
    tenantOnboardingPlanId: string | null
    tenantId: string | null
    taskKey: string | null
    title: string | null
    description: string | null
    status: string | null
    priority: string | null
    required: boolean | null
    ownerRole: string | null
    ownerActorId: string | null
    dueAt: Date | null
    blockedByClient: boolean | null
    blockerReason: string | null
    sortOrder: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantOnboardingTaskCountAggregateOutputType = {
    id: number
    tenantOnboardingPlanId: number
    tenantId: number
    taskKey: number
    title: number
    description: number
    status: number
    priority: number
    required: number
    ownerRole: number
    ownerActorId: number
    dueAt: number
    blockedByClient: number
    blockerReason: number
    sortOrder: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantOnboardingTaskAvgAggregateInputType = {
    sortOrder?: true
  }

  export type TenantOnboardingTaskSumAggregateInputType = {
    sortOrder?: true
  }

  export type TenantOnboardingTaskMinAggregateInputType = {
    id?: true
    tenantOnboardingPlanId?: true
    tenantId?: true
    taskKey?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    required?: true
    ownerRole?: true
    ownerActorId?: true
    dueAt?: true
    blockedByClient?: true
    blockerReason?: true
    sortOrder?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantOnboardingTaskMaxAggregateInputType = {
    id?: true
    tenantOnboardingPlanId?: true
    tenantId?: true
    taskKey?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    required?: true
    ownerRole?: true
    ownerActorId?: true
    dueAt?: true
    blockedByClient?: true
    blockerReason?: true
    sortOrder?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantOnboardingTaskCountAggregateInputType = {
    id?: true
    tenantOnboardingPlanId?: true
    tenantId?: true
    taskKey?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    required?: true
    ownerRole?: true
    ownerActorId?: true
    dueAt?: true
    blockedByClient?: true
    blockerReason?: true
    sortOrder?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantOnboardingTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantOnboardingTask to aggregate.
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingTasks to fetch.
     */
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantOnboardingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantOnboardingTasks
    **/
    _count?: true | TenantOnboardingTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TenantOnboardingTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TenantOnboardingTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantOnboardingTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantOnboardingTaskMaxAggregateInputType
  }

  export type GetTenantOnboardingTaskAggregateType<T extends TenantOnboardingTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantOnboardingTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantOnboardingTask[P]>
      : GetScalarType<T[P], AggregateTenantOnboardingTask[P]>
  }




  export type TenantOnboardingTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantOnboardingTaskWhereInput
    orderBy?: TenantOnboardingTaskOrderByWithAggregationInput | TenantOnboardingTaskOrderByWithAggregationInput[]
    by: TenantOnboardingTaskScalarFieldEnum[] | TenantOnboardingTaskScalarFieldEnum
    having?: TenantOnboardingTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantOnboardingTaskCountAggregateInputType | true
    _avg?: TenantOnboardingTaskAvgAggregateInputType
    _sum?: TenantOnboardingTaskSumAggregateInputType
    _min?: TenantOnboardingTaskMinAggregateInputType
    _max?: TenantOnboardingTaskMaxAggregateInputType
  }

  export type TenantOnboardingTaskGroupByOutputType = {
    id: string
    tenantOnboardingPlanId: string
    tenantId: string
    taskKey: string
    title: string
    description: string | null
    status: string
    priority: string
    required: boolean
    ownerRole: string
    ownerActorId: string | null
    dueAt: Date | null
    blockedByClient: boolean
    blockerReason: string | null
    sortOrder: number
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TenantOnboardingTaskCountAggregateOutputType | null
    _avg: TenantOnboardingTaskAvgAggregateOutputType | null
    _sum: TenantOnboardingTaskSumAggregateOutputType | null
    _min: TenantOnboardingTaskMinAggregateOutputType | null
    _max: TenantOnboardingTaskMaxAggregateOutputType | null
  }

  type GetTenantOnboardingTaskGroupByPayload<T extends TenantOnboardingTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantOnboardingTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantOnboardingTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantOnboardingTaskGroupByOutputType[P]>
            : GetScalarType<T[P], TenantOnboardingTaskGroupByOutputType[P]>
        }
      >
    >


  export type TenantOnboardingTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantOnboardingPlanId?: boolean
    tenantId?: boolean
    taskKey?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    required?: boolean
    ownerRole?: boolean
    ownerActorId?: boolean
    dueAt?: boolean
    blockedByClient?: boolean
    blockerReason?: boolean
    sortOrder?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingTask"]>

  export type TenantOnboardingTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantOnboardingPlanId?: boolean
    tenantId?: boolean
    taskKey?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    required?: boolean
    ownerRole?: boolean
    ownerActorId?: boolean
    dueAt?: boolean
    blockedByClient?: boolean
    blockerReason?: boolean
    sortOrder?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingTask"]>

  export type TenantOnboardingTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantOnboardingPlanId?: boolean
    tenantId?: boolean
    taskKey?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    required?: boolean
    ownerRole?: boolean
    ownerActorId?: boolean
    dueAt?: boolean
    blockedByClient?: boolean
    blockerReason?: boolean
    sortOrder?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantOnboardingTask"]>

  export type TenantOnboardingTaskSelectScalar = {
    id?: boolean
    tenantOnboardingPlanId?: boolean
    tenantId?: boolean
    taskKey?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    required?: boolean
    ownerRole?: boolean
    ownerActorId?: boolean
    dueAt?: boolean
    blockedByClient?: boolean
    blockerReason?: boolean
    sortOrder?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOnboardingTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantOnboardingPlanId" | "tenantId" | "taskKey" | "title" | "description" | "status" | "priority" | "required" | "ownerRole" | "ownerActorId" | "dueAt" | "blockedByClient" | "blockerReason" | "sortOrder" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tenantOnboardingTask"]>
  export type TenantOnboardingTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }
  export type TenantOnboardingTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }
  export type TenantOnboardingTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    onboardingPlan?: boolean | TenantOnboardingPlanDefaultArgs<ExtArgs>
  }

  export type $TenantOnboardingTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantOnboardingTask"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      onboardingPlan: Prisma.$TenantOnboardingPlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantOnboardingPlanId: string
      tenantId: string
      taskKey: string
      title: string
      description: string | null
      status: string
      priority: string
      required: boolean
      ownerRole: string
      ownerActorId: string | null
      dueAt: Date | null
      blockedByClient: boolean
      blockerReason: string | null
      sortOrder: number
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenantOnboardingTask"]>
    composites: {}
  }

  type TenantOnboardingTaskGetPayload<S extends boolean | null | undefined | TenantOnboardingTaskDefaultArgs> = $Result.GetResult<Prisma.$TenantOnboardingTaskPayload, S>

  type TenantOnboardingTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantOnboardingTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantOnboardingTaskCountAggregateInputType | true
    }

  export interface TenantOnboardingTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantOnboardingTask'], meta: { name: 'TenantOnboardingTask' } }
    /**
     * Find zero or one TenantOnboardingTask that matches the filter.
     * @param {TenantOnboardingTaskFindUniqueArgs} args - Arguments to find a TenantOnboardingTask
     * @example
     * // Get one TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantOnboardingTaskFindUniqueArgs>(args: SelectSubset<T, TenantOnboardingTaskFindUniqueArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantOnboardingTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantOnboardingTaskFindUniqueOrThrowArgs} args - Arguments to find a TenantOnboardingTask
     * @example
     * // Get one TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantOnboardingTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantOnboardingTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOnboardingTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskFindFirstArgs} args - Arguments to find a TenantOnboardingTask
     * @example
     * // Get one TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantOnboardingTaskFindFirstArgs>(args?: SelectSubset<T, TenantOnboardingTaskFindFirstArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantOnboardingTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskFindFirstOrThrowArgs} args - Arguments to find a TenantOnboardingTask
     * @example
     * // Get one TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantOnboardingTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantOnboardingTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantOnboardingTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantOnboardingTasks
     * const tenantOnboardingTasks = await prisma.tenantOnboardingTask.findMany()
     * 
     * // Get first 10 TenantOnboardingTasks
     * const tenantOnboardingTasks = await prisma.tenantOnboardingTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantOnboardingTaskWithIdOnly = await prisma.tenantOnboardingTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantOnboardingTaskFindManyArgs>(args?: SelectSubset<T, TenantOnboardingTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantOnboardingTask.
     * @param {TenantOnboardingTaskCreateArgs} args - Arguments to create a TenantOnboardingTask.
     * @example
     * // Create one TenantOnboardingTask
     * const TenantOnboardingTask = await prisma.tenantOnboardingTask.create({
     *   data: {
     *     // ... data to create a TenantOnboardingTask
     *   }
     * })
     * 
     */
    create<T extends TenantOnboardingTaskCreateArgs>(args: SelectSubset<T, TenantOnboardingTaskCreateArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantOnboardingTasks.
     * @param {TenantOnboardingTaskCreateManyArgs} args - Arguments to create many TenantOnboardingTasks.
     * @example
     * // Create many TenantOnboardingTasks
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantOnboardingTaskCreateManyArgs>(args?: SelectSubset<T, TenantOnboardingTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantOnboardingTasks and returns the data saved in the database.
     * @param {TenantOnboardingTaskCreateManyAndReturnArgs} args - Arguments to create many TenantOnboardingTasks.
     * @example
     * // Create many TenantOnboardingTasks
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantOnboardingTasks and only return the `id`
     * const tenantOnboardingTaskWithIdOnly = await prisma.tenantOnboardingTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantOnboardingTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantOnboardingTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantOnboardingTask.
     * @param {TenantOnboardingTaskDeleteArgs} args - Arguments to delete one TenantOnboardingTask.
     * @example
     * // Delete one TenantOnboardingTask
     * const TenantOnboardingTask = await prisma.tenantOnboardingTask.delete({
     *   where: {
     *     // ... filter to delete one TenantOnboardingTask
     *   }
     * })
     * 
     */
    delete<T extends TenantOnboardingTaskDeleteArgs>(args: SelectSubset<T, TenantOnboardingTaskDeleteArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantOnboardingTask.
     * @param {TenantOnboardingTaskUpdateArgs} args - Arguments to update one TenantOnboardingTask.
     * @example
     * // Update one TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantOnboardingTaskUpdateArgs>(args: SelectSubset<T, TenantOnboardingTaskUpdateArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantOnboardingTasks.
     * @param {TenantOnboardingTaskDeleteManyArgs} args - Arguments to filter TenantOnboardingTasks to delete.
     * @example
     * // Delete a few TenantOnboardingTasks
     * const { count } = await prisma.tenantOnboardingTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantOnboardingTaskDeleteManyArgs>(args?: SelectSubset<T, TenantOnboardingTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOnboardingTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantOnboardingTasks
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantOnboardingTaskUpdateManyArgs>(args: SelectSubset<T, TenantOnboardingTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantOnboardingTasks and returns the data updated in the database.
     * @param {TenantOnboardingTaskUpdateManyAndReturnArgs} args - Arguments to update many TenantOnboardingTasks.
     * @example
     * // Update many TenantOnboardingTasks
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantOnboardingTasks and only return the `id`
     * const tenantOnboardingTaskWithIdOnly = await prisma.tenantOnboardingTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantOnboardingTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantOnboardingTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantOnboardingTask.
     * @param {TenantOnboardingTaskUpsertArgs} args - Arguments to update or create a TenantOnboardingTask.
     * @example
     * // Update or create a TenantOnboardingTask
     * const tenantOnboardingTask = await prisma.tenantOnboardingTask.upsert({
     *   create: {
     *     // ... data to create a TenantOnboardingTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantOnboardingTask we want to update
     *   }
     * })
     */
    upsert<T extends TenantOnboardingTaskUpsertArgs>(args: SelectSubset<T, TenantOnboardingTaskUpsertArgs<ExtArgs>>): Prisma__TenantOnboardingTaskClient<$Result.GetResult<Prisma.$TenantOnboardingTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantOnboardingTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskCountArgs} args - Arguments to filter TenantOnboardingTasks to count.
     * @example
     * // Count the number of TenantOnboardingTasks
     * const count = await prisma.tenantOnboardingTask.count({
     *   where: {
     *     // ... the filter for the TenantOnboardingTasks we want to count
     *   }
     * })
    **/
    count<T extends TenantOnboardingTaskCountArgs>(
      args?: Subset<T, TenantOnboardingTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantOnboardingTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantOnboardingTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantOnboardingTaskAggregateArgs>(args: Subset<T, TenantOnboardingTaskAggregateArgs>): Prisma.PrismaPromise<GetTenantOnboardingTaskAggregateType<T>>

    /**
     * Group by TenantOnboardingTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantOnboardingTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantOnboardingTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantOnboardingTaskGroupByArgs['orderBy'] }
        : { orderBy?: TenantOnboardingTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantOnboardingTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantOnboardingTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantOnboardingTask model
   */
  readonly fields: TenantOnboardingTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantOnboardingTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantOnboardingTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    onboardingPlan<T extends TenantOnboardingPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantOnboardingPlanDefaultArgs<ExtArgs>>): Prisma__TenantOnboardingPlanClient<$Result.GetResult<Prisma.$TenantOnboardingPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantOnboardingTask model
   */
  interface TenantOnboardingTaskFieldRefs {
    readonly id: FieldRef<"TenantOnboardingTask", 'String'>
    readonly tenantOnboardingPlanId: FieldRef<"TenantOnboardingTask", 'String'>
    readonly tenantId: FieldRef<"TenantOnboardingTask", 'String'>
    readonly taskKey: FieldRef<"TenantOnboardingTask", 'String'>
    readonly title: FieldRef<"TenantOnboardingTask", 'String'>
    readonly description: FieldRef<"TenantOnboardingTask", 'String'>
    readonly status: FieldRef<"TenantOnboardingTask", 'String'>
    readonly priority: FieldRef<"TenantOnboardingTask", 'String'>
    readonly required: FieldRef<"TenantOnboardingTask", 'Boolean'>
    readonly ownerRole: FieldRef<"TenantOnboardingTask", 'String'>
    readonly ownerActorId: FieldRef<"TenantOnboardingTask", 'String'>
    readonly dueAt: FieldRef<"TenantOnboardingTask", 'DateTime'>
    readonly blockedByClient: FieldRef<"TenantOnboardingTask", 'Boolean'>
    readonly blockerReason: FieldRef<"TenantOnboardingTask", 'String'>
    readonly sortOrder: FieldRef<"TenantOnboardingTask", 'Int'>
    readonly completedAt: FieldRef<"TenantOnboardingTask", 'DateTime'>
    readonly createdAt: FieldRef<"TenantOnboardingTask", 'DateTime'>
    readonly updatedAt: FieldRef<"TenantOnboardingTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TenantOnboardingTask findUnique
   */
  export type TenantOnboardingTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingTask to fetch.
     */
    where: TenantOnboardingTaskWhereUniqueInput
  }

  /**
   * TenantOnboardingTask findUniqueOrThrow
   */
  export type TenantOnboardingTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingTask to fetch.
     */
    where: TenantOnboardingTaskWhereUniqueInput
  }

  /**
   * TenantOnboardingTask findFirst
   */
  export type TenantOnboardingTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingTask to fetch.
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingTasks to fetch.
     */
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantOnboardingTasks.
     */
    cursor?: TenantOnboardingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantOnboardingTasks.
     */
    distinct?: TenantOnboardingTaskScalarFieldEnum | TenantOnboardingTaskScalarFieldEnum[]
  }

  /**
   * TenantOnboardingTask findFirstOrThrow
   */
  export type TenantOnboardingTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingTask to fetch.
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingTasks to fetch.
     */
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantOnboardingTasks.
     */
    cursor?: TenantOnboardingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantOnboardingTasks.
     */
    distinct?: TenantOnboardingTaskScalarFieldEnum | TenantOnboardingTaskScalarFieldEnum[]
  }

  /**
   * TenantOnboardingTask findMany
   */
  export type TenantOnboardingTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter, which TenantOnboardingTasks to fetch.
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantOnboardingTasks to fetch.
     */
    orderBy?: TenantOnboardingTaskOrderByWithRelationInput | TenantOnboardingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantOnboardingTasks.
     */
    cursor?: TenantOnboardingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantOnboardingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantOnboardingTasks.
     */
    skip?: number
    distinct?: TenantOnboardingTaskScalarFieldEnum | TenantOnboardingTaskScalarFieldEnum[]
  }

  /**
   * TenantOnboardingTask create
   */
  export type TenantOnboardingTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantOnboardingTask.
     */
    data: XOR<TenantOnboardingTaskCreateInput, TenantOnboardingTaskUncheckedCreateInput>
  }

  /**
   * TenantOnboardingTask createMany
   */
  export type TenantOnboardingTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantOnboardingTasks.
     */
    data: TenantOnboardingTaskCreateManyInput | TenantOnboardingTaskCreateManyInput[]
  }

  /**
   * TenantOnboardingTask createManyAndReturn
   */
  export type TenantOnboardingTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * The data used to create many TenantOnboardingTasks.
     */
    data: TenantOnboardingTaskCreateManyInput | TenantOnboardingTaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantOnboardingTask update
   */
  export type TenantOnboardingTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantOnboardingTask.
     */
    data: XOR<TenantOnboardingTaskUpdateInput, TenantOnboardingTaskUncheckedUpdateInput>
    /**
     * Choose, which TenantOnboardingTask to update.
     */
    where: TenantOnboardingTaskWhereUniqueInput
  }

  /**
   * TenantOnboardingTask updateMany
   */
  export type TenantOnboardingTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantOnboardingTasks.
     */
    data: XOR<TenantOnboardingTaskUpdateManyMutationInput, TenantOnboardingTaskUncheckedUpdateManyInput>
    /**
     * Filter which TenantOnboardingTasks to update
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * Limit how many TenantOnboardingTasks to update.
     */
    limit?: number
  }

  /**
   * TenantOnboardingTask updateManyAndReturn
   */
  export type TenantOnboardingTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * The data used to update TenantOnboardingTasks.
     */
    data: XOR<TenantOnboardingTaskUpdateManyMutationInput, TenantOnboardingTaskUncheckedUpdateManyInput>
    /**
     * Filter which TenantOnboardingTasks to update
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * Limit how many TenantOnboardingTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantOnboardingTask upsert
   */
  export type TenantOnboardingTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantOnboardingTask to update in case it exists.
     */
    where: TenantOnboardingTaskWhereUniqueInput
    /**
     * In case the TenantOnboardingTask found by the `where` argument doesn't exist, create a new TenantOnboardingTask with this data.
     */
    create: XOR<TenantOnboardingTaskCreateInput, TenantOnboardingTaskUncheckedCreateInput>
    /**
     * In case the TenantOnboardingTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantOnboardingTaskUpdateInput, TenantOnboardingTaskUncheckedUpdateInput>
  }

  /**
   * TenantOnboardingTask delete
   */
  export type TenantOnboardingTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
    /**
     * Filter which TenantOnboardingTask to delete.
     */
    where: TenantOnboardingTaskWhereUniqueInput
  }

  /**
   * TenantOnboardingTask deleteMany
   */
  export type TenantOnboardingTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantOnboardingTasks to delete
     */
    where?: TenantOnboardingTaskWhereInput
    /**
     * Limit how many TenantOnboardingTasks to delete.
     */
    limit?: number
  }

  /**
   * TenantOnboardingTask without action
   */
  export type TenantOnboardingTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantOnboardingTask
     */
    select?: TenantOnboardingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantOnboardingTask
     */
    omit?: TenantOnboardingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantOnboardingTaskInclude<ExtArgs> | null
  }


  /**
   * Model ModuleConfig
   */

  export type AggregateModuleConfig = {
    _count: ModuleConfigCountAggregateOutputType | null
    _avg: ModuleConfigAvgAggregateOutputType | null
    _sum: ModuleConfigSumAggregateOutputType | null
    _min: ModuleConfigMinAggregateOutputType | null
    _max: ModuleConfigMaxAggregateOutputType | null
  }

  export type ModuleConfigAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ModuleConfigSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ModuleConfigMinAggregateOutputType = {
    id: string | null
    websiteConfigId: string | null
    tenantId: string | null
    moduleKey: string | null
    enabled: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleConfigMaxAggregateOutputType = {
    id: string | null
    websiteConfigId: string | null
    tenantId: string | null
    moduleKey: string | null
    enabled: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleConfigCountAggregateOutputType = {
    id: number
    websiteConfigId: number
    tenantId: number
    moduleKey: number
    enabled: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleConfigAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ModuleConfigSumAggregateInputType = {
    sortOrder?: true
  }

  export type ModuleConfigMinAggregateInputType = {
    id?: true
    websiteConfigId?: true
    tenantId?: true
    moduleKey?: true
    enabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleConfigMaxAggregateInputType = {
    id?: true
    websiteConfigId?: true
    tenantId?: true
    moduleKey?: true
    enabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleConfigCountAggregateInputType = {
    id?: true
    websiteConfigId?: true
    tenantId?: true
    moduleKey?: true
    enabled?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleConfig to aggregate.
     */
    where?: ModuleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleConfigs to fetch.
     */
    orderBy?: ModuleConfigOrderByWithRelationInput | ModuleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleConfigs
    **/
    _count?: true | ModuleConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleConfigMaxAggregateInputType
  }

  export type GetModuleConfigAggregateType<T extends ModuleConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleConfig[P]>
      : GetScalarType<T[P], AggregateModuleConfig[P]>
  }




  export type ModuleConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleConfigWhereInput
    orderBy?: ModuleConfigOrderByWithAggregationInput | ModuleConfigOrderByWithAggregationInput[]
    by: ModuleConfigScalarFieldEnum[] | ModuleConfigScalarFieldEnum
    having?: ModuleConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleConfigCountAggregateInputType | true
    _avg?: ModuleConfigAvgAggregateInputType
    _sum?: ModuleConfigSumAggregateInputType
    _min?: ModuleConfigMinAggregateInputType
    _max?: ModuleConfigMaxAggregateInputType
  }

  export type ModuleConfigGroupByOutputType = {
    id: string
    websiteConfigId: string
    tenantId: string
    moduleKey: string
    enabled: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ModuleConfigCountAggregateOutputType | null
    _avg: ModuleConfigAvgAggregateOutputType | null
    _sum: ModuleConfigSumAggregateOutputType | null
    _min: ModuleConfigMinAggregateOutputType | null
    _max: ModuleConfigMaxAggregateOutputType | null
  }

  type GetModuleConfigGroupByPayload<T extends ModuleConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleConfigGroupByOutputType[P]>
        }
      >
    >


  export type ModuleConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteConfigId?: boolean
    tenantId?: boolean
    moduleKey?: boolean
    enabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleConfig"]>

  export type ModuleConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteConfigId?: boolean
    tenantId?: boolean
    moduleKey?: boolean
    enabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleConfig"]>

  export type ModuleConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    websiteConfigId?: boolean
    tenantId?: boolean
    moduleKey?: boolean
    enabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleConfig"]>

  export type ModuleConfigSelectScalar = {
    id?: boolean
    websiteConfigId?: boolean
    tenantId?: boolean
    moduleKey?: boolean
    enabled?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "websiteConfigId" | "tenantId" | "moduleKey" | "enabled" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["moduleConfig"]>
  export type ModuleConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }
  export type ModuleConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }
  export type ModuleConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    websiteConfig?: boolean | WebsiteConfigDefaultArgs<ExtArgs>
  }

  export type $ModuleConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleConfig"
    objects: {
      websiteConfig: Prisma.$WebsiteConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      websiteConfigId: string
      tenantId: string
      moduleKey: string
      enabled: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moduleConfig"]>
    composites: {}
  }

  type ModuleConfigGetPayload<S extends boolean | null | undefined | ModuleConfigDefaultArgs> = $Result.GetResult<Prisma.$ModuleConfigPayload, S>

  type ModuleConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleConfigCountAggregateInputType | true
    }

  export interface ModuleConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleConfig'], meta: { name: 'ModuleConfig' } }
    /**
     * Find zero or one ModuleConfig that matches the filter.
     * @param {ModuleConfigFindUniqueArgs} args - Arguments to find a ModuleConfig
     * @example
     * // Get one ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleConfigFindUniqueArgs>(args: SelectSubset<T, ModuleConfigFindUniqueArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleConfigFindUniqueOrThrowArgs} args - Arguments to find a ModuleConfig
     * @example
     * // Get one ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigFindFirstArgs} args - Arguments to find a ModuleConfig
     * @example
     * // Get one ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleConfigFindFirstArgs>(args?: SelectSubset<T, ModuleConfigFindFirstArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigFindFirstOrThrowArgs} args - Arguments to find a ModuleConfig
     * @example
     * // Get one ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleConfigs
     * const moduleConfigs = await prisma.moduleConfig.findMany()
     * 
     * // Get first 10 ModuleConfigs
     * const moduleConfigs = await prisma.moduleConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleConfigWithIdOnly = await prisma.moduleConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleConfigFindManyArgs>(args?: SelectSubset<T, ModuleConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleConfig.
     * @param {ModuleConfigCreateArgs} args - Arguments to create a ModuleConfig.
     * @example
     * // Create one ModuleConfig
     * const ModuleConfig = await prisma.moduleConfig.create({
     *   data: {
     *     // ... data to create a ModuleConfig
     *   }
     * })
     * 
     */
    create<T extends ModuleConfigCreateArgs>(args: SelectSubset<T, ModuleConfigCreateArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleConfigs.
     * @param {ModuleConfigCreateManyArgs} args - Arguments to create many ModuleConfigs.
     * @example
     * // Create many ModuleConfigs
     * const moduleConfig = await prisma.moduleConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleConfigCreateManyArgs>(args?: SelectSubset<T, ModuleConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleConfigs and returns the data saved in the database.
     * @param {ModuleConfigCreateManyAndReturnArgs} args - Arguments to create many ModuleConfigs.
     * @example
     * // Create many ModuleConfigs
     * const moduleConfig = await prisma.moduleConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleConfigs and only return the `id`
     * const moduleConfigWithIdOnly = await prisma.moduleConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleConfig.
     * @param {ModuleConfigDeleteArgs} args - Arguments to delete one ModuleConfig.
     * @example
     * // Delete one ModuleConfig
     * const ModuleConfig = await prisma.moduleConfig.delete({
     *   where: {
     *     // ... filter to delete one ModuleConfig
     *   }
     * })
     * 
     */
    delete<T extends ModuleConfigDeleteArgs>(args: SelectSubset<T, ModuleConfigDeleteArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleConfig.
     * @param {ModuleConfigUpdateArgs} args - Arguments to update one ModuleConfig.
     * @example
     * // Update one ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleConfigUpdateArgs>(args: SelectSubset<T, ModuleConfigUpdateArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleConfigs.
     * @param {ModuleConfigDeleteManyArgs} args - Arguments to filter ModuleConfigs to delete.
     * @example
     * // Delete a few ModuleConfigs
     * const { count } = await prisma.moduleConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleConfigDeleteManyArgs>(args?: SelectSubset<T, ModuleConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleConfigs
     * const moduleConfig = await prisma.moduleConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleConfigUpdateManyArgs>(args: SelectSubset<T, ModuleConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleConfigs and returns the data updated in the database.
     * @param {ModuleConfigUpdateManyAndReturnArgs} args - Arguments to update many ModuleConfigs.
     * @example
     * // Update many ModuleConfigs
     * const moduleConfig = await prisma.moduleConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleConfigs and only return the `id`
     * const moduleConfigWithIdOnly = await prisma.moduleConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleConfig.
     * @param {ModuleConfigUpsertArgs} args - Arguments to update or create a ModuleConfig.
     * @example
     * // Update or create a ModuleConfig
     * const moduleConfig = await prisma.moduleConfig.upsert({
     *   create: {
     *     // ... data to create a ModuleConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleConfig we want to update
     *   }
     * })
     */
    upsert<T extends ModuleConfigUpsertArgs>(args: SelectSubset<T, ModuleConfigUpsertArgs<ExtArgs>>): Prisma__ModuleConfigClient<$Result.GetResult<Prisma.$ModuleConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigCountArgs} args - Arguments to filter ModuleConfigs to count.
     * @example
     * // Count the number of ModuleConfigs
     * const count = await prisma.moduleConfig.count({
     *   where: {
     *     // ... the filter for the ModuleConfigs we want to count
     *   }
     * })
    **/
    count<T extends ModuleConfigCountArgs>(
      args?: Subset<T, ModuleConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleConfigAggregateArgs>(args: Subset<T, ModuleConfigAggregateArgs>): Prisma.PrismaPromise<GetModuleConfigAggregateType<T>>

    /**
     * Group by ModuleConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleConfigGroupByArgs['orderBy'] }
        : { orderBy?: ModuleConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleConfig model
   */
  readonly fields: ModuleConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    websiteConfig<T extends WebsiteConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WebsiteConfigDefaultArgs<ExtArgs>>): Prisma__WebsiteConfigClient<$Result.GetResult<Prisma.$WebsiteConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleConfig model
   */
  interface ModuleConfigFieldRefs {
    readonly id: FieldRef<"ModuleConfig", 'String'>
    readonly websiteConfigId: FieldRef<"ModuleConfig", 'String'>
    readonly tenantId: FieldRef<"ModuleConfig", 'String'>
    readonly moduleKey: FieldRef<"ModuleConfig", 'String'>
    readonly enabled: FieldRef<"ModuleConfig", 'Boolean'>
    readonly sortOrder: FieldRef<"ModuleConfig", 'Int'>
    readonly createdAt: FieldRef<"ModuleConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ModuleConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuleConfig findUnique
   */
  export type ModuleConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter, which ModuleConfig to fetch.
     */
    where: ModuleConfigWhereUniqueInput
  }

  /**
   * ModuleConfig findUniqueOrThrow
   */
  export type ModuleConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter, which ModuleConfig to fetch.
     */
    where: ModuleConfigWhereUniqueInput
  }

  /**
   * ModuleConfig findFirst
   */
  export type ModuleConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter, which ModuleConfig to fetch.
     */
    where?: ModuleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleConfigs to fetch.
     */
    orderBy?: ModuleConfigOrderByWithRelationInput | ModuleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleConfigs.
     */
    cursor?: ModuleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleConfigs.
     */
    distinct?: ModuleConfigScalarFieldEnum | ModuleConfigScalarFieldEnum[]
  }

  /**
   * ModuleConfig findFirstOrThrow
   */
  export type ModuleConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter, which ModuleConfig to fetch.
     */
    where?: ModuleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleConfigs to fetch.
     */
    orderBy?: ModuleConfigOrderByWithRelationInput | ModuleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleConfigs.
     */
    cursor?: ModuleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleConfigs.
     */
    distinct?: ModuleConfigScalarFieldEnum | ModuleConfigScalarFieldEnum[]
  }

  /**
   * ModuleConfig findMany
   */
  export type ModuleConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter, which ModuleConfigs to fetch.
     */
    where?: ModuleConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleConfigs to fetch.
     */
    orderBy?: ModuleConfigOrderByWithRelationInput | ModuleConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleConfigs.
     */
    cursor?: ModuleConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleConfigs.
     */
    skip?: number
    distinct?: ModuleConfigScalarFieldEnum | ModuleConfigScalarFieldEnum[]
  }

  /**
   * ModuleConfig create
   */
  export type ModuleConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleConfig.
     */
    data: XOR<ModuleConfigCreateInput, ModuleConfigUncheckedCreateInput>
  }

  /**
   * ModuleConfig createMany
   */
  export type ModuleConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleConfigs.
     */
    data: ModuleConfigCreateManyInput | ModuleConfigCreateManyInput[]
  }

  /**
   * ModuleConfig createManyAndReturn
   */
  export type ModuleConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleConfigs.
     */
    data: ModuleConfigCreateManyInput | ModuleConfigCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleConfig update
   */
  export type ModuleConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleConfig.
     */
    data: XOR<ModuleConfigUpdateInput, ModuleConfigUncheckedUpdateInput>
    /**
     * Choose, which ModuleConfig to update.
     */
    where: ModuleConfigWhereUniqueInput
  }

  /**
   * ModuleConfig updateMany
   */
  export type ModuleConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleConfigs.
     */
    data: XOR<ModuleConfigUpdateManyMutationInput, ModuleConfigUncheckedUpdateManyInput>
    /**
     * Filter which ModuleConfigs to update
     */
    where?: ModuleConfigWhereInput
    /**
     * Limit how many ModuleConfigs to update.
     */
    limit?: number
  }

  /**
   * ModuleConfig updateManyAndReturn
   */
  export type ModuleConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * The data used to update ModuleConfigs.
     */
    data: XOR<ModuleConfigUpdateManyMutationInput, ModuleConfigUncheckedUpdateManyInput>
    /**
     * Filter which ModuleConfigs to update
     */
    where?: ModuleConfigWhereInput
    /**
     * Limit how many ModuleConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleConfig upsert
   */
  export type ModuleConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleConfig to update in case it exists.
     */
    where: ModuleConfigWhereUniqueInput
    /**
     * In case the ModuleConfig found by the `where` argument doesn't exist, create a new ModuleConfig with this data.
     */
    create: XOR<ModuleConfigCreateInput, ModuleConfigUncheckedCreateInput>
    /**
     * In case the ModuleConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleConfigUpdateInput, ModuleConfigUncheckedUpdateInput>
  }

  /**
   * ModuleConfig delete
   */
  export type ModuleConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
    /**
     * Filter which ModuleConfig to delete.
     */
    where: ModuleConfigWhereUniqueInput
  }

  /**
   * ModuleConfig deleteMany
   */
  export type ModuleConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleConfigs to delete
     */
    where?: ModuleConfigWhereInput
    /**
     * Limit how many ModuleConfigs to delete.
     */
    limit?: number
  }

  /**
   * ModuleConfig without action
   */
  export type ModuleConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleConfig
     */
    select?: ModuleConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleConfig
     */
    omit?: ModuleConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleConfigInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fullName: string | null
    email: string | null
    emailNormalized: string | null
    phone: string | null
    phoneNormalized: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    fullName: string | null
    email: string | null
    emailNormalized: string | null
    phone: string | null
    phoneNormalized: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    tenantId: number
    fullName: number
    email: number
    emailNormalized: number
    phone: number
    phoneNormalized: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    emailNormalized?: true
    phone?: true
    phoneNormalized?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    emailNormalized?: true
    phone?: true
    phoneNormalized?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    tenantId?: true
    fullName?: true
    email?: true
    emailNormalized?: true
    phone?: true
    phoneNormalized?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    tenantId: string
    fullName: string | null
    email: string | null
    emailNormalized: string | null
    phone: string | null
    phoneNormalized: string | null
    source: string
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    emailNormalized?: boolean
    phone?: boolean
    phoneNormalized?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    leads?: boolean | Contact$leadsArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    emailNormalized?: boolean
    phone?: boolean
    phoneNormalized?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    emailNormalized?: boolean
    phone?: boolean
    phoneNormalized?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    tenantId?: boolean
    fullName?: boolean
    email?: boolean
    emailNormalized?: boolean
    phone?: boolean
    phoneNormalized?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "fullName" | "email" | "emailNormalized" | "phone" | "phoneNormalized" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    leads?: boolean | Contact$leadsArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      leads: Prisma.$LeadPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      fullName: string | null
      email: string | null
      emailNormalized: string | null
      phone: string | null
      phoneNormalized: string | null
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leads<T extends Contact$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Contact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly tenantId: FieldRef<"Contact", 'String'>
    readonly fullName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly emailNormalized: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly phoneNormalized: FieldRef<"Contact", 'String'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.leads
   */
  export type Contact$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Contact.activities
   */
  export type Contact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type LeadSumAggregateOutputType = {
    beds: number | null
    baths: number | null
    sqft: number | null
    priceMin: number | null
    priceMax: number | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    status: string | null
    leadType: string | null
    source: string | null
    timeframe: string | null
    notes: string | null
    listingId: string | null
    listingUrl: string | null
    listingAddress: string | null
    propertyType: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    lastContactAt: Date | null
    nextActionAt: Date | null
    nextActionNote: string | null
    nextActionChannel: string | null
    reminderSnoozedUntil: Date | null
    priceMin: number | null
    priceMax: number | null
    tags: string | null
    closeReason: string | null
    closeNotes: string | null
    closedAt: Date | null
    assignedTo: string | null
    referredBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    status: string | null
    leadType: string | null
    source: string | null
    timeframe: string | null
    notes: string | null
    listingId: string | null
    listingUrl: string | null
    listingAddress: string | null
    propertyType: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    lastContactAt: Date | null
    nextActionAt: Date | null
    nextActionNote: string | null
    nextActionChannel: string | null
    reminderSnoozedUntil: Date | null
    priceMin: number | null
    priceMax: number | null
    tags: string | null
    closeReason: string | null
    closeNotes: string | null
    closedAt: Date | null
    assignedTo: string | null
    referredBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    status: number
    leadType: number
    source: number
    timeframe: number
    notes: number
    listingId: number
    listingUrl: number
    listingAddress: number
    propertyType: number
    beds: number
    baths: number
    sqft: number
    lastContactAt: number
    nextActionAt: number
    nextActionNote: number
    nextActionChannel: number
    reminderSnoozedUntil: number
    priceMin: number
    priceMax: number
    tags: number
    closeReason: number
    closeNotes: number
    closedAt: number
    assignedTo: number
    referredBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    priceMin?: true
    priceMax?: true
  }

  export type LeadSumAggregateInputType = {
    beds?: true
    baths?: true
    sqft?: true
    priceMin?: true
    priceMax?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    status?: true
    leadType?: true
    source?: true
    timeframe?: true
    notes?: true
    listingId?: true
    listingUrl?: true
    listingAddress?: true
    propertyType?: true
    beds?: true
    baths?: true
    sqft?: true
    lastContactAt?: true
    nextActionAt?: true
    nextActionNote?: true
    nextActionChannel?: true
    reminderSnoozedUntil?: true
    priceMin?: true
    priceMax?: true
    tags?: true
    closeReason?: true
    closeNotes?: true
    closedAt?: true
    assignedTo?: true
    referredBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    status?: true
    leadType?: true
    source?: true
    timeframe?: true
    notes?: true
    listingId?: true
    listingUrl?: true
    listingAddress?: true
    propertyType?: true
    beds?: true
    baths?: true
    sqft?: true
    lastContactAt?: true
    nextActionAt?: true
    nextActionNote?: true
    nextActionChannel?: true
    reminderSnoozedUntil?: true
    priceMin?: true
    priceMax?: true
    tags?: true
    closeReason?: true
    closeNotes?: true
    closedAt?: true
    assignedTo?: true
    referredBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    status?: true
    leadType?: true
    source?: true
    timeframe?: true
    notes?: true
    listingId?: true
    listingUrl?: true
    listingAddress?: true
    propertyType?: true
    beds?: true
    baths?: true
    sqft?: true
    lastContactAt?: true
    nextActionAt?: true
    nextActionNote?: true
    nextActionChannel?: true
    reminderSnoozedUntil?: true
    priceMin?: true
    priceMax?: true
    tags?: true
    closeReason?: true
    closeNotes?: true
    closedAt?: true
    assignedTo?: true
    referredBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string | null
    status: string
    leadType: string
    source: string
    timeframe: string | null
    notes: string | null
    listingId: string | null
    listingUrl: string | null
    listingAddress: string | null
    propertyType: string | null
    beds: number | null
    baths: number | null
    sqft: number | null
    lastContactAt: Date | null
    nextActionAt: Date | null
    nextActionNote: string | null
    nextActionChannel: string | null
    reminderSnoozedUntil: Date | null
    priceMin: number | null
    priceMax: number | null
    tags: string
    closeReason: string | null
    closeNotes: string | null
    closedAt: Date | null
    assignedTo: string | null
    referredBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    status?: boolean
    leadType?: boolean
    source?: boolean
    timeframe?: boolean
    notes?: boolean
    listingId?: boolean
    listingUrl?: boolean
    listingAddress?: boolean
    propertyType?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    lastContactAt?: boolean
    nextActionAt?: boolean
    nextActionNote?: boolean
    nextActionChannel?: boolean
    reminderSnoozedUntil?: boolean
    priceMin?: boolean
    priceMax?: boolean
    tags?: boolean
    closeReason?: boolean
    closeNotes?: boolean
    closedAt?: boolean
    assignedTo?: boolean
    referredBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    status?: boolean
    leadType?: boolean
    source?: boolean
    timeframe?: boolean
    notes?: boolean
    listingId?: boolean
    listingUrl?: boolean
    listingAddress?: boolean
    propertyType?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    lastContactAt?: boolean
    nextActionAt?: boolean
    nextActionNote?: boolean
    nextActionChannel?: boolean
    reminderSnoozedUntil?: boolean
    priceMin?: boolean
    priceMax?: boolean
    tags?: boolean
    closeReason?: boolean
    closeNotes?: boolean
    closedAt?: boolean
    assignedTo?: boolean
    referredBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    status?: boolean
    leadType?: boolean
    source?: boolean
    timeframe?: boolean
    notes?: boolean
    listingId?: boolean
    listingUrl?: boolean
    listingAddress?: boolean
    propertyType?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    lastContactAt?: boolean
    nextActionAt?: boolean
    nextActionNote?: boolean
    nextActionChannel?: boolean
    reminderSnoozedUntil?: boolean
    priceMin?: boolean
    priceMax?: boolean
    tags?: boolean
    closeReason?: boolean
    closeNotes?: boolean
    closedAt?: boolean
    assignedTo?: boolean
    referredBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    status?: boolean
    leadType?: boolean
    source?: boolean
    timeframe?: boolean
    notes?: boolean
    listingId?: boolean
    listingUrl?: boolean
    listingAddress?: boolean
    propertyType?: boolean
    beds?: boolean
    baths?: boolean
    sqft?: boolean
    lastContactAt?: boolean
    nextActionAt?: boolean
    nextActionNote?: boolean
    nextActionChannel?: boolean
    reminderSnoozedUntil?: boolean
    priceMin?: boolean
    priceMax?: boolean
    tags?: boolean
    closeReason?: boolean
    closeNotes?: boolean
    closedAt?: boolean
    assignedTo?: boolean
    referredBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "status" | "leadType" | "source" | "timeframe" | "notes" | "listingId" | "listingUrl" | "listingAddress" | "propertyType" | "beds" | "baths" | "sqft" | "lastContactAt" | "nextActionAt" | "nextActionNote" | "nextActionChannel" | "reminderSnoozedUntil" | "priceMin" | "priceMax" | "tags" | "closeReason" | "closeNotes" | "closedAt" | "assignedTo" | "referredBy" | "createdAt" | "updatedAt", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
    activities?: boolean | Lead$activitiesArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string | null
      status: string
      leadType: string
      source: string
      timeframe: string | null
      notes: string | null
      listingId: string | null
      listingUrl: string | null
      listingAddress: string | null
      propertyType: string | null
      beds: number | null
      baths: number | null
      sqft: number | null
      lastContactAt: Date | null
      nextActionAt: Date | null
      nextActionNote: string | null
      nextActionChannel: string | null
      reminderSnoozedUntil: Date | null
      priceMin: number | null
      priceMax: number | null
      tags: string
      closeReason: string | null
      closeNotes: string | null
      closedAt: Date | null
      assignedTo: string | null
      referredBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends Lead$contactArgs<ExtArgs> = {}>(args?: Subset<T, Lead$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activities<T extends Lead$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Lead$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly tenantId: FieldRef<"Lead", 'String'>
    readonly contactId: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'String'>
    readonly leadType: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly timeframe: FieldRef<"Lead", 'String'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly listingId: FieldRef<"Lead", 'String'>
    readonly listingUrl: FieldRef<"Lead", 'String'>
    readonly listingAddress: FieldRef<"Lead", 'String'>
    readonly propertyType: FieldRef<"Lead", 'String'>
    readonly beds: FieldRef<"Lead", 'Int'>
    readonly baths: FieldRef<"Lead", 'Int'>
    readonly sqft: FieldRef<"Lead", 'Int'>
    readonly lastContactAt: FieldRef<"Lead", 'DateTime'>
    readonly nextActionAt: FieldRef<"Lead", 'DateTime'>
    readonly nextActionNote: FieldRef<"Lead", 'String'>
    readonly nextActionChannel: FieldRef<"Lead", 'String'>
    readonly reminderSnoozedUntil: FieldRef<"Lead", 'DateTime'>
    readonly priceMin: FieldRef<"Lead", 'Int'>
    readonly priceMax: FieldRef<"Lead", 'Int'>
    readonly tags: FieldRef<"Lead", 'String'>
    readonly closeReason: FieldRef<"Lead", 'String'>
    readonly closeNotes: FieldRef<"Lead", 'String'>
    readonly closedAt: FieldRef<"Lead", 'DateTime'>
    readonly assignedTo: FieldRef<"Lead", 'String'>
    readonly referredBy: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.contact
   */
  export type Lead$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Lead.activities
   */
  export type Lead$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    leadId: string | null
    activityType: string | null
    occurredAt: Date | null
    summary: string | null
    metadataJson: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    leadId: string | null
    activityType: string | null
    occurredAt: Date | null
    summary: string | null
    metadataJson: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    leadId: number
    activityType: number
    occurredAt: number
    summary: number
    metadataJson: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    activityType?: true
    occurredAt?: true
    summary?: true
    metadataJson?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    activityType?: true
    occurredAt?: true
    summary?: true
    metadataJson?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    activityType?: true
    occurredAt?: true
    summary?: true
    metadataJson?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string | null
    leadId: string | null
    activityType: string
    occurredAt: Date
    summary: string
    metadataJson: string | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    activityType?: boolean
    occurredAt?: boolean
    summary?: boolean
    metadataJson?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    activityType?: boolean
    occurredAt?: boolean
    summary?: boolean
    metadataJson?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    activityType?: boolean
    occurredAt?: boolean
    summary?: boolean
    metadataJson?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    activityType?: boolean
    occurredAt?: boolean
    summary?: boolean
    metadataJson?: boolean
    createdAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "leadId" | "activityType" | "occurredAt" | "summary" | "metadataJson" | "createdAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
    lead?: boolean | Activity$leadArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      lead: Prisma.$LeadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string | null
      leadId: string | null
      activityType: string
      occurredAt: Date
      summary: string
      metadataJson: string | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends Activity$contactArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lead<T extends Activity$leadArgs<ExtArgs> = {}>(args?: Subset<T, Activity$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly tenantId: FieldRef<"Activity", 'String'>
    readonly contactId: FieldRef<"Activity", 'String'>
    readonly leadId: FieldRef<"Activity", 'String'>
    readonly activityType: FieldRef<"Activity", 'String'>
    readonly occurredAt: FieldRef<"Activity", 'DateTime'>
    readonly summary: FieldRef<"Activity", 'String'>
    readonly metadataJson: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.contact
   */
  export type Activity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Activity.lead
   */
  export type Activity$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model IngestedEvent
   */

  export type AggregateIngestedEvent = {
    _count: IngestedEventCountAggregateOutputType | null
    _min: IngestedEventMinAggregateOutputType | null
    _max: IngestedEventMaxAggregateOutputType | null
  }

  export type IngestedEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    eventKey: string | null
    occurredAt: Date | null
    payloadJson: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type IngestedEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    eventKey: string | null
    occurredAt: Date | null
    payloadJson: string | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type IngestedEventCountAggregateOutputType = {
    id: number
    tenantId: number
    eventType: number
    eventKey: number
    occurredAt: number
    payloadJson: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type IngestedEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    processedAt?: true
    createdAt?: true
  }

  export type IngestedEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    processedAt?: true
    createdAt?: true
  }

  export type IngestedEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type IngestedEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestedEvent to aggregate.
     */
    where?: IngestedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedEvents to fetch.
     */
    orderBy?: IngestedEventOrderByWithRelationInput | IngestedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngestedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngestedEvents
    **/
    _count?: true | IngestedEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngestedEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngestedEventMaxAggregateInputType
  }

  export type GetIngestedEventAggregateType<T extends IngestedEventAggregateArgs> = {
        [P in keyof T & keyof AggregateIngestedEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestedEvent[P]>
      : GetScalarType<T[P], AggregateIngestedEvent[P]>
  }




  export type IngestedEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestedEventWhereInput
    orderBy?: IngestedEventOrderByWithAggregationInput | IngestedEventOrderByWithAggregationInput[]
    by: IngestedEventScalarFieldEnum[] | IngestedEventScalarFieldEnum
    having?: IngestedEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestedEventCountAggregateInputType | true
    _min?: IngestedEventMinAggregateInputType
    _max?: IngestedEventMaxAggregateInputType
  }

  export type IngestedEventGroupByOutputType = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date
    payloadJson: string
    processedAt: Date
    createdAt: Date
    _count: IngestedEventCountAggregateOutputType | null
    _min: IngestedEventMinAggregateOutputType | null
    _max: IngestedEventMaxAggregateOutputType | null
  }

  type GetIngestedEventGroupByPayload<T extends IngestedEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestedEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngestedEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestedEventGroupByOutputType[P]>
            : GetScalarType<T[P], IngestedEventGroupByOutputType[P]>
        }
      >
    >


  export type IngestedEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestedEvent"]>

  export type IngestedEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestedEvent"]>

  export type IngestedEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    processedAt?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestedEvent"]>

  export type IngestedEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type IngestedEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "eventType" | "eventKey" | "occurredAt" | "payloadJson" | "processedAt" | "createdAt", ExtArgs["result"]["ingestedEvent"]>
  export type IngestedEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IngestedEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IngestedEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $IngestedEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngestedEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      eventType: string
      eventKey: string
      occurredAt: Date
      payloadJson: string
      processedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["ingestedEvent"]>
    composites: {}
  }

  type IngestedEventGetPayload<S extends boolean | null | undefined | IngestedEventDefaultArgs> = $Result.GetResult<Prisma.$IngestedEventPayload, S>

  type IngestedEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngestedEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IngestedEventCountAggregateInputType | true
    }

  export interface IngestedEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngestedEvent'], meta: { name: 'IngestedEvent' } }
    /**
     * Find zero or one IngestedEvent that matches the filter.
     * @param {IngestedEventFindUniqueArgs} args - Arguments to find a IngestedEvent
     * @example
     * // Get one IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestedEventFindUniqueArgs>(args: SelectSubset<T, IngestedEventFindUniqueArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IngestedEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngestedEventFindUniqueOrThrowArgs} args - Arguments to find a IngestedEvent
     * @example
     * // Get one IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestedEventFindUniqueOrThrowArgs>(args: SelectSubset<T, IngestedEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestedEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventFindFirstArgs} args - Arguments to find a IngestedEvent
     * @example
     * // Get one IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestedEventFindFirstArgs>(args?: SelectSubset<T, IngestedEventFindFirstArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestedEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventFindFirstOrThrowArgs} args - Arguments to find a IngestedEvent
     * @example
     * // Get one IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestedEventFindFirstOrThrowArgs>(args?: SelectSubset<T, IngestedEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IngestedEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestedEvents
     * const ingestedEvents = await prisma.ingestedEvent.findMany()
     * 
     * // Get first 10 IngestedEvents
     * const ingestedEvents = await prisma.ingestedEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingestedEventWithIdOnly = await prisma.ingestedEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngestedEventFindManyArgs>(args?: SelectSubset<T, IngestedEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IngestedEvent.
     * @param {IngestedEventCreateArgs} args - Arguments to create a IngestedEvent.
     * @example
     * // Create one IngestedEvent
     * const IngestedEvent = await prisma.ingestedEvent.create({
     *   data: {
     *     // ... data to create a IngestedEvent
     *   }
     * })
     * 
     */
    create<T extends IngestedEventCreateArgs>(args: SelectSubset<T, IngestedEventCreateArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IngestedEvents.
     * @param {IngestedEventCreateManyArgs} args - Arguments to create many IngestedEvents.
     * @example
     * // Create many IngestedEvents
     * const ingestedEvent = await prisma.ingestedEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngestedEventCreateManyArgs>(args?: SelectSubset<T, IngestedEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestedEvents and returns the data saved in the database.
     * @param {IngestedEventCreateManyAndReturnArgs} args - Arguments to create many IngestedEvents.
     * @example
     * // Create many IngestedEvents
     * const ingestedEvent = await prisma.ingestedEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngestedEvents and only return the `id`
     * const ingestedEventWithIdOnly = await prisma.ingestedEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngestedEventCreateManyAndReturnArgs>(args?: SelectSubset<T, IngestedEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IngestedEvent.
     * @param {IngestedEventDeleteArgs} args - Arguments to delete one IngestedEvent.
     * @example
     * // Delete one IngestedEvent
     * const IngestedEvent = await prisma.ingestedEvent.delete({
     *   where: {
     *     // ... filter to delete one IngestedEvent
     *   }
     * })
     * 
     */
    delete<T extends IngestedEventDeleteArgs>(args: SelectSubset<T, IngestedEventDeleteArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IngestedEvent.
     * @param {IngestedEventUpdateArgs} args - Arguments to update one IngestedEvent.
     * @example
     * // Update one IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngestedEventUpdateArgs>(args: SelectSubset<T, IngestedEventUpdateArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IngestedEvents.
     * @param {IngestedEventDeleteManyArgs} args - Arguments to filter IngestedEvents to delete.
     * @example
     * // Delete a few IngestedEvents
     * const { count } = await prisma.ingestedEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngestedEventDeleteManyArgs>(args?: SelectSubset<T, IngestedEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestedEvents
     * const ingestedEvent = await prisma.ingestedEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngestedEventUpdateManyArgs>(args: SelectSubset<T, IngestedEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestedEvents and returns the data updated in the database.
     * @param {IngestedEventUpdateManyAndReturnArgs} args - Arguments to update many IngestedEvents.
     * @example
     * // Update many IngestedEvents
     * const ingestedEvent = await prisma.ingestedEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IngestedEvents and only return the `id`
     * const ingestedEventWithIdOnly = await prisma.ingestedEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IngestedEventUpdateManyAndReturnArgs>(args: SelectSubset<T, IngestedEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IngestedEvent.
     * @param {IngestedEventUpsertArgs} args - Arguments to update or create a IngestedEvent.
     * @example
     * // Update or create a IngestedEvent
     * const ingestedEvent = await prisma.ingestedEvent.upsert({
     *   create: {
     *     // ... data to create a IngestedEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestedEvent we want to update
     *   }
     * })
     */
    upsert<T extends IngestedEventUpsertArgs>(args: SelectSubset<T, IngestedEventUpsertArgs<ExtArgs>>): Prisma__IngestedEventClient<$Result.GetResult<Prisma.$IngestedEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IngestedEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventCountArgs} args - Arguments to filter IngestedEvents to count.
     * @example
     * // Count the number of IngestedEvents
     * const count = await prisma.ingestedEvent.count({
     *   where: {
     *     // ... the filter for the IngestedEvents we want to count
     *   }
     * })
    **/
    count<T extends IngestedEventCountArgs>(
      args?: Subset<T, IngestedEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestedEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngestedEventAggregateArgs>(args: Subset<T, IngestedEventAggregateArgs>): Prisma.PrismaPromise<GetIngestedEventAggregateType<T>>

    /**
     * Group by IngestedEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestedEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngestedEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestedEventGroupByArgs['orderBy'] }
        : { orderBy?: IngestedEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngestedEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngestedEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngestedEvent model
   */
  readonly fields: IngestedEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestedEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestedEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngestedEvent model
   */
  interface IngestedEventFieldRefs {
    readonly id: FieldRef<"IngestedEvent", 'String'>
    readonly tenantId: FieldRef<"IngestedEvent", 'String'>
    readonly eventType: FieldRef<"IngestedEvent", 'String'>
    readonly eventKey: FieldRef<"IngestedEvent", 'String'>
    readonly occurredAt: FieldRef<"IngestedEvent", 'DateTime'>
    readonly payloadJson: FieldRef<"IngestedEvent", 'String'>
    readonly processedAt: FieldRef<"IngestedEvent", 'DateTime'>
    readonly createdAt: FieldRef<"IngestedEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IngestedEvent findUnique
   */
  export type IngestedEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter, which IngestedEvent to fetch.
     */
    where: IngestedEventWhereUniqueInput
  }

  /**
   * IngestedEvent findUniqueOrThrow
   */
  export type IngestedEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter, which IngestedEvent to fetch.
     */
    where: IngestedEventWhereUniqueInput
  }

  /**
   * IngestedEvent findFirst
   */
  export type IngestedEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter, which IngestedEvent to fetch.
     */
    where?: IngestedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedEvents to fetch.
     */
    orderBy?: IngestedEventOrderByWithRelationInput | IngestedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestedEvents.
     */
    cursor?: IngestedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestedEvents.
     */
    distinct?: IngestedEventScalarFieldEnum | IngestedEventScalarFieldEnum[]
  }

  /**
   * IngestedEvent findFirstOrThrow
   */
  export type IngestedEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter, which IngestedEvent to fetch.
     */
    where?: IngestedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedEvents to fetch.
     */
    orderBy?: IngestedEventOrderByWithRelationInput | IngestedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestedEvents.
     */
    cursor?: IngestedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestedEvents.
     */
    distinct?: IngestedEventScalarFieldEnum | IngestedEventScalarFieldEnum[]
  }

  /**
   * IngestedEvent findMany
   */
  export type IngestedEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter, which IngestedEvents to fetch.
     */
    where?: IngestedEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestedEvents to fetch.
     */
    orderBy?: IngestedEventOrderByWithRelationInput | IngestedEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngestedEvents.
     */
    cursor?: IngestedEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestedEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestedEvents.
     */
    skip?: number
    distinct?: IngestedEventScalarFieldEnum | IngestedEventScalarFieldEnum[]
  }

  /**
   * IngestedEvent create
   */
  export type IngestedEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * The data needed to create a IngestedEvent.
     */
    data: XOR<IngestedEventCreateInput, IngestedEventUncheckedCreateInput>
  }

  /**
   * IngestedEvent createMany
   */
  export type IngestedEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngestedEvents.
     */
    data: IngestedEventCreateManyInput | IngestedEventCreateManyInput[]
  }

  /**
   * IngestedEvent createManyAndReturn
   */
  export type IngestedEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * The data used to create many IngestedEvents.
     */
    data: IngestedEventCreateManyInput | IngestedEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestedEvent update
   */
  export type IngestedEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * The data needed to update a IngestedEvent.
     */
    data: XOR<IngestedEventUpdateInput, IngestedEventUncheckedUpdateInput>
    /**
     * Choose, which IngestedEvent to update.
     */
    where: IngestedEventWhereUniqueInput
  }

  /**
   * IngestedEvent updateMany
   */
  export type IngestedEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngestedEvents.
     */
    data: XOR<IngestedEventUpdateManyMutationInput, IngestedEventUncheckedUpdateManyInput>
    /**
     * Filter which IngestedEvents to update
     */
    where?: IngestedEventWhereInput
    /**
     * Limit how many IngestedEvents to update.
     */
    limit?: number
  }

  /**
   * IngestedEvent updateManyAndReturn
   */
  export type IngestedEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * The data used to update IngestedEvents.
     */
    data: XOR<IngestedEventUpdateManyMutationInput, IngestedEventUncheckedUpdateManyInput>
    /**
     * Filter which IngestedEvents to update
     */
    where?: IngestedEventWhereInput
    /**
     * Limit how many IngestedEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestedEvent upsert
   */
  export type IngestedEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * The filter to search for the IngestedEvent to update in case it exists.
     */
    where: IngestedEventWhereUniqueInput
    /**
     * In case the IngestedEvent found by the `where` argument doesn't exist, create a new IngestedEvent with this data.
     */
    create: XOR<IngestedEventCreateInput, IngestedEventUncheckedCreateInput>
    /**
     * In case the IngestedEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestedEventUpdateInput, IngestedEventUncheckedUpdateInput>
  }

  /**
   * IngestedEvent delete
   */
  export type IngestedEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
    /**
     * Filter which IngestedEvent to delete.
     */
    where: IngestedEventWhereUniqueInput
  }

  /**
   * IngestedEvent deleteMany
   */
  export type IngestedEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestedEvents to delete
     */
    where?: IngestedEventWhereInput
    /**
     * Limit how many IngestedEvents to delete.
     */
    limit?: number
  }

  /**
   * IngestedEvent without action
   */
  export type IngestedEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestedEvent
     */
    select?: IngestedEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestedEvent
     */
    omit?: IngestedEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestedEventInclude<ExtArgs> | null
  }


  /**
   * Model IngestionQueueJob
   */

  export type AggregateIngestionQueueJob = {
    _count: IngestionQueueJobCountAggregateOutputType | null
    _avg: IngestionQueueJobAvgAggregateOutputType | null
    _sum: IngestionQueueJobSumAggregateOutputType | null
    _min: IngestionQueueJobMinAggregateOutputType | null
    _max: IngestionQueueJobMaxAggregateOutputType | null
  }

  export type IngestionQueueJobAvgAggregateOutputType = {
    attemptCount: number | null
  }

  export type IngestionQueueJobSumAggregateOutputType = {
    attemptCount: number | null
  }

  export type IngestionQueueJobMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    eventKey: string | null
    occurredAt: Date | null
    payloadJson: string | null
    status: string | null
    attemptCount: number | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    nextAttemptAt: Date | null
    deadLetteredAt: Date | null
  }

  export type IngestionQueueJobMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    eventKey: string | null
    occurredAt: Date | null
    payloadJson: string | null
    status: string | null
    attemptCount: number | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    nextAttemptAt: Date | null
    deadLetteredAt: Date | null
  }

  export type IngestionQueueJobCountAggregateOutputType = {
    id: number
    tenantId: number
    eventType: number
    eventKey: number
    occurredAt: number
    payloadJson: number
    status: number
    attemptCount: number
    lastError: number
    createdAt: number
    updatedAt: number
    processedAt: number
    nextAttemptAt: number
    deadLetteredAt: number
    _all: number
  }


  export type IngestionQueueJobAvgAggregateInputType = {
    attemptCount?: true
  }

  export type IngestionQueueJobSumAggregateInputType = {
    attemptCount?: true
  }

  export type IngestionQueueJobMinAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    status?: true
    attemptCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    nextAttemptAt?: true
    deadLetteredAt?: true
  }

  export type IngestionQueueJobMaxAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    status?: true
    attemptCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    nextAttemptAt?: true
    deadLetteredAt?: true
  }

  export type IngestionQueueJobCountAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    eventKey?: true
    occurredAt?: true
    payloadJson?: true
    status?: true
    attemptCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    nextAttemptAt?: true
    deadLetteredAt?: true
    _all?: true
  }

  export type IngestionQueueJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionQueueJob to aggregate.
     */
    where?: IngestionQueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionQueueJobs to fetch.
     */
    orderBy?: IngestionQueueJobOrderByWithRelationInput | IngestionQueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngestionQueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionQueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionQueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngestionQueueJobs
    **/
    _count?: true | IngestionQueueJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngestionQueueJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngestionQueueJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngestionQueueJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngestionQueueJobMaxAggregateInputType
  }

  export type GetIngestionQueueJobAggregateType<T extends IngestionQueueJobAggregateArgs> = {
        [P in keyof T & keyof AggregateIngestionQueueJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestionQueueJob[P]>
      : GetScalarType<T[P], AggregateIngestionQueueJob[P]>
  }




  export type IngestionQueueJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionQueueJobWhereInput
    orderBy?: IngestionQueueJobOrderByWithAggregationInput | IngestionQueueJobOrderByWithAggregationInput[]
    by: IngestionQueueJobScalarFieldEnum[] | IngestionQueueJobScalarFieldEnum
    having?: IngestionQueueJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestionQueueJobCountAggregateInputType | true
    _avg?: IngestionQueueJobAvgAggregateInputType
    _sum?: IngestionQueueJobSumAggregateInputType
    _min?: IngestionQueueJobMinAggregateInputType
    _max?: IngestionQueueJobMaxAggregateInputType
  }

  export type IngestionQueueJobGroupByOutputType = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date
    payloadJson: string
    status: string
    attemptCount: number
    lastError: string | null
    createdAt: Date
    updatedAt: Date
    processedAt: Date | null
    nextAttemptAt: Date
    deadLetteredAt: Date | null
    _count: IngestionQueueJobCountAggregateOutputType | null
    _avg: IngestionQueueJobAvgAggregateOutputType | null
    _sum: IngestionQueueJobSumAggregateOutputType | null
    _min: IngestionQueueJobMinAggregateOutputType | null
    _max: IngestionQueueJobMaxAggregateOutputType | null
  }

  type GetIngestionQueueJobGroupByPayload<T extends IngestionQueueJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestionQueueJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngestionQueueJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestionQueueJobGroupByOutputType[P]>
            : GetScalarType<T[P], IngestionQueueJobGroupByOutputType[P]>
        }
      >
    >


  export type IngestionQueueJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    status?: boolean
    attemptCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    nextAttemptAt?: boolean
    deadLetteredAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionQueueJob"]>

  export type IngestionQueueJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    status?: boolean
    attemptCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    nextAttemptAt?: boolean
    deadLetteredAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionQueueJob"]>

  export type IngestionQueueJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    status?: boolean
    attemptCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    nextAttemptAt?: boolean
    deadLetteredAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionQueueJob"]>

  export type IngestionQueueJobSelectScalar = {
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    eventKey?: boolean
    occurredAt?: boolean
    payloadJson?: boolean
    status?: boolean
    attemptCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    nextAttemptAt?: boolean
    deadLetteredAt?: boolean
  }

  export type IngestionQueueJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "eventType" | "eventKey" | "occurredAt" | "payloadJson" | "status" | "attemptCount" | "lastError" | "createdAt" | "updatedAt" | "processedAt" | "nextAttemptAt" | "deadLetteredAt", ExtArgs["result"]["ingestionQueueJob"]>
  export type IngestionQueueJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IngestionQueueJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IngestionQueueJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $IngestionQueueJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngestionQueueJob"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      eventType: string
      eventKey: string
      occurredAt: Date
      payloadJson: string
      status: string
      attemptCount: number
      lastError: string | null
      createdAt: Date
      updatedAt: Date
      processedAt: Date | null
      nextAttemptAt: Date
      deadLetteredAt: Date | null
    }, ExtArgs["result"]["ingestionQueueJob"]>
    composites: {}
  }

  type IngestionQueueJobGetPayload<S extends boolean | null | undefined | IngestionQueueJobDefaultArgs> = $Result.GetResult<Prisma.$IngestionQueueJobPayload, S>

  type IngestionQueueJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngestionQueueJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IngestionQueueJobCountAggregateInputType | true
    }

  export interface IngestionQueueJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngestionQueueJob'], meta: { name: 'IngestionQueueJob' } }
    /**
     * Find zero or one IngestionQueueJob that matches the filter.
     * @param {IngestionQueueJobFindUniqueArgs} args - Arguments to find a IngestionQueueJob
     * @example
     * // Get one IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestionQueueJobFindUniqueArgs>(args: SelectSubset<T, IngestionQueueJobFindUniqueArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IngestionQueueJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngestionQueueJobFindUniqueOrThrowArgs} args - Arguments to find a IngestionQueueJob
     * @example
     * // Get one IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestionQueueJobFindUniqueOrThrowArgs>(args: SelectSubset<T, IngestionQueueJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestionQueueJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobFindFirstArgs} args - Arguments to find a IngestionQueueJob
     * @example
     * // Get one IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestionQueueJobFindFirstArgs>(args?: SelectSubset<T, IngestionQueueJobFindFirstArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestionQueueJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobFindFirstOrThrowArgs} args - Arguments to find a IngestionQueueJob
     * @example
     * // Get one IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestionQueueJobFindFirstOrThrowArgs>(args?: SelectSubset<T, IngestionQueueJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IngestionQueueJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestionQueueJobs
     * const ingestionQueueJobs = await prisma.ingestionQueueJob.findMany()
     * 
     * // Get first 10 IngestionQueueJobs
     * const ingestionQueueJobs = await prisma.ingestionQueueJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingestionQueueJobWithIdOnly = await prisma.ingestionQueueJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngestionQueueJobFindManyArgs>(args?: SelectSubset<T, IngestionQueueJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IngestionQueueJob.
     * @param {IngestionQueueJobCreateArgs} args - Arguments to create a IngestionQueueJob.
     * @example
     * // Create one IngestionQueueJob
     * const IngestionQueueJob = await prisma.ingestionQueueJob.create({
     *   data: {
     *     // ... data to create a IngestionQueueJob
     *   }
     * })
     * 
     */
    create<T extends IngestionQueueJobCreateArgs>(args: SelectSubset<T, IngestionQueueJobCreateArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IngestionQueueJobs.
     * @param {IngestionQueueJobCreateManyArgs} args - Arguments to create many IngestionQueueJobs.
     * @example
     * // Create many IngestionQueueJobs
     * const ingestionQueueJob = await prisma.ingestionQueueJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngestionQueueJobCreateManyArgs>(args?: SelectSubset<T, IngestionQueueJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestionQueueJobs and returns the data saved in the database.
     * @param {IngestionQueueJobCreateManyAndReturnArgs} args - Arguments to create many IngestionQueueJobs.
     * @example
     * // Create many IngestionQueueJobs
     * const ingestionQueueJob = await prisma.ingestionQueueJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngestionQueueJobs and only return the `id`
     * const ingestionQueueJobWithIdOnly = await prisma.ingestionQueueJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngestionQueueJobCreateManyAndReturnArgs>(args?: SelectSubset<T, IngestionQueueJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IngestionQueueJob.
     * @param {IngestionQueueJobDeleteArgs} args - Arguments to delete one IngestionQueueJob.
     * @example
     * // Delete one IngestionQueueJob
     * const IngestionQueueJob = await prisma.ingestionQueueJob.delete({
     *   where: {
     *     // ... filter to delete one IngestionQueueJob
     *   }
     * })
     * 
     */
    delete<T extends IngestionQueueJobDeleteArgs>(args: SelectSubset<T, IngestionQueueJobDeleteArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IngestionQueueJob.
     * @param {IngestionQueueJobUpdateArgs} args - Arguments to update one IngestionQueueJob.
     * @example
     * // Update one IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngestionQueueJobUpdateArgs>(args: SelectSubset<T, IngestionQueueJobUpdateArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IngestionQueueJobs.
     * @param {IngestionQueueJobDeleteManyArgs} args - Arguments to filter IngestionQueueJobs to delete.
     * @example
     * // Delete a few IngestionQueueJobs
     * const { count } = await prisma.ingestionQueueJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngestionQueueJobDeleteManyArgs>(args?: SelectSubset<T, IngestionQueueJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestionQueueJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestionQueueJobs
     * const ingestionQueueJob = await prisma.ingestionQueueJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngestionQueueJobUpdateManyArgs>(args: SelectSubset<T, IngestionQueueJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestionQueueJobs and returns the data updated in the database.
     * @param {IngestionQueueJobUpdateManyAndReturnArgs} args - Arguments to update many IngestionQueueJobs.
     * @example
     * // Update many IngestionQueueJobs
     * const ingestionQueueJob = await prisma.ingestionQueueJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IngestionQueueJobs and only return the `id`
     * const ingestionQueueJobWithIdOnly = await prisma.ingestionQueueJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IngestionQueueJobUpdateManyAndReturnArgs>(args: SelectSubset<T, IngestionQueueJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IngestionQueueJob.
     * @param {IngestionQueueJobUpsertArgs} args - Arguments to update or create a IngestionQueueJob.
     * @example
     * // Update or create a IngestionQueueJob
     * const ingestionQueueJob = await prisma.ingestionQueueJob.upsert({
     *   create: {
     *     // ... data to create a IngestionQueueJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestionQueueJob we want to update
     *   }
     * })
     */
    upsert<T extends IngestionQueueJobUpsertArgs>(args: SelectSubset<T, IngestionQueueJobUpsertArgs<ExtArgs>>): Prisma__IngestionQueueJobClient<$Result.GetResult<Prisma.$IngestionQueueJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IngestionQueueJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobCountArgs} args - Arguments to filter IngestionQueueJobs to count.
     * @example
     * // Count the number of IngestionQueueJobs
     * const count = await prisma.ingestionQueueJob.count({
     *   where: {
     *     // ... the filter for the IngestionQueueJobs we want to count
     *   }
     * })
    **/
    count<T extends IngestionQueueJobCountArgs>(
      args?: Subset<T, IngestionQueueJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestionQueueJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestionQueueJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngestionQueueJobAggregateArgs>(args: Subset<T, IngestionQueueJobAggregateArgs>): Prisma.PrismaPromise<GetIngestionQueueJobAggregateType<T>>

    /**
     * Group by IngestionQueueJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionQueueJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngestionQueueJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestionQueueJobGroupByArgs['orderBy'] }
        : { orderBy?: IngestionQueueJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngestionQueueJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngestionQueueJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngestionQueueJob model
   */
  readonly fields: IngestionQueueJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestionQueueJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestionQueueJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngestionQueueJob model
   */
  interface IngestionQueueJobFieldRefs {
    readonly id: FieldRef<"IngestionQueueJob", 'String'>
    readonly tenantId: FieldRef<"IngestionQueueJob", 'String'>
    readonly eventType: FieldRef<"IngestionQueueJob", 'String'>
    readonly eventKey: FieldRef<"IngestionQueueJob", 'String'>
    readonly occurredAt: FieldRef<"IngestionQueueJob", 'DateTime'>
    readonly payloadJson: FieldRef<"IngestionQueueJob", 'String'>
    readonly status: FieldRef<"IngestionQueueJob", 'String'>
    readonly attemptCount: FieldRef<"IngestionQueueJob", 'Int'>
    readonly lastError: FieldRef<"IngestionQueueJob", 'String'>
    readonly createdAt: FieldRef<"IngestionQueueJob", 'DateTime'>
    readonly updatedAt: FieldRef<"IngestionQueueJob", 'DateTime'>
    readonly processedAt: FieldRef<"IngestionQueueJob", 'DateTime'>
    readonly nextAttemptAt: FieldRef<"IngestionQueueJob", 'DateTime'>
    readonly deadLetteredAt: FieldRef<"IngestionQueueJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IngestionQueueJob findUnique
   */
  export type IngestionQueueJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionQueueJob to fetch.
     */
    where: IngestionQueueJobWhereUniqueInput
  }

  /**
   * IngestionQueueJob findUniqueOrThrow
   */
  export type IngestionQueueJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionQueueJob to fetch.
     */
    where: IngestionQueueJobWhereUniqueInput
  }

  /**
   * IngestionQueueJob findFirst
   */
  export type IngestionQueueJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionQueueJob to fetch.
     */
    where?: IngestionQueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionQueueJobs to fetch.
     */
    orderBy?: IngestionQueueJobOrderByWithRelationInput | IngestionQueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionQueueJobs.
     */
    cursor?: IngestionQueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionQueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionQueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionQueueJobs.
     */
    distinct?: IngestionQueueJobScalarFieldEnum | IngestionQueueJobScalarFieldEnum[]
  }

  /**
   * IngestionQueueJob findFirstOrThrow
   */
  export type IngestionQueueJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionQueueJob to fetch.
     */
    where?: IngestionQueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionQueueJobs to fetch.
     */
    orderBy?: IngestionQueueJobOrderByWithRelationInput | IngestionQueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionQueueJobs.
     */
    cursor?: IngestionQueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionQueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionQueueJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionQueueJobs.
     */
    distinct?: IngestionQueueJobScalarFieldEnum | IngestionQueueJobScalarFieldEnum[]
  }

  /**
   * IngestionQueueJob findMany
   */
  export type IngestionQueueJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionQueueJobs to fetch.
     */
    where?: IngestionQueueJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionQueueJobs to fetch.
     */
    orderBy?: IngestionQueueJobOrderByWithRelationInput | IngestionQueueJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngestionQueueJobs.
     */
    cursor?: IngestionQueueJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionQueueJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionQueueJobs.
     */
    skip?: number
    distinct?: IngestionQueueJobScalarFieldEnum | IngestionQueueJobScalarFieldEnum[]
  }

  /**
   * IngestionQueueJob create
   */
  export type IngestionQueueJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * The data needed to create a IngestionQueueJob.
     */
    data: XOR<IngestionQueueJobCreateInput, IngestionQueueJobUncheckedCreateInput>
  }

  /**
   * IngestionQueueJob createMany
   */
  export type IngestionQueueJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngestionQueueJobs.
     */
    data: IngestionQueueJobCreateManyInput | IngestionQueueJobCreateManyInput[]
  }

  /**
   * IngestionQueueJob createManyAndReturn
   */
  export type IngestionQueueJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * The data used to create many IngestionQueueJobs.
     */
    data: IngestionQueueJobCreateManyInput | IngestionQueueJobCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestionQueueJob update
   */
  export type IngestionQueueJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * The data needed to update a IngestionQueueJob.
     */
    data: XOR<IngestionQueueJobUpdateInput, IngestionQueueJobUncheckedUpdateInput>
    /**
     * Choose, which IngestionQueueJob to update.
     */
    where: IngestionQueueJobWhereUniqueInput
  }

  /**
   * IngestionQueueJob updateMany
   */
  export type IngestionQueueJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngestionQueueJobs.
     */
    data: XOR<IngestionQueueJobUpdateManyMutationInput, IngestionQueueJobUncheckedUpdateManyInput>
    /**
     * Filter which IngestionQueueJobs to update
     */
    where?: IngestionQueueJobWhereInput
    /**
     * Limit how many IngestionQueueJobs to update.
     */
    limit?: number
  }

  /**
   * IngestionQueueJob updateManyAndReturn
   */
  export type IngestionQueueJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * The data used to update IngestionQueueJobs.
     */
    data: XOR<IngestionQueueJobUpdateManyMutationInput, IngestionQueueJobUncheckedUpdateManyInput>
    /**
     * Filter which IngestionQueueJobs to update
     */
    where?: IngestionQueueJobWhereInput
    /**
     * Limit how many IngestionQueueJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestionQueueJob upsert
   */
  export type IngestionQueueJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * The filter to search for the IngestionQueueJob to update in case it exists.
     */
    where: IngestionQueueJobWhereUniqueInput
    /**
     * In case the IngestionQueueJob found by the `where` argument doesn't exist, create a new IngestionQueueJob with this data.
     */
    create: XOR<IngestionQueueJobCreateInput, IngestionQueueJobUncheckedCreateInput>
    /**
     * In case the IngestionQueueJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestionQueueJobUpdateInput, IngestionQueueJobUncheckedUpdateInput>
  }

  /**
   * IngestionQueueJob delete
   */
  export type IngestionQueueJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
    /**
     * Filter which IngestionQueueJob to delete.
     */
    where: IngestionQueueJobWhereUniqueInput
  }

  /**
   * IngestionQueueJob deleteMany
   */
  export type IngestionQueueJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionQueueJobs to delete
     */
    where?: IngestionQueueJobWhereInput
    /**
     * Limit how many IngestionQueueJobs to delete.
     */
    limit?: number
  }

  /**
   * IngestionQueueJob without action
   */
  export type IngestionQueueJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionQueueJob
     */
    select?: IngestionQueueJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionQueueJob
     */
    omit?: IngestionQueueJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionQueueJobInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditEvent
   */

  export type AggregateAdminAuditEvent = {
    _count: AdminAuditEventCountAggregateOutputType | null
    _min: AdminAuditEventMinAggregateOutputType | null
    _max: AdminAuditEventMaxAggregateOutputType | null
  }

  export type AdminAuditEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    domainId: string | null
    action: string | null
    status: string | null
    actorId: string | null
    actorRole: string | null
    error: string | null
    metadataJson: string | null
    createdAt: Date | null
  }

  export type AdminAuditEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    domainId: string | null
    action: string | null
    status: string | null
    actorId: string | null
    actorRole: string | null
    error: string | null
    metadataJson: string | null
    createdAt: Date | null
  }

  export type AdminAuditEventCountAggregateOutputType = {
    id: number
    tenantId: number
    domainId: number
    action: number
    status: number
    actorId: number
    actorRole: number
    error: number
    metadataJson: number
    createdAt: number
    _all: number
  }


  export type AdminAuditEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    domainId?: true
    action?: true
    status?: true
    actorId?: true
    actorRole?: true
    error?: true
    metadataJson?: true
    createdAt?: true
  }

  export type AdminAuditEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    domainId?: true
    action?: true
    status?: true
    actorId?: true
    actorRole?: true
    error?: true
    metadataJson?: true
    createdAt?: true
  }

  export type AdminAuditEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    domainId?: true
    action?: true
    status?: true
    actorId?: true
    actorRole?: true
    error?: true
    metadataJson?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditEvent to aggregate.
     */
    where?: AdminAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditEvents to fetch.
     */
    orderBy?: AdminAuditEventOrderByWithRelationInput | AdminAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditEvents
    **/
    _count?: true | AdminAuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditEventMaxAggregateInputType
  }

  export type GetAdminAuditEventAggregateType<T extends AdminAuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditEvent[P]>
      : GetScalarType<T[P], AggregateAdminAuditEvent[P]>
  }




  export type AdminAuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditEventWhereInput
    orderBy?: AdminAuditEventOrderByWithAggregationInput | AdminAuditEventOrderByWithAggregationInput[]
    by: AdminAuditEventScalarFieldEnum[] | AdminAuditEventScalarFieldEnum
    having?: AdminAuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditEventCountAggregateInputType | true
    _min?: AdminAuditEventMinAggregateInputType
    _max?: AdminAuditEventMaxAggregateInputType
  }

  export type AdminAuditEventGroupByOutputType = {
    id: string
    tenantId: string | null
    domainId: string | null
    action: string
    status: string
    actorId: string | null
    actorRole: string
    error: string | null
    metadataJson: string | null
    createdAt: Date
    _count: AdminAuditEventCountAggregateOutputType | null
    _min: AdminAuditEventMinAggregateOutputType | null
    _max: AdminAuditEventMaxAggregateOutputType | null
  }

  type GetAdminAuditEventGroupByPayload<T extends AdminAuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domainId?: boolean
    action?: boolean
    status?: boolean
    actorId?: boolean
    actorRole?: boolean
    error?: boolean
    metadataJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAuditEvent"]>

  export type AdminAuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domainId?: boolean
    action?: boolean
    status?: boolean
    actorId?: boolean
    actorRole?: boolean
    error?: boolean
    metadataJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAuditEvent"]>

  export type AdminAuditEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    domainId?: boolean
    action?: boolean
    status?: boolean
    actorId?: boolean
    actorRole?: boolean
    error?: boolean
    metadataJson?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["adminAuditEvent"]>

  export type AdminAuditEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    domainId?: boolean
    action?: boolean
    status?: boolean
    actorId?: boolean
    actorRole?: boolean
    error?: boolean
    metadataJson?: boolean
    createdAt?: boolean
  }

  export type AdminAuditEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "domainId" | "action" | "status" | "actorId" | "actorRole" | "error" | "metadataJson" | "createdAt", ExtArgs["result"]["adminAuditEvent"]>

  export type $AdminAuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      domainId: string | null
      action: string
      status: string
      actorId: string | null
      actorRole: string
      error: string | null
      metadataJson: string | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditEvent"]>
    composites: {}
  }

  type AdminAuditEventGetPayload<S extends boolean | null | undefined | AdminAuditEventDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditEventPayload, S>

  type AdminAuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditEventCountAggregateInputType | true
    }

  export interface AdminAuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditEvent'], meta: { name: 'AdminAuditEvent' } }
    /**
     * Find zero or one AdminAuditEvent that matches the filter.
     * @param {AdminAuditEventFindUniqueArgs} args - Arguments to find a AdminAuditEvent
     * @example
     * // Get one AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditEventFindUniqueArgs>(args: SelectSubset<T, AdminAuditEventFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuditEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditEventFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditEvent
     * @example
     * // Get one AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventFindFirstArgs} args - Arguments to find a AdminAuditEvent
     * @example
     * // Get one AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditEventFindFirstArgs>(args?: SelectSubset<T, AdminAuditEventFindFirstArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventFindFirstOrThrowArgs} args - Arguments to find a AdminAuditEvent
     * @example
     * // Get one AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditEvents
     * const adminAuditEvents = await prisma.adminAuditEvent.findMany()
     * 
     * // Get first 10 AdminAuditEvents
     * const adminAuditEvents = await prisma.adminAuditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditEventWithIdOnly = await prisma.adminAuditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditEventFindManyArgs>(args?: SelectSubset<T, AdminAuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuditEvent.
     * @param {AdminAuditEventCreateArgs} args - Arguments to create a AdminAuditEvent.
     * @example
     * // Create one AdminAuditEvent
     * const AdminAuditEvent = await prisma.adminAuditEvent.create({
     *   data: {
     *     // ... data to create a AdminAuditEvent
     *   }
     * })
     * 
     */
    create<T extends AdminAuditEventCreateArgs>(args: SelectSubset<T, AdminAuditEventCreateArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuditEvents.
     * @param {AdminAuditEventCreateManyArgs} args - Arguments to create many AdminAuditEvents.
     * @example
     * // Create many AdminAuditEvents
     * const adminAuditEvent = await prisma.adminAuditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditEventCreateManyArgs>(args?: SelectSubset<T, AdminAuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditEvents and returns the data saved in the database.
     * @param {AdminAuditEventCreateManyAndReturnArgs} args - Arguments to create many AdminAuditEvents.
     * @example
     * // Create many AdminAuditEvents
     * const adminAuditEvent = await prisma.adminAuditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditEvents and only return the `id`
     * const adminAuditEventWithIdOnly = await prisma.adminAuditEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuditEvent.
     * @param {AdminAuditEventDeleteArgs} args - Arguments to delete one AdminAuditEvent.
     * @example
     * // Delete one AdminAuditEvent
     * const AdminAuditEvent = await prisma.adminAuditEvent.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditEventDeleteArgs>(args: SelectSubset<T, AdminAuditEventDeleteArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuditEvent.
     * @param {AdminAuditEventUpdateArgs} args - Arguments to update one AdminAuditEvent.
     * @example
     * // Update one AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditEventUpdateArgs>(args: SelectSubset<T, AdminAuditEventUpdateArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuditEvents.
     * @param {AdminAuditEventDeleteManyArgs} args - Arguments to filter AdminAuditEvents to delete.
     * @example
     * // Delete a few AdminAuditEvents
     * const { count } = await prisma.adminAuditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditEventDeleteManyArgs>(args?: SelectSubset<T, AdminAuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditEvents
     * const adminAuditEvent = await prisma.adminAuditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditEventUpdateManyArgs>(args: SelectSubset<T, AdminAuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditEvents and returns the data updated in the database.
     * @param {AdminAuditEventUpdateManyAndReturnArgs} args - Arguments to update many AdminAuditEvents.
     * @example
     * // Update many AdminAuditEvents
     * const adminAuditEvent = await prisma.adminAuditEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuditEvents and only return the `id`
     * const adminAuditEventWithIdOnly = await prisma.adminAuditEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuditEvent.
     * @param {AdminAuditEventUpsertArgs} args - Arguments to update or create a AdminAuditEvent.
     * @example
     * // Update or create a AdminAuditEvent
     * const adminAuditEvent = await prisma.adminAuditEvent.upsert({
     *   create: {
     *     // ... data to create a AdminAuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditEventUpsertArgs>(args: SelectSubset<T, AdminAuditEventUpsertArgs<ExtArgs>>): Prisma__AdminAuditEventClient<$Result.GetResult<Prisma.$AdminAuditEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventCountArgs} args - Arguments to filter AdminAuditEvents to count.
     * @example
     * // Count the number of AdminAuditEvents
     * const count = await prisma.adminAuditEvent.count({
     *   where: {
     *     // ... the filter for the AdminAuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditEventCountArgs>(
      args?: Subset<T, AdminAuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditEventAggregateArgs>(args: Subset<T, AdminAuditEventAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditEventAggregateType<T>>

    /**
     * Group by AdminAuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditEvent model
   */
  readonly fields: AdminAuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditEvent model
   */
  interface AdminAuditEventFieldRefs {
    readonly id: FieldRef<"AdminAuditEvent", 'String'>
    readonly tenantId: FieldRef<"AdminAuditEvent", 'String'>
    readonly domainId: FieldRef<"AdminAuditEvent", 'String'>
    readonly action: FieldRef<"AdminAuditEvent", 'String'>
    readonly status: FieldRef<"AdminAuditEvent", 'String'>
    readonly actorId: FieldRef<"AdminAuditEvent", 'String'>
    readonly actorRole: FieldRef<"AdminAuditEvent", 'String'>
    readonly error: FieldRef<"AdminAuditEvent", 'String'>
    readonly metadataJson: FieldRef<"AdminAuditEvent", 'String'>
    readonly createdAt: FieldRef<"AdminAuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditEvent findUnique
   */
  export type AdminAuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminAuditEvent to fetch.
     */
    where: AdminAuditEventWhereUniqueInput
  }

  /**
   * AdminAuditEvent findUniqueOrThrow
   */
  export type AdminAuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminAuditEvent to fetch.
     */
    where: AdminAuditEventWhereUniqueInput
  }

  /**
   * AdminAuditEvent findFirst
   */
  export type AdminAuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminAuditEvent to fetch.
     */
    where?: AdminAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditEvents to fetch.
     */
    orderBy?: AdminAuditEventOrderByWithRelationInput | AdminAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditEvents.
     */
    cursor?: AdminAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditEvents.
     */
    distinct?: AdminAuditEventScalarFieldEnum | AdminAuditEventScalarFieldEnum[]
  }

  /**
   * AdminAuditEvent findFirstOrThrow
   */
  export type AdminAuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminAuditEvent to fetch.
     */
    where?: AdminAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditEvents to fetch.
     */
    orderBy?: AdminAuditEventOrderByWithRelationInput | AdminAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditEvents.
     */
    cursor?: AdminAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditEvents.
     */
    distinct?: AdminAuditEventScalarFieldEnum | AdminAuditEventScalarFieldEnum[]
  }

  /**
   * AdminAuditEvent findMany
   */
  export type AdminAuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminAuditEvents to fetch.
     */
    where?: AdminAuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditEvents to fetch.
     */
    orderBy?: AdminAuditEventOrderByWithRelationInput | AdminAuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditEvents.
     */
    cursor?: AdminAuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditEvents.
     */
    skip?: number
    distinct?: AdminAuditEventScalarFieldEnum | AdminAuditEventScalarFieldEnum[]
  }

  /**
   * AdminAuditEvent create
   */
  export type AdminAuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditEvent.
     */
    data: XOR<AdminAuditEventCreateInput, AdminAuditEventUncheckedCreateInput>
  }

  /**
   * AdminAuditEvent createMany
   */
  export type AdminAuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditEvents.
     */
    data: AdminAuditEventCreateManyInput | AdminAuditEventCreateManyInput[]
  }

  /**
   * AdminAuditEvent createManyAndReturn
   */
  export type AdminAuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuditEvents.
     */
    data: AdminAuditEventCreateManyInput | AdminAuditEventCreateManyInput[]
  }

  /**
   * AdminAuditEvent update
   */
  export type AdminAuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditEvent.
     */
    data: XOR<AdminAuditEventUpdateInput, AdminAuditEventUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditEvent to update.
     */
    where: AdminAuditEventWhereUniqueInput
  }

  /**
   * AdminAuditEvent updateMany
   */
  export type AdminAuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditEvents.
     */
    data: XOR<AdminAuditEventUpdateManyMutationInput, AdminAuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditEvents to update
     */
    where?: AdminAuditEventWhereInput
    /**
     * Limit how many AdminAuditEvents to update.
     */
    limit?: number
  }

  /**
   * AdminAuditEvent updateManyAndReturn
   */
  export type AdminAuditEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuditEvents.
     */
    data: XOR<AdminAuditEventUpdateManyMutationInput, AdminAuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditEvents to update
     */
    where?: AdminAuditEventWhereInput
    /**
     * Limit how many AdminAuditEvents to update.
     */
    limit?: number
  }

  /**
   * AdminAuditEvent upsert
   */
  export type AdminAuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditEvent to update in case it exists.
     */
    where: AdminAuditEventWhereUniqueInput
    /**
     * In case the AdminAuditEvent found by the `where` argument doesn't exist, create a new AdminAuditEvent with this data.
     */
    create: XOR<AdminAuditEventCreateInput, AdminAuditEventUncheckedCreateInput>
    /**
     * In case the AdminAuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditEventUpdateInput, AdminAuditEventUncheckedUpdateInput>
  }

  /**
   * AdminAuditEvent delete
   */
  export type AdminAuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
    /**
     * Filter which AdminAuditEvent to delete.
     */
    where: AdminAuditEventWhereUniqueInput
  }

  /**
   * AdminAuditEvent deleteMany
   */
  export type AdminAuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditEvents to delete
     */
    where?: AdminAuditEventWhereInput
    /**
     * Limit how many AdminAuditEvents to delete.
     */
    limit?: number
  }

  /**
   * AdminAuditEvent without action
   */
  export type AdminAuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditEvent
     */
    select?: AdminAuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditEvent
     */
    omit?: AdminAuditEventOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    salePrice: number | null
    listPrice: number | null
  }

  export type TransactionSumAggregateOutputType = {
    salePrice: number | null
    listPrice: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    contactId: string | null
    propertyAddress: string | null
    status: string | null
    side: string | null
    salePrice: number | null
    listPrice: number | null
    closingDate: Date | null
    contractDate: Date | null
    inspectionDate: Date | null
    appraisalDate: Date | null
    titleDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    leadId: string | null
    contactId: string | null
    propertyAddress: string | null
    status: string | null
    side: string | null
    salePrice: number | null
    listPrice: number | null
    closingDate: Date | null
    contractDate: Date | null
    inspectionDate: Date | null
    appraisalDate: Date | null
    titleDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    leadId: number
    contactId: number
    propertyAddress: number
    status: number
    side: number
    salePrice: number
    listPrice: number
    closingDate: number
    contractDate: number
    inspectionDate: number
    appraisalDate: number
    titleDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    salePrice?: true
    listPrice?: true
  }

  export type TransactionSumAggregateInputType = {
    salePrice?: true
    listPrice?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    contactId?: true
    propertyAddress?: true
    status?: true
    side?: true
    salePrice?: true
    listPrice?: true
    closingDate?: true
    contractDate?: true
    inspectionDate?: true
    appraisalDate?: true
    titleDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    contactId?: true
    propertyAddress?: true
    status?: true
    side?: true
    salePrice?: true
    listPrice?: true
    closingDate?: true
    contractDate?: true
    inspectionDate?: true
    appraisalDate?: true
    titleDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    leadId?: true
    contactId?: true
    propertyAddress?: true
    status?: true
    side?: true
    salePrice?: true
    listPrice?: true
    closingDate?: true
    contractDate?: true
    inspectionDate?: true
    appraisalDate?: true
    titleDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    tenantId: string
    leadId: string | null
    contactId: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice: number | null
    listPrice: number | null
    closingDate: Date | null
    contractDate: Date | null
    inspectionDate: Date | null
    appraisalDate: Date | null
    titleDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    contactId?: boolean
    propertyAddress?: boolean
    status?: boolean
    side?: boolean
    salePrice?: boolean
    listPrice?: boolean
    closingDate?: boolean
    contractDate?: boolean
    inspectionDate?: boolean
    appraisalDate?: boolean
    titleDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parties?: boolean | Transaction$partiesArgs<ExtArgs>
    documents?: boolean | Transaction$documentsArgs<ExtArgs>
    milestones?: boolean | Transaction$milestonesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    contactId?: boolean
    propertyAddress?: boolean
    status?: boolean
    side?: boolean
    salePrice?: boolean
    listPrice?: boolean
    closingDate?: boolean
    contractDate?: boolean
    inspectionDate?: boolean
    appraisalDate?: boolean
    titleDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    contactId?: boolean
    propertyAddress?: boolean
    status?: boolean
    side?: boolean
    salePrice?: boolean
    listPrice?: boolean
    closingDate?: boolean
    contractDate?: boolean
    inspectionDate?: boolean
    appraisalDate?: boolean
    titleDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    leadId?: boolean
    contactId?: boolean
    propertyAddress?: boolean
    status?: boolean
    side?: boolean
    salePrice?: boolean
    listPrice?: boolean
    closingDate?: boolean
    contractDate?: boolean
    inspectionDate?: boolean
    appraisalDate?: boolean
    titleDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "leadId" | "contactId" | "propertyAddress" | "status" | "side" | "salePrice" | "listPrice" | "closingDate" | "contractDate" | "inspectionDate" | "appraisalDate" | "titleDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    parties?: boolean | Transaction$partiesArgs<ExtArgs>
    documents?: boolean | Transaction$documentsArgs<ExtArgs>
    milestones?: boolean | Transaction$milestonesArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      parties: Prisma.$TransactionPartyPayload<ExtArgs>[]
      documents: Prisma.$TransactionDocumentPayload<ExtArgs>[]
      milestones: Prisma.$TransactionMilestonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      leadId: string | null
      contactId: string | null
      propertyAddress: string
      status: string
      side: string
      salePrice: number | null
      listPrice: number | null
      closingDate: Date | null
      contractDate: Date | null
      inspectionDate: Date | null
      appraisalDate: Date | null
      titleDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parties<T extends Transaction$partiesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$partiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Transaction$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Transaction$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly leadId: FieldRef<"Transaction", 'String'>
    readonly contactId: FieldRef<"Transaction", 'String'>
    readonly propertyAddress: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly side: FieldRef<"Transaction", 'String'>
    readonly salePrice: FieldRef<"Transaction", 'Int'>
    readonly listPrice: FieldRef<"Transaction", 'Int'>
    readonly closingDate: FieldRef<"Transaction", 'DateTime'>
    readonly contractDate: FieldRef<"Transaction", 'DateTime'>
    readonly inspectionDate: FieldRef<"Transaction", 'DateTime'>
    readonly appraisalDate: FieldRef<"Transaction", 'DateTime'>
    readonly titleDate: FieldRef<"Transaction", 'DateTime'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.parties
   */
  export type Transaction$partiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    where?: TransactionPartyWhereInput
    orderBy?: TransactionPartyOrderByWithRelationInput | TransactionPartyOrderByWithRelationInput[]
    cursor?: TransactionPartyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionPartyScalarFieldEnum | TransactionPartyScalarFieldEnum[]
  }

  /**
   * Transaction.documents
   */
  export type Transaction$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    where?: TransactionDocumentWhereInput
    orderBy?: TransactionDocumentOrderByWithRelationInput | TransactionDocumentOrderByWithRelationInput[]
    cursor?: TransactionDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionDocumentScalarFieldEnum | TransactionDocumentScalarFieldEnum[]
  }

  /**
   * Transaction.milestones
   */
  export type Transaction$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    where?: TransactionMilestoneWhereInput
    orderBy?: TransactionMilestoneOrderByWithRelationInput | TransactionMilestoneOrderByWithRelationInput[]
    cursor?: TransactionMilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionMilestoneScalarFieldEnum | TransactionMilestoneScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionParty
   */

  export type AggregateTransactionParty = {
    _count: TransactionPartyCountAggregateOutputType | null
    _min: TransactionPartyMinAggregateOutputType | null
    _max: TransactionPartyMaxAggregateOutputType | null
  }

  export type TransactionPartyMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    role: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionPartyMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    role: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionPartyCountAggregateOutputType = {
    id: number
    transactionId: number
    tenantId: number
    role: number
    name: number
    email: number
    phone: number
    company: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionPartyMinAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    role?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionPartyMaxAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    role?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionPartyCountAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    role?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionPartyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionParty to aggregate.
     */
    where?: TransactionPartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionParties to fetch.
     */
    orderBy?: TransactionPartyOrderByWithRelationInput | TransactionPartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionPartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionParties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionParties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionParties
    **/
    _count?: true | TransactionPartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionPartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionPartyMaxAggregateInputType
  }

  export type GetTransactionPartyAggregateType<T extends TransactionPartyAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionParty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionParty[P]>
      : GetScalarType<T[P], AggregateTransactionParty[P]>
  }




  export type TransactionPartyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionPartyWhereInput
    orderBy?: TransactionPartyOrderByWithAggregationInput | TransactionPartyOrderByWithAggregationInput[]
    by: TransactionPartyScalarFieldEnum[] | TransactionPartyScalarFieldEnum
    having?: TransactionPartyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionPartyCountAggregateInputType | true
    _min?: TransactionPartyMinAggregateInputType
    _max?: TransactionPartyMaxAggregateInputType
  }

  export type TransactionPartyGroupByOutputType = {
    id: string
    transactionId: string
    tenantId: string
    role: string
    name: string
    email: string | null
    phone: string | null
    company: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionPartyCountAggregateOutputType | null
    _min: TransactionPartyMinAggregateOutputType | null
    _max: TransactionPartyMaxAggregateOutputType | null
  }

  type GetTransactionPartyGroupByPayload<T extends TransactionPartyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionPartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionPartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionPartyGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionPartyGroupByOutputType[P]>
        }
      >
    >


  export type TransactionPartySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionParty"]>

  export type TransactionPartySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionParty"]>

  export type TransactionPartySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionParty"]>

  export type TransactionPartySelectScalar = {
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    role?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionPartyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "tenantId" | "role" | "name" | "email" | "phone" | "company" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionParty"]>
  export type TransactionPartyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionPartyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionPartyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionPartyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionParty"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      tenantId: string
      role: string
      name: string
      email: string | null
      phone: string | null
      company: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionParty"]>
    composites: {}
  }

  type TransactionPartyGetPayload<S extends boolean | null | undefined | TransactionPartyDefaultArgs> = $Result.GetResult<Prisma.$TransactionPartyPayload, S>

  type TransactionPartyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionPartyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionPartyCountAggregateInputType | true
    }

  export interface TransactionPartyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionParty'], meta: { name: 'TransactionParty' } }
    /**
     * Find zero or one TransactionParty that matches the filter.
     * @param {TransactionPartyFindUniqueArgs} args - Arguments to find a TransactionParty
     * @example
     * // Get one TransactionParty
     * const transactionParty = await prisma.transactionParty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionPartyFindUniqueArgs>(args: SelectSubset<T, TransactionPartyFindUniqueArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionParty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionPartyFindUniqueOrThrowArgs} args - Arguments to find a TransactionParty
     * @example
     * // Get one TransactionParty
     * const transactionParty = await prisma.transactionParty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionPartyFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionPartyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionParty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyFindFirstArgs} args - Arguments to find a TransactionParty
     * @example
     * // Get one TransactionParty
     * const transactionParty = await prisma.transactionParty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionPartyFindFirstArgs>(args?: SelectSubset<T, TransactionPartyFindFirstArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionParty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyFindFirstOrThrowArgs} args - Arguments to find a TransactionParty
     * @example
     * // Get one TransactionParty
     * const transactionParty = await prisma.transactionParty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionPartyFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionPartyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionParties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionParties
     * const transactionParties = await prisma.transactionParty.findMany()
     * 
     * // Get first 10 TransactionParties
     * const transactionParties = await prisma.transactionParty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionPartyWithIdOnly = await prisma.transactionParty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionPartyFindManyArgs>(args?: SelectSubset<T, TransactionPartyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionParty.
     * @param {TransactionPartyCreateArgs} args - Arguments to create a TransactionParty.
     * @example
     * // Create one TransactionParty
     * const TransactionParty = await prisma.transactionParty.create({
     *   data: {
     *     // ... data to create a TransactionParty
     *   }
     * })
     * 
     */
    create<T extends TransactionPartyCreateArgs>(args: SelectSubset<T, TransactionPartyCreateArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionParties.
     * @param {TransactionPartyCreateManyArgs} args - Arguments to create many TransactionParties.
     * @example
     * // Create many TransactionParties
     * const transactionParty = await prisma.transactionParty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionPartyCreateManyArgs>(args?: SelectSubset<T, TransactionPartyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionParties and returns the data saved in the database.
     * @param {TransactionPartyCreateManyAndReturnArgs} args - Arguments to create many TransactionParties.
     * @example
     * // Create many TransactionParties
     * const transactionParty = await prisma.transactionParty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionParties and only return the `id`
     * const transactionPartyWithIdOnly = await prisma.transactionParty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionPartyCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionPartyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionParty.
     * @param {TransactionPartyDeleteArgs} args - Arguments to delete one TransactionParty.
     * @example
     * // Delete one TransactionParty
     * const TransactionParty = await prisma.transactionParty.delete({
     *   where: {
     *     // ... filter to delete one TransactionParty
     *   }
     * })
     * 
     */
    delete<T extends TransactionPartyDeleteArgs>(args: SelectSubset<T, TransactionPartyDeleteArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionParty.
     * @param {TransactionPartyUpdateArgs} args - Arguments to update one TransactionParty.
     * @example
     * // Update one TransactionParty
     * const transactionParty = await prisma.transactionParty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionPartyUpdateArgs>(args: SelectSubset<T, TransactionPartyUpdateArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionParties.
     * @param {TransactionPartyDeleteManyArgs} args - Arguments to filter TransactionParties to delete.
     * @example
     * // Delete a few TransactionParties
     * const { count } = await prisma.transactionParty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionPartyDeleteManyArgs>(args?: SelectSubset<T, TransactionPartyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionParties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionParties
     * const transactionParty = await prisma.transactionParty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionPartyUpdateManyArgs>(args: SelectSubset<T, TransactionPartyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionParties and returns the data updated in the database.
     * @param {TransactionPartyUpdateManyAndReturnArgs} args - Arguments to update many TransactionParties.
     * @example
     * // Update many TransactionParties
     * const transactionParty = await prisma.transactionParty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionParties and only return the `id`
     * const transactionPartyWithIdOnly = await prisma.transactionParty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionPartyUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionPartyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionParty.
     * @param {TransactionPartyUpsertArgs} args - Arguments to update or create a TransactionParty.
     * @example
     * // Update or create a TransactionParty
     * const transactionParty = await prisma.transactionParty.upsert({
     *   create: {
     *     // ... data to create a TransactionParty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionParty we want to update
     *   }
     * })
     */
    upsert<T extends TransactionPartyUpsertArgs>(args: SelectSubset<T, TransactionPartyUpsertArgs<ExtArgs>>): Prisma__TransactionPartyClient<$Result.GetResult<Prisma.$TransactionPartyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionParties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyCountArgs} args - Arguments to filter TransactionParties to count.
     * @example
     * // Count the number of TransactionParties
     * const count = await prisma.transactionParty.count({
     *   where: {
     *     // ... the filter for the TransactionParties we want to count
     *   }
     * })
    **/
    count<T extends TransactionPartyCountArgs>(
      args?: Subset<T, TransactionPartyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionPartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionParty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionPartyAggregateArgs>(args: Subset<T, TransactionPartyAggregateArgs>): Prisma.PrismaPromise<GetTransactionPartyAggregateType<T>>

    /**
     * Group by TransactionParty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPartyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionPartyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionPartyGroupByArgs['orderBy'] }
        : { orderBy?: TransactionPartyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionPartyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionPartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionParty model
   */
  readonly fields: TransactionPartyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionParty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionPartyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionParty model
   */
  interface TransactionPartyFieldRefs {
    readonly id: FieldRef<"TransactionParty", 'String'>
    readonly transactionId: FieldRef<"TransactionParty", 'String'>
    readonly tenantId: FieldRef<"TransactionParty", 'String'>
    readonly role: FieldRef<"TransactionParty", 'String'>
    readonly name: FieldRef<"TransactionParty", 'String'>
    readonly email: FieldRef<"TransactionParty", 'String'>
    readonly phone: FieldRef<"TransactionParty", 'String'>
    readonly company: FieldRef<"TransactionParty", 'String'>
    readonly createdAt: FieldRef<"TransactionParty", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionParty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionParty findUnique
   */
  export type TransactionPartyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter, which TransactionParty to fetch.
     */
    where: TransactionPartyWhereUniqueInput
  }

  /**
   * TransactionParty findUniqueOrThrow
   */
  export type TransactionPartyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter, which TransactionParty to fetch.
     */
    where: TransactionPartyWhereUniqueInput
  }

  /**
   * TransactionParty findFirst
   */
  export type TransactionPartyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter, which TransactionParty to fetch.
     */
    where?: TransactionPartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionParties to fetch.
     */
    orderBy?: TransactionPartyOrderByWithRelationInput | TransactionPartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionParties.
     */
    cursor?: TransactionPartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionParties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionParties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionParties.
     */
    distinct?: TransactionPartyScalarFieldEnum | TransactionPartyScalarFieldEnum[]
  }

  /**
   * TransactionParty findFirstOrThrow
   */
  export type TransactionPartyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter, which TransactionParty to fetch.
     */
    where?: TransactionPartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionParties to fetch.
     */
    orderBy?: TransactionPartyOrderByWithRelationInput | TransactionPartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionParties.
     */
    cursor?: TransactionPartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionParties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionParties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionParties.
     */
    distinct?: TransactionPartyScalarFieldEnum | TransactionPartyScalarFieldEnum[]
  }

  /**
   * TransactionParty findMany
   */
  export type TransactionPartyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter, which TransactionParties to fetch.
     */
    where?: TransactionPartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionParties to fetch.
     */
    orderBy?: TransactionPartyOrderByWithRelationInput | TransactionPartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionParties.
     */
    cursor?: TransactionPartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionParties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionParties.
     */
    skip?: number
    distinct?: TransactionPartyScalarFieldEnum | TransactionPartyScalarFieldEnum[]
  }

  /**
   * TransactionParty create
   */
  export type TransactionPartyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionParty.
     */
    data: XOR<TransactionPartyCreateInput, TransactionPartyUncheckedCreateInput>
  }

  /**
   * TransactionParty createMany
   */
  export type TransactionPartyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionParties.
     */
    data: TransactionPartyCreateManyInput | TransactionPartyCreateManyInput[]
  }

  /**
   * TransactionParty createManyAndReturn
   */
  export type TransactionPartyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionParties.
     */
    data: TransactionPartyCreateManyInput | TransactionPartyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionParty update
   */
  export type TransactionPartyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionParty.
     */
    data: XOR<TransactionPartyUpdateInput, TransactionPartyUncheckedUpdateInput>
    /**
     * Choose, which TransactionParty to update.
     */
    where: TransactionPartyWhereUniqueInput
  }

  /**
   * TransactionParty updateMany
   */
  export type TransactionPartyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionParties.
     */
    data: XOR<TransactionPartyUpdateManyMutationInput, TransactionPartyUncheckedUpdateManyInput>
    /**
     * Filter which TransactionParties to update
     */
    where?: TransactionPartyWhereInput
    /**
     * Limit how many TransactionParties to update.
     */
    limit?: number
  }

  /**
   * TransactionParty updateManyAndReturn
   */
  export type TransactionPartyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * The data used to update TransactionParties.
     */
    data: XOR<TransactionPartyUpdateManyMutationInput, TransactionPartyUncheckedUpdateManyInput>
    /**
     * Filter which TransactionParties to update
     */
    where?: TransactionPartyWhereInput
    /**
     * Limit how many TransactionParties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionParty upsert
   */
  export type TransactionPartyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionParty to update in case it exists.
     */
    where: TransactionPartyWhereUniqueInput
    /**
     * In case the TransactionParty found by the `where` argument doesn't exist, create a new TransactionParty with this data.
     */
    create: XOR<TransactionPartyCreateInput, TransactionPartyUncheckedCreateInput>
    /**
     * In case the TransactionParty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionPartyUpdateInput, TransactionPartyUncheckedUpdateInput>
  }

  /**
   * TransactionParty delete
   */
  export type TransactionPartyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
    /**
     * Filter which TransactionParty to delete.
     */
    where: TransactionPartyWhereUniqueInput
  }

  /**
   * TransactionParty deleteMany
   */
  export type TransactionPartyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionParties to delete
     */
    where?: TransactionPartyWhereInput
    /**
     * Limit how many TransactionParties to delete.
     */
    limit?: number
  }

  /**
   * TransactionParty without action
   */
  export type TransactionPartyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionParty
     */
    select?: TransactionPartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionParty
     */
    omit?: TransactionPartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionPartyInclude<ExtArgs> | null
  }


  /**
   * Model TransactionDocument
   */

  export type AggregateTransactionDocument = {
    _count: TransactionDocumentCountAggregateOutputType | null
    _min: TransactionDocumentMinAggregateOutputType | null
    _max: TransactionDocumentMaxAggregateOutputType | null
  }

  export type TransactionDocumentMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    documentType: string | null
    fileName: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionDocumentMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    documentType: string | null
    fileName: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionDocumentCountAggregateOutputType = {
    id: number
    transactionId: number
    tenantId: number
    documentType: number
    fileName: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionDocumentMinAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    documentType?: true
    fileName?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionDocumentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    documentType?: true
    fileName?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionDocumentCountAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    documentType?: true
    fileName?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionDocument to aggregate.
     */
    where?: TransactionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionDocuments to fetch.
     */
    orderBy?: TransactionDocumentOrderByWithRelationInput | TransactionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionDocuments
    **/
    _count?: true | TransactionDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionDocumentMaxAggregateInputType
  }

  export type GetTransactionDocumentAggregateType<T extends TransactionDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionDocument[P]>
      : GetScalarType<T[P], AggregateTransactionDocument[P]>
  }




  export type TransactionDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionDocumentWhereInput
    orderBy?: TransactionDocumentOrderByWithAggregationInput | TransactionDocumentOrderByWithAggregationInput[]
    by: TransactionDocumentScalarFieldEnum[] | TransactionDocumentScalarFieldEnum
    having?: TransactionDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionDocumentCountAggregateInputType | true
    _min?: TransactionDocumentMinAggregateInputType
    _max?: TransactionDocumentMaxAggregateInputType
  }

  export type TransactionDocumentGroupByOutputType = {
    id: string
    transactionId: string
    tenantId: string
    documentType: string
    fileName: string
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionDocumentCountAggregateOutputType | null
    _min: TransactionDocumentMinAggregateOutputType | null
    _max: TransactionDocumentMaxAggregateOutputType | null
  }

  type GetTransactionDocumentGroupByPayload<T extends TransactionDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionDocumentGroupByOutputType[P]>
        }
      >
    >


  export type TransactionDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    documentType?: boolean
    fileName?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionDocument"]>

  export type TransactionDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    documentType?: boolean
    fileName?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionDocument"]>

  export type TransactionDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    documentType?: boolean
    fileName?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionDocument"]>

  export type TransactionDocumentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    documentType?: boolean
    fileName?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "tenantId" | "documentType" | "fileName" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionDocument"]>
  export type TransactionDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionDocument"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      tenantId: string
      documentType: string
      fileName: string
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionDocument"]>
    composites: {}
  }

  type TransactionDocumentGetPayload<S extends boolean | null | undefined | TransactionDocumentDefaultArgs> = $Result.GetResult<Prisma.$TransactionDocumentPayload, S>

  type TransactionDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionDocumentCountAggregateInputType | true
    }

  export interface TransactionDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionDocument'], meta: { name: 'TransactionDocument' } }
    /**
     * Find zero or one TransactionDocument that matches the filter.
     * @param {TransactionDocumentFindUniqueArgs} args - Arguments to find a TransactionDocument
     * @example
     * // Get one TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionDocumentFindUniqueArgs>(args: SelectSubset<T, TransactionDocumentFindUniqueArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionDocumentFindUniqueOrThrowArgs} args - Arguments to find a TransactionDocument
     * @example
     * // Get one TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentFindFirstArgs} args - Arguments to find a TransactionDocument
     * @example
     * // Get one TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionDocumentFindFirstArgs>(args?: SelectSubset<T, TransactionDocumentFindFirstArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentFindFirstOrThrowArgs} args - Arguments to find a TransactionDocument
     * @example
     * // Get one TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionDocuments
     * const transactionDocuments = await prisma.transactionDocument.findMany()
     * 
     * // Get first 10 TransactionDocuments
     * const transactionDocuments = await prisma.transactionDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionDocumentWithIdOnly = await prisma.transactionDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionDocumentFindManyArgs>(args?: SelectSubset<T, TransactionDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionDocument.
     * @param {TransactionDocumentCreateArgs} args - Arguments to create a TransactionDocument.
     * @example
     * // Create one TransactionDocument
     * const TransactionDocument = await prisma.transactionDocument.create({
     *   data: {
     *     // ... data to create a TransactionDocument
     *   }
     * })
     * 
     */
    create<T extends TransactionDocumentCreateArgs>(args: SelectSubset<T, TransactionDocumentCreateArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionDocuments.
     * @param {TransactionDocumentCreateManyArgs} args - Arguments to create many TransactionDocuments.
     * @example
     * // Create many TransactionDocuments
     * const transactionDocument = await prisma.transactionDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionDocumentCreateManyArgs>(args?: SelectSubset<T, TransactionDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionDocuments and returns the data saved in the database.
     * @param {TransactionDocumentCreateManyAndReturnArgs} args - Arguments to create many TransactionDocuments.
     * @example
     * // Create many TransactionDocuments
     * const transactionDocument = await prisma.transactionDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionDocuments and only return the `id`
     * const transactionDocumentWithIdOnly = await prisma.transactionDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionDocument.
     * @param {TransactionDocumentDeleteArgs} args - Arguments to delete one TransactionDocument.
     * @example
     * // Delete one TransactionDocument
     * const TransactionDocument = await prisma.transactionDocument.delete({
     *   where: {
     *     // ... filter to delete one TransactionDocument
     *   }
     * })
     * 
     */
    delete<T extends TransactionDocumentDeleteArgs>(args: SelectSubset<T, TransactionDocumentDeleteArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionDocument.
     * @param {TransactionDocumentUpdateArgs} args - Arguments to update one TransactionDocument.
     * @example
     * // Update one TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionDocumentUpdateArgs>(args: SelectSubset<T, TransactionDocumentUpdateArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionDocuments.
     * @param {TransactionDocumentDeleteManyArgs} args - Arguments to filter TransactionDocuments to delete.
     * @example
     * // Delete a few TransactionDocuments
     * const { count } = await prisma.transactionDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDocumentDeleteManyArgs>(args?: SelectSubset<T, TransactionDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionDocuments
     * const transactionDocument = await prisma.transactionDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionDocumentUpdateManyArgs>(args: SelectSubset<T, TransactionDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionDocuments and returns the data updated in the database.
     * @param {TransactionDocumentUpdateManyAndReturnArgs} args - Arguments to update many TransactionDocuments.
     * @example
     * // Update many TransactionDocuments
     * const transactionDocument = await prisma.transactionDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionDocuments and only return the `id`
     * const transactionDocumentWithIdOnly = await prisma.transactionDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionDocument.
     * @param {TransactionDocumentUpsertArgs} args - Arguments to update or create a TransactionDocument.
     * @example
     * // Update or create a TransactionDocument
     * const transactionDocument = await prisma.transactionDocument.upsert({
     *   create: {
     *     // ... data to create a TransactionDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionDocument we want to update
     *   }
     * })
     */
    upsert<T extends TransactionDocumentUpsertArgs>(args: SelectSubset<T, TransactionDocumentUpsertArgs<ExtArgs>>): Prisma__TransactionDocumentClient<$Result.GetResult<Prisma.$TransactionDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentCountArgs} args - Arguments to filter TransactionDocuments to count.
     * @example
     * // Count the number of TransactionDocuments
     * const count = await prisma.transactionDocument.count({
     *   where: {
     *     // ... the filter for the TransactionDocuments we want to count
     *   }
     * })
    **/
    count<T extends TransactionDocumentCountArgs>(
      args?: Subset<T, TransactionDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionDocumentAggregateArgs>(args: Subset<T, TransactionDocumentAggregateArgs>): Prisma.PrismaPromise<GetTransactionDocumentAggregateType<T>>

    /**
     * Group by TransactionDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionDocumentGroupByArgs['orderBy'] }
        : { orderBy?: TransactionDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionDocument model
   */
  readonly fields: TransactionDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionDocument model
   */
  interface TransactionDocumentFieldRefs {
    readonly id: FieldRef<"TransactionDocument", 'String'>
    readonly transactionId: FieldRef<"TransactionDocument", 'String'>
    readonly tenantId: FieldRef<"TransactionDocument", 'String'>
    readonly documentType: FieldRef<"TransactionDocument", 'String'>
    readonly fileName: FieldRef<"TransactionDocument", 'String'>
    readonly status: FieldRef<"TransactionDocument", 'String'>
    readonly notes: FieldRef<"TransactionDocument", 'String'>
    readonly createdAt: FieldRef<"TransactionDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionDocument findUnique
   */
  export type TransactionDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransactionDocument to fetch.
     */
    where: TransactionDocumentWhereUniqueInput
  }

  /**
   * TransactionDocument findUniqueOrThrow
   */
  export type TransactionDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransactionDocument to fetch.
     */
    where: TransactionDocumentWhereUniqueInput
  }

  /**
   * TransactionDocument findFirst
   */
  export type TransactionDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransactionDocument to fetch.
     */
    where?: TransactionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionDocuments to fetch.
     */
    orderBy?: TransactionDocumentOrderByWithRelationInput | TransactionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionDocuments.
     */
    cursor?: TransactionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionDocuments.
     */
    distinct?: TransactionDocumentScalarFieldEnum | TransactionDocumentScalarFieldEnum[]
  }

  /**
   * TransactionDocument findFirstOrThrow
   */
  export type TransactionDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransactionDocument to fetch.
     */
    where?: TransactionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionDocuments to fetch.
     */
    orderBy?: TransactionDocumentOrderByWithRelationInput | TransactionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionDocuments.
     */
    cursor?: TransactionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionDocuments.
     */
    distinct?: TransactionDocumentScalarFieldEnum | TransactionDocumentScalarFieldEnum[]
  }

  /**
   * TransactionDocument findMany
   */
  export type TransactionDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter, which TransactionDocuments to fetch.
     */
    where?: TransactionDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionDocuments to fetch.
     */
    orderBy?: TransactionDocumentOrderByWithRelationInput | TransactionDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionDocuments.
     */
    cursor?: TransactionDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionDocuments.
     */
    skip?: number
    distinct?: TransactionDocumentScalarFieldEnum | TransactionDocumentScalarFieldEnum[]
  }

  /**
   * TransactionDocument create
   */
  export type TransactionDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionDocument.
     */
    data: XOR<TransactionDocumentCreateInput, TransactionDocumentUncheckedCreateInput>
  }

  /**
   * TransactionDocument createMany
   */
  export type TransactionDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionDocuments.
     */
    data: TransactionDocumentCreateManyInput | TransactionDocumentCreateManyInput[]
  }

  /**
   * TransactionDocument createManyAndReturn
   */
  export type TransactionDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionDocuments.
     */
    data: TransactionDocumentCreateManyInput | TransactionDocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionDocument update
   */
  export type TransactionDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionDocument.
     */
    data: XOR<TransactionDocumentUpdateInput, TransactionDocumentUncheckedUpdateInput>
    /**
     * Choose, which TransactionDocument to update.
     */
    where: TransactionDocumentWhereUniqueInput
  }

  /**
   * TransactionDocument updateMany
   */
  export type TransactionDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionDocuments.
     */
    data: XOR<TransactionDocumentUpdateManyMutationInput, TransactionDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TransactionDocuments to update
     */
    where?: TransactionDocumentWhereInput
    /**
     * Limit how many TransactionDocuments to update.
     */
    limit?: number
  }

  /**
   * TransactionDocument updateManyAndReturn
   */
  export type TransactionDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * The data used to update TransactionDocuments.
     */
    data: XOR<TransactionDocumentUpdateManyMutationInput, TransactionDocumentUncheckedUpdateManyInput>
    /**
     * Filter which TransactionDocuments to update
     */
    where?: TransactionDocumentWhereInput
    /**
     * Limit how many TransactionDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionDocument upsert
   */
  export type TransactionDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionDocument to update in case it exists.
     */
    where: TransactionDocumentWhereUniqueInput
    /**
     * In case the TransactionDocument found by the `where` argument doesn't exist, create a new TransactionDocument with this data.
     */
    create: XOR<TransactionDocumentCreateInput, TransactionDocumentUncheckedCreateInput>
    /**
     * In case the TransactionDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionDocumentUpdateInput, TransactionDocumentUncheckedUpdateInput>
  }

  /**
   * TransactionDocument delete
   */
  export type TransactionDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
    /**
     * Filter which TransactionDocument to delete.
     */
    where: TransactionDocumentWhereUniqueInput
  }

  /**
   * TransactionDocument deleteMany
   */
  export type TransactionDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionDocuments to delete
     */
    where?: TransactionDocumentWhereInput
    /**
     * Limit how many TransactionDocuments to delete.
     */
    limit?: number
  }

  /**
   * TransactionDocument without action
   */
  export type TransactionDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionDocument
     */
    select?: TransactionDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionDocument
     */
    omit?: TransactionDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionDocumentInclude<ExtArgs> | null
  }


  /**
   * Model TransactionMilestone
   */

  export type AggregateTransactionMilestone = {
    _count: TransactionMilestoneCountAggregateOutputType | null
    _min: TransactionMilestoneMinAggregateOutputType | null
    _max: TransactionMilestoneMaxAggregateOutputType | null
  }

  export type TransactionMilestoneMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    milestoneType: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMilestoneMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    tenantId: string | null
    milestoneType: string | null
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMilestoneCountAggregateOutputType = {
    id: number
    transactionId: number
    tenantId: number
    milestoneType: number
    scheduledAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionMilestoneMinAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    milestoneType?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMilestoneMaxAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    milestoneType?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMilestoneCountAggregateInputType = {
    id?: true
    transactionId?: true
    tenantId?: true
    milestoneType?: true
    scheduledAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionMilestone to aggregate.
     */
    where?: TransactionMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMilestones to fetch.
     */
    orderBy?: TransactionMilestoneOrderByWithRelationInput | TransactionMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionMilestones
    **/
    _count?: true | TransactionMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMilestoneMaxAggregateInputType
  }

  export type GetTransactionMilestoneAggregateType<T extends TransactionMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionMilestone[P]>
      : GetScalarType<T[P], AggregateTransactionMilestone[P]>
  }




  export type TransactionMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionMilestoneWhereInput
    orderBy?: TransactionMilestoneOrderByWithAggregationInput | TransactionMilestoneOrderByWithAggregationInput[]
    by: TransactionMilestoneScalarFieldEnum[] | TransactionMilestoneScalarFieldEnum
    having?: TransactionMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionMilestoneCountAggregateInputType | true
    _min?: TransactionMilestoneMinAggregateInputType
    _max?: TransactionMilestoneMaxAggregateInputType
  }

  export type TransactionMilestoneGroupByOutputType = {
    id: string
    transactionId: string
    tenantId: string
    milestoneType: string
    scheduledAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionMilestoneCountAggregateOutputType | null
    _min: TransactionMilestoneMinAggregateOutputType | null
    _max: TransactionMilestoneMaxAggregateOutputType | null
  }

  type GetTransactionMilestoneGroupByPayload<T extends TransactionMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type TransactionMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    milestoneType?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionMilestone"]>

  export type TransactionMilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    milestoneType?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionMilestone"]>

  export type TransactionMilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    milestoneType?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionMilestone"]>

  export type TransactionMilestoneSelectScalar = {
    id?: boolean
    transactionId?: boolean
    tenantId?: boolean
    milestoneType?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionMilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "tenantId" | "milestoneType" | "scheduledAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionMilestone"]>
  export type TransactionMilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionMilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionMilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionMilestone"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      tenantId: string
      milestoneType: string
      scheduledAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionMilestone"]>
    composites: {}
  }

  type TransactionMilestoneGetPayload<S extends boolean | null | undefined | TransactionMilestoneDefaultArgs> = $Result.GetResult<Prisma.$TransactionMilestonePayload, S>

  type TransactionMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionMilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionMilestoneCountAggregateInputType | true
    }

  export interface TransactionMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionMilestone'], meta: { name: 'TransactionMilestone' } }
    /**
     * Find zero or one TransactionMilestone that matches the filter.
     * @param {TransactionMilestoneFindUniqueArgs} args - Arguments to find a TransactionMilestone
     * @example
     * // Get one TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionMilestoneFindUniqueArgs>(args: SelectSubset<T, TransactionMilestoneFindUniqueArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionMilestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionMilestoneFindUniqueOrThrowArgs} args - Arguments to find a TransactionMilestone
     * @example
     * // Get one TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneFindFirstArgs} args - Arguments to find a TransactionMilestone
     * @example
     * // Get one TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionMilestoneFindFirstArgs>(args?: SelectSubset<T, TransactionMilestoneFindFirstArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneFindFirstOrThrowArgs} args - Arguments to find a TransactionMilestone
     * @example
     * // Get one TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionMilestones
     * const transactionMilestones = await prisma.transactionMilestone.findMany()
     * 
     * // Get first 10 TransactionMilestones
     * const transactionMilestones = await prisma.transactionMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionMilestoneWithIdOnly = await prisma.transactionMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionMilestoneFindManyArgs>(args?: SelectSubset<T, TransactionMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionMilestone.
     * @param {TransactionMilestoneCreateArgs} args - Arguments to create a TransactionMilestone.
     * @example
     * // Create one TransactionMilestone
     * const TransactionMilestone = await prisma.transactionMilestone.create({
     *   data: {
     *     // ... data to create a TransactionMilestone
     *   }
     * })
     * 
     */
    create<T extends TransactionMilestoneCreateArgs>(args: SelectSubset<T, TransactionMilestoneCreateArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionMilestones.
     * @param {TransactionMilestoneCreateManyArgs} args - Arguments to create many TransactionMilestones.
     * @example
     * // Create many TransactionMilestones
     * const transactionMilestone = await prisma.transactionMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionMilestoneCreateManyArgs>(args?: SelectSubset<T, TransactionMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionMilestones and returns the data saved in the database.
     * @param {TransactionMilestoneCreateManyAndReturnArgs} args - Arguments to create many TransactionMilestones.
     * @example
     * // Create many TransactionMilestones
     * const transactionMilestone = await prisma.transactionMilestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionMilestones and only return the `id`
     * const transactionMilestoneWithIdOnly = await prisma.transactionMilestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionMilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionMilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionMilestone.
     * @param {TransactionMilestoneDeleteArgs} args - Arguments to delete one TransactionMilestone.
     * @example
     * // Delete one TransactionMilestone
     * const TransactionMilestone = await prisma.transactionMilestone.delete({
     *   where: {
     *     // ... filter to delete one TransactionMilestone
     *   }
     * })
     * 
     */
    delete<T extends TransactionMilestoneDeleteArgs>(args: SelectSubset<T, TransactionMilestoneDeleteArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionMilestone.
     * @param {TransactionMilestoneUpdateArgs} args - Arguments to update one TransactionMilestone.
     * @example
     * // Update one TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionMilestoneUpdateArgs>(args: SelectSubset<T, TransactionMilestoneUpdateArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionMilestones.
     * @param {TransactionMilestoneDeleteManyArgs} args - Arguments to filter TransactionMilestones to delete.
     * @example
     * // Delete a few TransactionMilestones
     * const { count } = await prisma.transactionMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionMilestoneDeleteManyArgs>(args?: SelectSubset<T, TransactionMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionMilestones
     * const transactionMilestone = await prisma.transactionMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionMilestoneUpdateManyArgs>(args: SelectSubset<T, TransactionMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionMilestones and returns the data updated in the database.
     * @param {TransactionMilestoneUpdateManyAndReturnArgs} args - Arguments to update many TransactionMilestones.
     * @example
     * // Update many TransactionMilestones
     * const transactionMilestone = await prisma.transactionMilestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionMilestones and only return the `id`
     * const transactionMilestoneWithIdOnly = await prisma.transactionMilestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionMilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionMilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionMilestone.
     * @param {TransactionMilestoneUpsertArgs} args - Arguments to update or create a TransactionMilestone.
     * @example
     * // Update or create a TransactionMilestone
     * const transactionMilestone = await prisma.transactionMilestone.upsert({
     *   create: {
     *     // ... data to create a TransactionMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionMilestone we want to update
     *   }
     * })
     */
    upsert<T extends TransactionMilestoneUpsertArgs>(args: SelectSubset<T, TransactionMilestoneUpsertArgs<ExtArgs>>): Prisma__TransactionMilestoneClient<$Result.GetResult<Prisma.$TransactionMilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneCountArgs} args - Arguments to filter TransactionMilestones to count.
     * @example
     * // Count the number of TransactionMilestones
     * const count = await prisma.transactionMilestone.count({
     *   where: {
     *     // ... the filter for the TransactionMilestones we want to count
     *   }
     * })
    **/
    count<T extends TransactionMilestoneCountArgs>(
      args?: Subset<T, TransactionMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionMilestoneAggregateArgs>(args: Subset<T, TransactionMilestoneAggregateArgs>): Prisma.PrismaPromise<GetTransactionMilestoneAggregateType<T>>

    /**
     * Group by TransactionMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: TransactionMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionMilestone model
   */
  readonly fields: TransactionMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionMilestone model
   */
  interface TransactionMilestoneFieldRefs {
    readonly id: FieldRef<"TransactionMilestone", 'String'>
    readonly transactionId: FieldRef<"TransactionMilestone", 'String'>
    readonly tenantId: FieldRef<"TransactionMilestone", 'String'>
    readonly milestoneType: FieldRef<"TransactionMilestone", 'String'>
    readonly scheduledAt: FieldRef<"TransactionMilestone", 'DateTime'>
    readonly completedAt: FieldRef<"TransactionMilestone", 'DateTime'>
    readonly createdAt: FieldRef<"TransactionMilestone", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionMilestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionMilestone findUnique
   */
  export type TransactionMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which TransactionMilestone to fetch.
     */
    where: TransactionMilestoneWhereUniqueInput
  }

  /**
   * TransactionMilestone findUniqueOrThrow
   */
  export type TransactionMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which TransactionMilestone to fetch.
     */
    where: TransactionMilestoneWhereUniqueInput
  }

  /**
   * TransactionMilestone findFirst
   */
  export type TransactionMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which TransactionMilestone to fetch.
     */
    where?: TransactionMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMilestones to fetch.
     */
    orderBy?: TransactionMilestoneOrderByWithRelationInput | TransactionMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionMilestones.
     */
    cursor?: TransactionMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionMilestones.
     */
    distinct?: TransactionMilestoneScalarFieldEnum | TransactionMilestoneScalarFieldEnum[]
  }

  /**
   * TransactionMilestone findFirstOrThrow
   */
  export type TransactionMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which TransactionMilestone to fetch.
     */
    where?: TransactionMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMilestones to fetch.
     */
    orderBy?: TransactionMilestoneOrderByWithRelationInput | TransactionMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionMilestones.
     */
    cursor?: TransactionMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionMilestones.
     */
    distinct?: TransactionMilestoneScalarFieldEnum | TransactionMilestoneScalarFieldEnum[]
  }

  /**
   * TransactionMilestone findMany
   */
  export type TransactionMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter, which TransactionMilestones to fetch.
     */
    where?: TransactionMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionMilestones to fetch.
     */
    orderBy?: TransactionMilestoneOrderByWithRelationInput | TransactionMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionMilestones.
     */
    cursor?: TransactionMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionMilestones.
     */
    skip?: number
    distinct?: TransactionMilestoneScalarFieldEnum | TransactionMilestoneScalarFieldEnum[]
  }

  /**
   * TransactionMilestone create
   */
  export type TransactionMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionMilestone.
     */
    data: XOR<TransactionMilestoneCreateInput, TransactionMilestoneUncheckedCreateInput>
  }

  /**
   * TransactionMilestone createMany
   */
  export type TransactionMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionMilestones.
     */
    data: TransactionMilestoneCreateManyInput | TransactionMilestoneCreateManyInput[]
  }

  /**
   * TransactionMilestone createManyAndReturn
   */
  export type TransactionMilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionMilestones.
     */
    data: TransactionMilestoneCreateManyInput | TransactionMilestoneCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionMilestone update
   */
  export type TransactionMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionMilestone.
     */
    data: XOR<TransactionMilestoneUpdateInput, TransactionMilestoneUncheckedUpdateInput>
    /**
     * Choose, which TransactionMilestone to update.
     */
    where: TransactionMilestoneWhereUniqueInput
  }

  /**
   * TransactionMilestone updateMany
   */
  export type TransactionMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionMilestones.
     */
    data: XOR<TransactionMilestoneUpdateManyMutationInput, TransactionMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which TransactionMilestones to update
     */
    where?: TransactionMilestoneWhereInput
    /**
     * Limit how many TransactionMilestones to update.
     */
    limit?: number
  }

  /**
   * TransactionMilestone updateManyAndReturn
   */
  export type TransactionMilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * The data used to update TransactionMilestones.
     */
    data: XOR<TransactionMilestoneUpdateManyMutationInput, TransactionMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which TransactionMilestones to update
     */
    where?: TransactionMilestoneWhereInput
    /**
     * Limit how many TransactionMilestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionMilestone upsert
   */
  export type TransactionMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionMilestone to update in case it exists.
     */
    where: TransactionMilestoneWhereUniqueInput
    /**
     * In case the TransactionMilestone found by the `where` argument doesn't exist, create a new TransactionMilestone with this data.
     */
    create: XOR<TransactionMilestoneCreateInput, TransactionMilestoneUncheckedCreateInput>
    /**
     * In case the TransactionMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionMilestoneUpdateInput, TransactionMilestoneUncheckedUpdateInput>
  }

  /**
   * TransactionMilestone delete
   */
  export type TransactionMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
    /**
     * Filter which TransactionMilestone to delete.
     */
    where: TransactionMilestoneWhereUniqueInput
  }

  /**
   * TransactionMilestone deleteMany
   */
  export type TransactionMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionMilestones to delete
     */
    where?: TransactionMilestoneWhereInput
    /**
     * Limit how many TransactionMilestones to delete.
     */
    limit?: number
  }

  /**
   * TransactionMilestone without action
   */
  export type TransactionMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionMilestone
     */
    select?: TransactionMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionMilestone
     */
    omit?: TransactionMilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionMilestoneInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantDomainScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    hostname: 'hostname',
    hostnameNormalized: 'hostnameNormalized',
    status: 'status',
    isPrimary: 'isPrimary',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantDomainScalarFieldEnum = (typeof TenantDomainScalarFieldEnum)[keyof typeof TenantDomainScalarFieldEnum]


  export const WebsiteConfigScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebsiteConfigScalarFieldEnum = (typeof WebsiteConfigScalarFieldEnum)[keyof typeof WebsiteConfigScalarFieldEnum]


  export const TenantControlSettingsScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    status: 'status',
    planCode: 'planCode',
    featureFlagsJson: 'featureFlagsJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantControlSettingsScalarFieldEnum = (typeof TenantControlSettingsScalarFieldEnum)[keyof typeof TenantControlSettingsScalarFieldEnum]


  export const TenantBillingSubscriptionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    planCode: 'planCode',
    status: 'status',
    paymentStatus: 'paymentStatus',
    billingProvider: 'billingProvider',
    billingCustomerId: 'billingCustomerId',
    billingSubscriptionId: 'billingSubscriptionId',
    trialEndsAt: 'trialEndsAt',
    currentPeriodEndsAt: 'currentPeriodEndsAt',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantBillingSubscriptionScalarFieldEnum = (typeof TenantBillingSubscriptionScalarFieldEnum)[keyof typeof TenantBillingSubscriptionScalarFieldEnum]


  export const TenantBillingSyncEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    provider: 'provider',
    eventId: 'eventId',
    eventType: 'eventType',
    payloadJson: 'payloadJson',
    resultStatus: 'resultStatus',
    resultMessage: 'resultMessage',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type TenantBillingSyncEventScalarFieldEnum = (typeof TenantBillingSyncEventScalarFieldEnum)[keyof typeof TenantBillingSyncEventScalarFieldEnum]


  export const TenantControlActorScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    actorId: 'actorId',
    displayName: 'displayName',
    email: 'email',
    role: 'role',
    permissionsJson: 'permissionsJson',
    supportSessionActive: 'supportSessionActive',
    supportSessionStartedAt: 'supportSessionStartedAt',
    supportSessionExpiresAt: 'supportSessionExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantControlActorScalarFieldEnum = (typeof TenantControlActorScalarFieldEnum)[keyof typeof TenantControlActorScalarFieldEnum]


  export const TenantOnboardingPlanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    status: 'status',
    planCode: 'planCode',
    startedAt: 'startedAt',
    targetLaunchDate: 'targetLaunchDate',
    completedAt: 'completedAt',
    pausedAt: 'pausedAt',
    pauseReason: 'pauseReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantOnboardingPlanScalarFieldEnum = (typeof TenantOnboardingPlanScalarFieldEnum)[keyof typeof TenantOnboardingPlanScalarFieldEnum]


  export const TenantOnboardingTaskScalarFieldEnum: {
    id: 'id',
    tenantOnboardingPlanId: 'tenantOnboardingPlanId',
    tenantId: 'tenantId',
    taskKey: 'taskKey',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    required: 'required',
    ownerRole: 'ownerRole',
    ownerActorId: 'ownerActorId',
    dueAt: 'dueAt',
    blockedByClient: 'blockedByClient',
    blockerReason: 'blockerReason',
    sortOrder: 'sortOrder',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantOnboardingTaskScalarFieldEnum = (typeof TenantOnboardingTaskScalarFieldEnum)[keyof typeof TenantOnboardingTaskScalarFieldEnum]


  export const ModuleConfigScalarFieldEnum: {
    id: 'id',
    websiteConfigId: 'websiteConfigId',
    tenantId: 'tenantId',
    moduleKey: 'moduleKey',
    enabled: 'enabled',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleConfigScalarFieldEnum = (typeof ModuleConfigScalarFieldEnum)[keyof typeof ModuleConfigScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    fullName: 'fullName',
    email: 'email',
    emailNormalized: 'emailNormalized',
    phone: 'phone',
    phoneNormalized: 'phoneNormalized',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    status: 'status',
    leadType: 'leadType',
    source: 'source',
    timeframe: 'timeframe',
    notes: 'notes',
    listingId: 'listingId',
    listingUrl: 'listingUrl',
    listingAddress: 'listingAddress',
    propertyType: 'propertyType',
    beds: 'beds',
    baths: 'baths',
    sqft: 'sqft',
    lastContactAt: 'lastContactAt',
    nextActionAt: 'nextActionAt',
    nextActionNote: 'nextActionNote',
    nextActionChannel: 'nextActionChannel',
    reminderSnoozedUntil: 'reminderSnoozedUntil',
    priceMin: 'priceMin',
    priceMax: 'priceMax',
    tags: 'tags',
    closeReason: 'closeReason',
    closeNotes: 'closeNotes',
    closedAt: 'closedAt',
    assignedTo: 'assignedTo',
    referredBy: 'referredBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    leadId: 'leadId',
    activityType: 'activityType',
    occurredAt: 'occurredAt',
    summary: 'summary',
    metadataJson: 'metadataJson',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const IngestedEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    eventType: 'eventType',
    eventKey: 'eventKey',
    occurredAt: 'occurredAt',
    payloadJson: 'payloadJson',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type IngestedEventScalarFieldEnum = (typeof IngestedEventScalarFieldEnum)[keyof typeof IngestedEventScalarFieldEnum]


  export const IngestionQueueJobScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    eventType: 'eventType',
    eventKey: 'eventKey',
    occurredAt: 'occurredAt',
    payloadJson: 'payloadJson',
    status: 'status',
    attemptCount: 'attemptCount',
    lastError: 'lastError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    processedAt: 'processedAt',
    nextAttemptAt: 'nextAttemptAt',
    deadLetteredAt: 'deadLetteredAt'
  };

  export type IngestionQueueJobScalarFieldEnum = (typeof IngestionQueueJobScalarFieldEnum)[keyof typeof IngestionQueueJobScalarFieldEnum]


  export const AdminAuditEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    domainId: 'domainId',
    action: 'action',
    status: 'status',
    actorId: 'actorId',
    actorRole: 'actorRole',
    error: 'error',
    metadataJson: 'metadataJson',
    createdAt: 'createdAt'
  };

  export type AdminAuditEventScalarFieldEnum = (typeof AdminAuditEventScalarFieldEnum)[keyof typeof AdminAuditEventScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    leadId: 'leadId',
    contactId: 'contactId',
    propertyAddress: 'propertyAddress',
    status: 'status',
    side: 'side',
    salePrice: 'salePrice',
    listPrice: 'listPrice',
    closingDate: 'closingDate',
    contractDate: 'contractDate',
    inspectionDate: 'inspectionDate',
    appraisalDate: 'appraisalDate',
    titleDate: 'titleDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionPartyScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    tenantId: 'tenantId',
    role: 'role',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionPartyScalarFieldEnum = (typeof TransactionPartyScalarFieldEnum)[keyof typeof TransactionPartyScalarFieldEnum]


  export const TransactionDocumentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    tenantId: 'tenantId',
    documentType: 'documentType',
    fileName: 'fileName',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionDocumentScalarFieldEnum = (typeof TransactionDocumentScalarFieldEnum)[keyof typeof TransactionDocumentScalarFieldEnum]


  export const TransactionMilestoneScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    tenantId: 'tenantId',
    milestoneType: 'milestoneType',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionMilestoneScalarFieldEnum = (typeof TransactionMilestoneScalarFieldEnum)[keyof typeof TransactionMilestoneScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    status?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    domains?: TenantDomainListRelationFilter
    websiteConfig?: XOR<WebsiteConfigNullableScalarRelationFilter, WebsiteConfigWhereInput> | null
    controlSettings?: XOR<TenantControlSettingsNullableScalarRelationFilter, TenantControlSettingsWhereInput> | null
    billingSubscription?: XOR<TenantBillingSubscriptionNullableScalarRelationFilter, TenantBillingSubscriptionWhereInput> | null
    controlActors?: TenantControlActorListRelationFilter
    onboardingPlans?: TenantOnboardingPlanListRelationFilter
    onboardingTasks?: TenantOnboardingTaskListRelationFilter
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    activities?: ActivityListRelationFilter
    ingestedEvents?: IngestedEventListRelationFilter
    ingestionQueueJobs?: IngestionQueueJobListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domains?: TenantDomainOrderByRelationAggregateInput
    websiteConfig?: WebsiteConfigOrderByWithRelationInput
    controlSettings?: TenantControlSettingsOrderByWithRelationInput
    billingSubscription?: TenantBillingSubscriptionOrderByWithRelationInput
    controlActors?: TenantControlActorOrderByRelationAggregateInput
    onboardingPlans?: TenantOnboardingPlanOrderByRelationAggregateInput
    onboardingTasks?: TenantOnboardingTaskOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    ingestedEvents?: IngestedEventOrderByRelationAggregateInput
    ingestionQueueJobs?: IngestionQueueJobOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    status?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    domains?: TenantDomainListRelationFilter
    websiteConfig?: XOR<WebsiteConfigNullableScalarRelationFilter, WebsiteConfigWhereInput> | null
    controlSettings?: XOR<TenantControlSettingsNullableScalarRelationFilter, TenantControlSettingsWhereInput> | null
    billingSubscription?: XOR<TenantBillingSubscriptionNullableScalarRelationFilter, TenantBillingSubscriptionWhereInput> | null
    controlActors?: TenantControlActorListRelationFilter
    onboardingPlans?: TenantOnboardingPlanListRelationFilter
    onboardingTasks?: TenantOnboardingTaskListRelationFilter
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    activities?: ActivityListRelationFilter
    ingestedEvents?: IngestedEventListRelationFilter
    ingestionQueueJobs?: IngestionQueueJobListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    status?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantDomainWhereInput = {
    AND?: TenantDomainWhereInput | TenantDomainWhereInput[]
    OR?: TenantDomainWhereInput[]
    NOT?: TenantDomainWhereInput | TenantDomainWhereInput[]
    id?: StringFilter<"TenantDomain"> | string
    tenantId?: StringFilter<"TenantDomain"> | string
    hostname?: StringFilter<"TenantDomain"> | string
    hostnameNormalized?: StringFilter<"TenantDomain"> | string
    status?: StringFilter<"TenantDomain"> | string
    isPrimary?: BoolFilter<"TenantDomain"> | boolean
    isVerified?: BoolFilter<"TenantDomain"> | boolean
    verifiedAt?: DateTimeNullableFilter<"TenantDomain"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantDomain"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDomain"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantDomainOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hostname?: SortOrder
    hostnameNormalized?: SortOrder
    status?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantDomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hostnameNormalized?: string
    AND?: TenantDomainWhereInput | TenantDomainWhereInput[]
    OR?: TenantDomainWhereInput[]
    NOT?: TenantDomainWhereInput | TenantDomainWhereInput[]
    tenantId?: StringFilter<"TenantDomain"> | string
    hostname?: StringFilter<"TenantDomain"> | string
    status?: StringFilter<"TenantDomain"> | string
    isPrimary?: BoolFilter<"TenantDomain"> | boolean
    isVerified?: BoolFilter<"TenantDomain"> | boolean
    verifiedAt?: DateTimeNullableFilter<"TenantDomain"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantDomain"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDomain"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "hostnameNormalized">

  export type TenantDomainOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hostname?: SortOrder
    hostnameNormalized?: SortOrder
    status?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantDomainCountOrderByAggregateInput
    _max?: TenantDomainMaxOrderByAggregateInput
    _min?: TenantDomainMinOrderByAggregateInput
  }

  export type TenantDomainScalarWhereWithAggregatesInput = {
    AND?: TenantDomainScalarWhereWithAggregatesInput | TenantDomainScalarWhereWithAggregatesInput[]
    OR?: TenantDomainScalarWhereWithAggregatesInput[]
    NOT?: TenantDomainScalarWhereWithAggregatesInput | TenantDomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantDomain"> | string
    tenantId?: StringWithAggregatesFilter<"TenantDomain"> | string
    hostname?: StringWithAggregatesFilter<"TenantDomain"> | string
    hostnameNormalized?: StringWithAggregatesFilter<"TenantDomain"> | string
    status?: StringWithAggregatesFilter<"TenantDomain"> | string
    isPrimary?: BoolWithAggregatesFilter<"TenantDomain"> | boolean
    isVerified?: BoolWithAggregatesFilter<"TenantDomain"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"TenantDomain"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantDomain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantDomain"> | Date | string
  }

  export type WebsiteConfigWhereInput = {
    AND?: WebsiteConfigWhereInput | WebsiteConfigWhereInput[]
    OR?: WebsiteConfigWhereInput[]
    NOT?: WebsiteConfigWhereInput | WebsiteConfigWhereInput[]
    id?: StringFilter<"WebsiteConfig"> | string
    tenantId?: StringFilter<"WebsiteConfig"> | string
    createdAt?: DateTimeFilter<"WebsiteConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    modules?: ModuleConfigListRelationFilter
  }

  export type WebsiteConfigOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    modules?: ModuleConfigOrderByRelationAggregateInput
  }

  export type WebsiteConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: WebsiteConfigWhereInput | WebsiteConfigWhereInput[]
    OR?: WebsiteConfigWhereInput[]
    NOT?: WebsiteConfigWhereInput | WebsiteConfigWhereInput[]
    createdAt?: DateTimeFilter<"WebsiteConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WebsiteConfig"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    modules?: ModuleConfigListRelationFilter
  }, "id" | "tenantId">

  export type WebsiteConfigOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebsiteConfigCountOrderByAggregateInput
    _max?: WebsiteConfigMaxOrderByAggregateInput
    _min?: WebsiteConfigMinOrderByAggregateInput
  }

  export type WebsiteConfigScalarWhereWithAggregatesInput = {
    AND?: WebsiteConfigScalarWhereWithAggregatesInput | WebsiteConfigScalarWhereWithAggregatesInput[]
    OR?: WebsiteConfigScalarWhereWithAggregatesInput[]
    NOT?: WebsiteConfigScalarWhereWithAggregatesInput | WebsiteConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebsiteConfig"> | string
    tenantId?: StringWithAggregatesFilter<"WebsiteConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WebsiteConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebsiteConfig"> | Date | string
  }

  export type TenantControlSettingsWhereInput = {
    AND?: TenantControlSettingsWhereInput | TenantControlSettingsWhereInput[]
    OR?: TenantControlSettingsWhereInput[]
    NOT?: TenantControlSettingsWhereInput | TenantControlSettingsWhereInput[]
    id?: StringFilter<"TenantControlSettings"> | string
    tenantId?: StringFilter<"TenantControlSettings"> | string
    status?: StringFilter<"TenantControlSettings"> | string
    planCode?: StringFilter<"TenantControlSettings"> | string
    featureFlagsJson?: StringFilter<"TenantControlSettings"> | string
    createdAt?: DateTimeFilter<"TenantControlSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantControlSettings"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantControlSettingsOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    featureFlagsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantControlSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantControlSettingsWhereInput | TenantControlSettingsWhereInput[]
    OR?: TenantControlSettingsWhereInput[]
    NOT?: TenantControlSettingsWhereInput | TenantControlSettingsWhereInput[]
    status?: StringFilter<"TenantControlSettings"> | string
    planCode?: StringFilter<"TenantControlSettings"> | string
    featureFlagsJson?: StringFilter<"TenantControlSettings"> | string
    createdAt?: DateTimeFilter<"TenantControlSettings"> | Date | string
    updatedAt?: DateTimeFilter<"TenantControlSettings"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantControlSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    featureFlagsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantControlSettingsCountOrderByAggregateInput
    _max?: TenantControlSettingsMaxOrderByAggregateInput
    _min?: TenantControlSettingsMinOrderByAggregateInput
  }

  export type TenantControlSettingsScalarWhereWithAggregatesInput = {
    AND?: TenantControlSettingsScalarWhereWithAggregatesInput | TenantControlSettingsScalarWhereWithAggregatesInput[]
    OR?: TenantControlSettingsScalarWhereWithAggregatesInput[]
    NOT?: TenantControlSettingsScalarWhereWithAggregatesInput | TenantControlSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantControlSettings"> | string
    tenantId?: StringWithAggregatesFilter<"TenantControlSettings"> | string
    status?: StringWithAggregatesFilter<"TenantControlSettings"> | string
    planCode?: StringWithAggregatesFilter<"TenantControlSettings"> | string
    featureFlagsJson?: StringWithAggregatesFilter<"TenantControlSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TenantControlSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantControlSettings"> | Date | string
  }

  export type TenantBillingSubscriptionWhereInput = {
    AND?: TenantBillingSubscriptionWhereInput | TenantBillingSubscriptionWhereInput[]
    OR?: TenantBillingSubscriptionWhereInput[]
    NOT?: TenantBillingSubscriptionWhereInput | TenantBillingSubscriptionWhereInput[]
    id?: StringFilter<"TenantBillingSubscription"> | string
    tenantId?: StringFilter<"TenantBillingSubscription"> | string
    planCode?: StringFilter<"TenantBillingSubscription"> | string
    status?: StringFilter<"TenantBillingSubscription"> | string
    paymentStatus?: StringFilter<"TenantBillingSubscription"> | string
    billingProvider?: StringFilter<"TenantBillingSubscription"> | string
    billingCustomerId?: StringNullableFilter<"TenantBillingSubscription"> | string | null
    billingSubscriptionId?: StringNullableFilter<"TenantBillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"TenantBillingSubscription"> | Date | string | null
    currentPeriodEndsAt?: DateTimeNullableFilter<"TenantBillingSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"TenantBillingSubscription"> | boolean
    createdAt?: DateTimeFilter<"TenantBillingSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"TenantBillingSubscription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantBillingSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planCode?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    billingProvider?: SortOrder
    billingCustomerId?: SortOrderInput | SortOrder
    billingSubscriptionId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodEndsAt?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantBillingSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId?: string
    AND?: TenantBillingSubscriptionWhereInput | TenantBillingSubscriptionWhereInput[]
    OR?: TenantBillingSubscriptionWhereInput[]
    NOT?: TenantBillingSubscriptionWhereInput | TenantBillingSubscriptionWhereInput[]
    planCode?: StringFilter<"TenantBillingSubscription"> | string
    status?: StringFilter<"TenantBillingSubscription"> | string
    paymentStatus?: StringFilter<"TenantBillingSubscription"> | string
    billingProvider?: StringFilter<"TenantBillingSubscription"> | string
    billingCustomerId?: StringNullableFilter<"TenantBillingSubscription"> | string | null
    billingSubscriptionId?: StringNullableFilter<"TenantBillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableFilter<"TenantBillingSubscription"> | Date | string | null
    currentPeriodEndsAt?: DateTimeNullableFilter<"TenantBillingSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"TenantBillingSubscription"> | boolean
    createdAt?: DateTimeFilter<"TenantBillingSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"TenantBillingSubscription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId">

  export type TenantBillingSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planCode?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    billingProvider?: SortOrder
    billingCustomerId?: SortOrderInput | SortOrder
    billingSubscriptionId?: SortOrderInput | SortOrder
    trialEndsAt?: SortOrderInput | SortOrder
    currentPeriodEndsAt?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantBillingSubscriptionCountOrderByAggregateInput
    _max?: TenantBillingSubscriptionMaxOrderByAggregateInput
    _min?: TenantBillingSubscriptionMinOrderByAggregateInput
  }

  export type TenantBillingSubscriptionScalarWhereWithAggregatesInput = {
    AND?: TenantBillingSubscriptionScalarWhereWithAggregatesInput | TenantBillingSubscriptionScalarWhereWithAggregatesInput[]
    OR?: TenantBillingSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: TenantBillingSubscriptionScalarWhereWithAggregatesInput | TenantBillingSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    tenantId?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    planCode?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    status?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    paymentStatus?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    billingProvider?: StringWithAggregatesFilter<"TenantBillingSubscription"> | string
    billingCustomerId?: StringNullableWithAggregatesFilter<"TenantBillingSubscription"> | string | null
    billingSubscriptionId?: StringNullableWithAggregatesFilter<"TenantBillingSubscription"> | string | null
    trialEndsAt?: DateTimeNullableWithAggregatesFilter<"TenantBillingSubscription"> | Date | string | null
    currentPeriodEndsAt?: DateTimeNullableWithAggregatesFilter<"TenantBillingSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"TenantBillingSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TenantBillingSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantBillingSubscription"> | Date | string
  }

  export type TenantBillingSyncEventWhereInput = {
    AND?: TenantBillingSyncEventWhereInput | TenantBillingSyncEventWhereInput[]
    OR?: TenantBillingSyncEventWhereInput[]
    NOT?: TenantBillingSyncEventWhereInput | TenantBillingSyncEventWhereInput[]
    id?: StringFilter<"TenantBillingSyncEvent"> | string
    tenantId?: StringNullableFilter<"TenantBillingSyncEvent"> | string | null
    provider?: StringFilter<"TenantBillingSyncEvent"> | string
    eventId?: StringFilter<"TenantBillingSyncEvent"> | string
    eventType?: StringFilter<"TenantBillingSyncEvent"> | string
    payloadJson?: StringFilter<"TenantBillingSyncEvent"> | string
    resultStatus?: StringFilter<"TenantBillingSyncEvent"> | string
    resultMessage?: StringNullableFilter<"TenantBillingSyncEvent"> | string | null
    createdAt?: DateTimeFilter<"TenantBillingSyncEvent"> | Date | string
    processedAt?: DateTimeFilter<"TenantBillingSyncEvent"> | Date | string
  }

  export type TenantBillingSyncEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payloadJson?: SortOrder
    resultStatus?: SortOrder
    resultMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TenantBillingSyncEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_eventId?: TenantBillingSyncEventProviderEventIdCompoundUniqueInput
    AND?: TenantBillingSyncEventWhereInput | TenantBillingSyncEventWhereInput[]
    OR?: TenantBillingSyncEventWhereInput[]
    NOT?: TenantBillingSyncEventWhereInput | TenantBillingSyncEventWhereInput[]
    tenantId?: StringNullableFilter<"TenantBillingSyncEvent"> | string | null
    provider?: StringFilter<"TenantBillingSyncEvent"> | string
    eventId?: StringFilter<"TenantBillingSyncEvent"> | string
    eventType?: StringFilter<"TenantBillingSyncEvent"> | string
    payloadJson?: StringFilter<"TenantBillingSyncEvent"> | string
    resultStatus?: StringFilter<"TenantBillingSyncEvent"> | string
    resultMessage?: StringNullableFilter<"TenantBillingSyncEvent"> | string | null
    createdAt?: DateTimeFilter<"TenantBillingSyncEvent"> | Date | string
    processedAt?: DateTimeFilter<"TenantBillingSyncEvent"> | Date | string
  }, "id" | "provider_eventId">

  export type TenantBillingSyncEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payloadJson?: SortOrder
    resultStatus?: SortOrder
    resultMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    _count?: TenantBillingSyncEventCountOrderByAggregateInput
    _max?: TenantBillingSyncEventMaxOrderByAggregateInput
    _min?: TenantBillingSyncEventMinOrderByAggregateInput
  }

  export type TenantBillingSyncEventScalarWhereWithAggregatesInput = {
    AND?: TenantBillingSyncEventScalarWhereWithAggregatesInput | TenantBillingSyncEventScalarWhereWithAggregatesInput[]
    OR?: TenantBillingSyncEventScalarWhereWithAggregatesInput[]
    NOT?: TenantBillingSyncEventScalarWhereWithAggregatesInput | TenantBillingSyncEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    tenantId?: StringNullableWithAggregatesFilter<"TenantBillingSyncEvent"> | string | null
    provider?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    eventId?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    eventType?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    payloadJson?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    resultStatus?: StringWithAggregatesFilter<"TenantBillingSyncEvent"> | string
    resultMessage?: StringNullableWithAggregatesFilter<"TenantBillingSyncEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantBillingSyncEvent"> | Date | string
    processedAt?: DateTimeWithAggregatesFilter<"TenantBillingSyncEvent"> | Date | string
  }

  export type TenantControlActorWhereInput = {
    AND?: TenantControlActorWhereInput | TenantControlActorWhereInput[]
    OR?: TenantControlActorWhereInput[]
    NOT?: TenantControlActorWhereInput | TenantControlActorWhereInput[]
    id?: StringFilter<"TenantControlActor"> | string
    tenantId?: StringFilter<"TenantControlActor"> | string
    actorId?: StringFilter<"TenantControlActor"> | string
    displayName?: StringNullableFilter<"TenantControlActor"> | string | null
    email?: StringNullableFilter<"TenantControlActor"> | string | null
    role?: StringFilter<"TenantControlActor"> | string
    permissionsJson?: StringFilter<"TenantControlActor"> | string
    supportSessionActive?: BoolFilter<"TenantControlActor"> | boolean
    supportSessionStartedAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    supportSessionExpiresAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantControlActor"> | Date | string
    updatedAt?: DateTimeFilter<"TenantControlActor"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantControlActorOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    permissionsJson?: SortOrder
    supportSessionActive?: SortOrder
    supportSessionStartedAt?: SortOrderInput | SortOrder
    supportSessionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantControlActorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_actorId?: TenantControlActorTenantIdActorIdCompoundUniqueInput
    AND?: TenantControlActorWhereInput | TenantControlActorWhereInput[]
    OR?: TenantControlActorWhereInput[]
    NOT?: TenantControlActorWhereInput | TenantControlActorWhereInput[]
    tenantId?: StringFilter<"TenantControlActor"> | string
    actorId?: StringFilter<"TenantControlActor"> | string
    displayName?: StringNullableFilter<"TenantControlActor"> | string | null
    email?: StringNullableFilter<"TenantControlActor"> | string | null
    role?: StringFilter<"TenantControlActor"> | string
    permissionsJson?: StringFilter<"TenantControlActor"> | string
    supportSessionActive?: BoolFilter<"TenantControlActor"> | boolean
    supportSessionStartedAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    supportSessionExpiresAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantControlActor"> | Date | string
    updatedAt?: DateTimeFilter<"TenantControlActor"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_actorId">

  export type TenantControlActorOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrder
    permissionsJson?: SortOrder
    supportSessionActive?: SortOrder
    supportSessionStartedAt?: SortOrderInput | SortOrder
    supportSessionExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantControlActorCountOrderByAggregateInput
    _max?: TenantControlActorMaxOrderByAggregateInput
    _min?: TenantControlActorMinOrderByAggregateInput
  }

  export type TenantControlActorScalarWhereWithAggregatesInput = {
    AND?: TenantControlActorScalarWhereWithAggregatesInput | TenantControlActorScalarWhereWithAggregatesInput[]
    OR?: TenantControlActorScalarWhereWithAggregatesInput[]
    NOT?: TenantControlActorScalarWhereWithAggregatesInput | TenantControlActorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantControlActor"> | string
    tenantId?: StringWithAggregatesFilter<"TenantControlActor"> | string
    actorId?: StringWithAggregatesFilter<"TenantControlActor"> | string
    displayName?: StringNullableWithAggregatesFilter<"TenantControlActor"> | string | null
    email?: StringNullableWithAggregatesFilter<"TenantControlActor"> | string | null
    role?: StringWithAggregatesFilter<"TenantControlActor"> | string
    permissionsJson?: StringWithAggregatesFilter<"TenantControlActor"> | string
    supportSessionActive?: BoolWithAggregatesFilter<"TenantControlActor"> | boolean
    supportSessionStartedAt?: DateTimeNullableWithAggregatesFilter<"TenantControlActor"> | Date | string | null
    supportSessionExpiresAt?: DateTimeNullableWithAggregatesFilter<"TenantControlActor"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantControlActor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantControlActor"> | Date | string
  }

  export type TenantOnboardingPlanWhereInput = {
    AND?: TenantOnboardingPlanWhereInput | TenantOnboardingPlanWhereInput[]
    OR?: TenantOnboardingPlanWhereInput[]
    NOT?: TenantOnboardingPlanWhereInput | TenantOnboardingPlanWhereInput[]
    id?: StringFilter<"TenantOnboardingPlan"> | string
    tenantId?: StringFilter<"TenantOnboardingPlan"> | string
    status?: StringFilter<"TenantOnboardingPlan"> | string
    planCode?: StringFilter<"TenantOnboardingPlan"> | string
    startedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    targetLaunchDate?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pauseReason?: StringNullableFilter<"TenantOnboardingPlan"> | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tasks?: TenantOnboardingTaskListRelationFilter
  }

  export type TenantOnboardingPlanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    targetLaunchDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    tasks?: TenantOnboardingTaskOrderByRelationAggregateInput
  }

  export type TenantOnboardingPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantOnboardingPlanWhereInput | TenantOnboardingPlanWhereInput[]
    OR?: TenantOnboardingPlanWhereInput[]
    NOT?: TenantOnboardingPlanWhereInput | TenantOnboardingPlanWhereInput[]
    tenantId?: StringFilter<"TenantOnboardingPlan"> | string
    status?: StringFilter<"TenantOnboardingPlan"> | string
    planCode?: StringFilter<"TenantOnboardingPlan"> | string
    startedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    targetLaunchDate?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pauseReason?: StringNullableFilter<"TenantOnboardingPlan"> | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    tasks?: TenantOnboardingTaskListRelationFilter
  }, "id">

  export type TenantOnboardingPlanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    targetLaunchDate?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    pausedAt?: SortOrderInput | SortOrder
    pauseReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantOnboardingPlanCountOrderByAggregateInput
    _max?: TenantOnboardingPlanMaxOrderByAggregateInput
    _min?: TenantOnboardingPlanMinOrderByAggregateInput
  }

  export type TenantOnboardingPlanScalarWhereWithAggregatesInput = {
    AND?: TenantOnboardingPlanScalarWhereWithAggregatesInput | TenantOnboardingPlanScalarWhereWithAggregatesInput[]
    OR?: TenantOnboardingPlanScalarWhereWithAggregatesInput[]
    NOT?: TenantOnboardingPlanScalarWhereWithAggregatesInput | TenantOnboardingPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantOnboardingPlan"> | string
    tenantId?: StringWithAggregatesFilter<"TenantOnboardingPlan"> | string
    status?: StringWithAggregatesFilter<"TenantOnboardingPlan"> | string
    planCode?: StringWithAggregatesFilter<"TenantOnboardingPlan"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string | null
    targetLaunchDate?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string | null
    pausedAt?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string | null
    pauseReason?: StringNullableWithAggregatesFilter<"TenantOnboardingPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantOnboardingPlan"> | Date | string
  }

  export type TenantOnboardingTaskWhereInput = {
    AND?: TenantOnboardingTaskWhereInput | TenantOnboardingTaskWhereInput[]
    OR?: TenantOnboardingTaskWhereInput[]
    NOT?: TenantOnboardingTaskWhereInput | TenantOnboardingTaskWhereInput[]
    id?: StringFilter<"TenantOnboardingTask"> | string
    tenantOnboardingPlanId?: StringFilter<"TenantOnboardingTask"> | string
    tenantId?: StringFilter<"TenantOnboardingTask"> | string
    taskKey?: StringFilter<"TenantOnboardingTask"> | string
    title?: StringFilter<"TenantOnboardingTask"> | string
    description?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    status?: StringFilter<"TenantOnboardingTask"> | string
    priority?: StringFilter<"TenantOnboardingTask"> | string
    required?: BoolFilter<"TenantOnboardingTask"> | boolean
    ownerRole?: StringFilter<"TenantOnboardingTask"> | string
    ownerActorId?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    dueAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    blockedByClient?: BoolFilter<"TenantOnboardingTask"> | boolean
    blockerReason?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    sortOrder?: IntFilter<"TenantOnboardingTask"> | number
    completedAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    onboardingPlan?: XOR<TenantOnboardingPlanScalarRelationFilter, TenantOnboardingPlanWhereInput>
  }

  export type TenantOnboardingTaskOrderByWithRelationInput = {
    id?: SortOrder
    tenantOnboardingPlanId?: SortOrder
    tenantId?: SortOrder
    taskKey?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    required?: SortOrder
    ownerRole?: SortOrder
    ownerActorId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    blockedByClient?: SortOrder
    blockerReason?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    onboardingPlan?: TenantOnboardingPlanOrderByWithRelationInput
  }

  export type TenantOnboardingTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantOnboardingPlanId_taskKey?: TenantOnboardingTaskTenantOnboardingPlanIdTaskKeyCompoundUniqueInput
    AND?: TenantOnboardingTaskWhereInput | TenantOnboardingTaskWhereInput[]
    OR?: TenantOnboardingTaskWhereInput[]
    NOT?: TenantOnboardingTaskWhereInput | TenantOnboardingTaskWhereInput[]
    tenantOnboardingPlanId?: StringFilter<"TenantOnboardingTask"> | string
    tenantId?: StringFilter<"TenantOnboardingTask"> | string
    taskKey?: StringFilter<"TenantOnboardingTask"> | string
    title?: StringFilter<"TenantOnboardingTask"> | string
    description?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    status?: StringFilter<"TenantOnboardingTask"> | string
    priority?: StringFilter<"TenantOnboardingTask"> | string
    required?: BoolFilter<"TenantOnboardingTask"> | boolean
    ownerRole?: StringFilter<"TenantOnboardingTask"> | string
    ownerActorId?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    dueAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    blockedByClient?: BoolFilter<"TenantOnboardingTask"> | boolean
    blockerReason?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    sortOrder?: IntFilter<"TenantOnboardingTask"> | number
    completedAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    onboardingPlan?: XOR<TenantOnboardingPlanScalarRelationFilter, TenantOnboardingPlanWhereInput>
  }, "id" | "tenantOnboardingPlanId_taskKey">

  export type TenantOnboardingTaskOrderByWithAggregationInput = {
    id?: SortOrder
    tenantOnboardingPlanId?: SortOrder
    tenantId?: SortOrder
    taskKey?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    required?: SortOrder
    ownerRole?: SortOrder
    ownerActorId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    blockedByClient?: SortOrder
    blockerReason?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantOnboardingTaskCountOrderByAggregateInput
    _avg?: TenantOnboardingTaskAvgOrderByAggregateInput
    _max?: TenantOnboardingTaskMaxOrderByAggregateInput
    _min?: TenantOnboardingTaskMinOrderByAggregateInput
    _sum?: TenantOnboardingTaskSumOrderByAggregateInput
  }

  export type TenantOnboardingTaskScalarWhereWithAggregatesInput = {
    AND?: TenantOnboardingTaskScalarWhereWithAggregatesInput | TenantOnboardingTaskScalarWhereWithAggregatesInput[]
    OR?: TenantOnboardingTaskScalarWhereWithAggregatesInput[]
    NOT?: TenantOnboardingTaskScalarWhereWithAggregatesInput | TenantOnboardingTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    tenantOnboardingPlanId?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    tenantId?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    taskKey?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    title?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    description?: StringNullableWithAggregatesFilter<"TenantOnboardingTask"> | string | null
    status?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    priority?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    required?: BoolWithAggregatesFilter<"TenantOnboardingTask"> | boolean
    ownerRole?: StringWithAggregatesFilter<"TenantOnboardingTask"> | string
    ownerActorId?: StringNullableWithAggregatesFilter<"TenantOnboardingTask"> | string | null
    dueAt?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingTask"> | Date | string | null
    blockedByClient?: BoolWithAggregatesFilter<"TenantOnboardingTask"> | boolean
    blockerReason?: StringNullableWithAggregatesFilter<"TenantOnboardingTask"> | string | null
    sortOrder?: IntWithAggregatesFilter<"TenantOnboardingTask"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"TenantOnboardingTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TenantOnboardingTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TenantOnboardingTask"> | Date | string
  }

  export type ModuleConfigWhereInput = {
    AND?: ModuleConfigWhereInput | ModuleConfigWhereInput[]
    OR?: ModuleConfigWhereInput[]
    NOT?: ModuleConfigWhereInput | ModuleConfigWhereInput[]
    id?: StringFilter<"ModuleConfig"> | string
    websiteConfigId?: StringFilter<"ModuleConfig"> | string
    tenantId?: StringFilter<"ModuleConfig"> | string
    moduleKey?: StringFilter<"ModuleConfig"> | string
    enabled?: BoolFilter<"ModuleConfig"> | boolean
    sortOrder?: IntFilter<"ModuleConfig"> | number
    createdAt?: DateTimeFilter<"ModuleConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleConfig"> | Date | string
    websiteConfig?: XOR<WebsiteConfigScalarRelationFilter, WebsiteConfigWhereInput>
  }

  export type ModuleConfigOrderByWithRelationInput = {
    id?: SortOrder
    websiteConfigId?: SortOrder
    tenantId?: SortOrder
    moduleKey?: SortOrder
    enabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    websiteConfig?: WebsiteConfigOrderByWithRelationInput
  }

  export type ModuleConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    websiteConfigId_moduleKey?: ModuleConfigWebsiteConfigIdModuleKeyCompoundUniqueInput
    AND?: ModuleConfigWhereInput | ModuleConfigWhereInput[]
    OR?: ModuleConfigWhereInput[]
    NOT?: ModuleConfigWhereInput | ModuleConfigWhereInput[]
    websiteConfigId?: StringFilter<"ModuleConfig"> | string
    tenantId?: StringFilter<"ModuleConfig"> | string
    moduleKey?: StringFilter<"ModuleConfig"> | string
    enabled?: BoolFilter<"ModuleConfig"> | boolean
    sortOrder?: IntFilter<"ModuleConfig"> | number
    createdAt?: DateTimeFilter<"ModuleConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleConfig"> | Date | string
    websiteConfig?: XOR<WebsiteConfigScalarRelationFilter, WebsiteConfigWhereInput>
  }, "id" | "websiteConfigId_moduleKey">

  export type ModuleConfigOrderByWithAggregationInput = {
    id?: SortOrder
    websiteConfigId?: SortOrder
    tenantId?: SortOrder
    moduleKey?: SortOrder
    enabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleConfigCountOrderByAggregateInput
    _avg?: ModuleConfigAvgOrderByAggregateInput
    _max?: ModuleConfigMaxOrderByAggregateInput
    _min?: ModuleConfigMinOrderByAggregateInput
    _sum?: ModuleConfigSumOrderByAggregateInput
  }

  export type ModuleConfigScalarWhereWithAggregatesInput = {
    AND?: ModuleConfigScalarWhereWithAggregatesInput | ModuleConfigScalarWhereWithAggregatesInput[]
    OR?: ModuleConfigScalarWhereWithAggregatesInput[]
    NOT?: ModuleConfigScalarWhereWithAggregatesInput | ModuleConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuleConfig"> | string
    websiteConfigId?: StringWithAggregatesFilter<"ModuleConfig"> | string
    tenantId?: StringWithAggregatesFilter<"ModuleConfig"> | string
    moduleKey?: StringWithAggregatesFilter<"ModuleConfig"> | string
    enabled?: BoolWithAggregatesFilter<"ModuleConfig"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ModuleConfig"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ModuleConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModuleConfig"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    tenantId?: StringFilter<"Contact"> | string
    fullName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    emailNormalized?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    phoneNormalized?: StringNullableFilter<"Contact"> | string | null
    source?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    leads?: LeadListRelationFilter
    activities?: ActivityListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailNormalized?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneNormalized?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    leads?: LeadOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_emailNormalized?: ContactTenantIdEmailNormalizedCompoundUniqueInput
    tenantId_phoneNormalized?: ContactTenantIdPhoneNormalizedCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    tenantId?: StringFilter<"Contact"> | string
    fullName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    emailNormalized?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    phoneNormalized?: StringNullableFilter<"Contact"> | string | null
    source?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    leads?: LeadListRelationFilter
    activities?: ActivityListRelationFilter
  }, "id" | "tenantId_emailNormalized" | "tenantId_phoneNormalized">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailNormalized?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneNormalized?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    tenantId?: StringWithAggregatesFilter<"Contact"> | string
    fullName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    emailNormalized?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phoneNormalized?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    source?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    leadType?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    timeframe?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    listingId?: StringNullableFilter<"Lead"> | string | null
    listingUrl?: StringNullableFilter<"Lead"> | string | null
    listingAddress?: StringNullableFilter<"Lead"> | string | null
    propertyType?: StringNullableFilter<"Lead"> | string | null
    beds?: IntNullableFilter<"Lead"> | number | null
    baths?: IntNullableFilter<"Lead"> | number | null
    sqft?: IntNullableFilter<"Lead"> | number | null
    lastContactAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionNote?: StringNullableFilter<"Lead"> | string | null
    nextActionChannel?: StringNullableFilter<"Lead"> | string | null
    reminderSnoozedUntil?: DateTimeNullableFilter<"Lead"> | Date | string | null
    priceMin?: IntNullableFilter<"Lead"> | number | null
    priceMax?: IntNullableFilter<"Lead"> | number | null
    tags?: StringFilter<"Lead"> | string
    closeReason?: StringNullableFilter<"Lead"> | string | null
    closeNotes?: StringNullableFilter<"Lead"> | string | null
    closedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    assignedTo?: StringNullableFilter<"Lead"> | string | null
    referredBy?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    activities?: ActivityListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    status?: SortOrder
    leadType?: SortOrder
    source?: SortOrder
    timeframe?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    listingId?: SortOrderInput | SortOrder
    listingUrl?: SortOrderInput | SortOrder
    listingAddress?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    beds?: SortOrderInput | SortOrder
    baths?: SortOrderInput | SortOrder
    sqft?: SortOrderInput | SortOrder
    lastContactAt?: SortOrderInput | SortOrder
    nextActionAt?: SortOrderInput | SortOrder
    nextActionNote?: SortOrderInput | SortOrder
    nextActionChannel?: SortOrderInput | SortOrder
    reminderSnoozedUntil?: SortOrderInput | SortOrder
    priceMin?: SortOrderInput | SortOrder
    priceMax?: SortOrderInput | SortOrder
    tags?: SortOrder
    closeReason?: SortOrderInput | SortOrder
    closeNotes?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    leadType?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    timeframe?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    listingId?: StringNullableFilter<"Lead"> | string | null
    listingUrl?: StringNullableFilter<"Lead"> | string | null
    listingAddress?: StringNullableFilter<"Lead"> | string | null
    propertyType?: StringNullableFilter<"Lead"> | string | null
    beds?: IntNullableFilter<"Lead"> | number | null
    baths?: IntNullableFilter<"Lead"> | number | null
    sqft?: IntNullableFilter<"Lead"> | number | null
    lastContactAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionNote?: StringNullableFilter<"Lead"> | string | null
    nextActionChannel?: StringNullableFilter<"Lead"> | string | null
    reminderSnoozedUntil?: DateTimeNullableFilter<"Lead"> | Date | string | null
    priceMin?: IntNullableFilter<"Lead"> | number | null
    priceMax?: IntNullableFilter<"Lead"> | number | null
    tags?: StringFilter<"Lead"> | string
    closeReason?: StringNullableFilter<"Lead"> | string | null
    closeNotes?: StringNullableFilter<"Lead"> | string | null
    closedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    assignedTo?: StringNullableFilter<"Lead"> | string | null
    referredBy?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    activities?: ActivityListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    status?: SortOrder
    leadType?: SortOrder
    source?: SortOrder
    timeframe?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    listingId?: SortOrderInput | SortOrder
    listingUrl?: SortOrderInput | SortOrder
    listingAddress?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    beds?: SortOrderInput | SortOrder
    baths?: SortOrderInput | SortOrder
    sqft?: SortOrderInput | SortOrder
    lastContactAt?: SortOrderInput | SortOrder
    nextActionAt?: SortOrderInput | SortOrder
    nextActionNote?: SortOrderInput | SortOrder
    nextActionChannel?: SortOrderInput | SortOrder
    reminderSnoozedUntil?: SortOrderInput | SortOrder
    priceMin?: SortOrderInput | SortOrder
    priceMax?: SortOrderInput | SortOrder
    tags?: SortOrder
    closeReason?: SortOrderInput | SortOrder
    closeNotes?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    referredBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    tenantId?: StringWithAggregatesFilter<"Lead"> | string
    contactId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    status?: StringWithAggregatesFilter<"Lead"> | string
    leadType?: StringWithAggregatesFilter<"Lead"> | string
    source?: StringWithAggregatesFilter<"Lead"> | string
    timeframe?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    listingId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    listingUrl?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    listingAddress?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    propertyType?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    beds?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    baths?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    sqft?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    lastContactAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    nextActionAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    nextActionNote?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    nextActionChannel?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    reminderSnoozedUntil?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    priceMin?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    priceMax?: IntNullableWithAggregatesFilter<"Lead"> | number | null
    tags?: StringWithAggregatesFilter<"Lead"> | string
    closeReason?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    closeNotes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    referredBy?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    tenantId?: StringFilter<"Activity"> | string
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    activityType?: StringFilter<"Activity"> | string
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    summary?: StringFilter<"Activity"> | string
    metadataJson?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    activityType?: SortOrder
    occurredAt?: SortOrder
    summary?: SortOrder
    metadataJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    tenantId?: StringFilter<"Activity"> | string
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    activityType?: StringFilter<"Activity"> | string
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    summary?: StringFilter<"Activity"> | string
    metadataJson?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    leadId?: SortOrderInput | SortOrder
    activityType?: SortOrder
    occurredAt?: SortOrder
    summary?: SortOrder
    metadataJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    tenantId?: StringWithAggregatesFilter<"Activity"> | string
    contactId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    leadId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    activityType?: StringWithAggregatesFilter<"Activity"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    summary?: StringWithAggregatesFilter<"Activity"> | string
    metadataJson?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type IngestedEventWhereInput = {
    AND?: IngestedEventWhereInput | IngestedEventWhereInput[]
    OR?: IngestedEventWhereInput[]
    NOT?: IngestedEventWhereInput | IngestedEventWhereInput[]
    id?: StringFilter<"IngestedEvent"> | string
    tenantId?: StringFilter<"IngestedEvent"> | string
    eventType?: StringFilter<"IngestedEvent"> | string
    eventKey?: StringFilter<"IngestedEvent"> | string
    occurredAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    payloadJson?: StringFilter<"IngestedEvent"> | string
    processedAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    createdAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type IngestedEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type IngestedEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_eventKey?: IngestedEventTenantIdEventKeyCompoundUniqueInput
    AND?: IngestedEventWhereInput | IngestedEventWhereInput[]
    OR?: IngestedEventWhereInput[]
    NOT?: IngestedEventWhereInput | IngestedEventWhereInput[]
    tenantId?: StringFilter<"IngestedEvent"> | string
    eventType?: StringFilter<"IngestedEvent"> | string
    eventKey?: StringFilter<"IngestedEvent"> | string
    occurredAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    payloadJson?: StringFilter<"IngestedEvent"> | string
    processedAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    createdAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_eventKey">

  export type IngestedEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    _count?: IngestedEventCountOrderByAggregateInput
    _max?: IngestedEventMaxOrderByAggregateInput
    _min?: IngestedEventMinOrderByAggregateInput
  }

  export type IngestedEventScalarWhereWithAggregatesInput = {
    AND?: IngestedEventScalarWhereWithAggregatesInput | IngestedEventScalarWhereWithAggregatesInput[]
    OR?: IngestedEventScalarWhereWithAggregatesInput[]
    NOT?: IngestedEventScalarWhereWithAggregatesInput | IngestedEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngestedEvent"> | string
    tenantId?: StringWithAggregatesFilter<"IngestedEvent"> | string
    eventType?: StringWithAggregatesFilter<"IngestedEvent"> | string
    eventKey?: StringWithAggregatesFilter<"IngestedEvent"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"IngestedEvent"> | Date | string
    payloadJson?: StringWithAggregatesFilter<"IngestedEvent"> | string
    processedAt?: DateTimeWithAggregatesFilter<"IngestedEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"IngestedEvent"> | Date | string
  }

  export type IngestionQueueJobWhereInput = {
    AND?: IngestionQueueJobWhereInput | IngestionQueueJobWhereInput[]
    OR?: IngestionQueueJobWhereInput[]
    NOT?: IngestionQueueJobWhereInput | IngestionQueueJobWhereInput[]
    id?: StringFilter<"IngestionQueueJob"> | string
    tenantId?: StringFilter<"IngestionQueueJob"> | string
    eventType?: StringFilter<"IngestionQueueJob"> | string
    eventKey?: StringFilter<"IngestionQueueJob"> | string
    occurredAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    payloadJson?: StringFilter<"IngestionQueueJob"> | string
    status?: StringFilter<"IngestionQueueJob"> | string
    attemptCount?: IntFilter<"IngestionQueueJob"> | number
    lastError?: StringNullableFilter<"IngestionQueueJob"> | string | null
    createdAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    processedAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
    nextAttemptAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    deadLetteredAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type IngestionQueueJobOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrder
    deadLetteredAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type IngestionQueueJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_eventKey?: IngestionQueueJobTenantIdEventKeyCompoundUniqueInput
    AND?: IngestionQueueJobWhereInput | IngestionQueueJobWhereInput[]
    OR?: IngestionQueueJobWhereInput[]
    NOT?: IngestionQueueJobWhereInput | IngestionQueueJobWhereInput[]
    tenantId?: StringFilter<"IngestionQueueJob"> | string
    eventType?: StringFilter<"IngestionQueueJob"> | string
    eventKey?: StringFilter<"IngestionQueueJob"> | string
    occurredAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    payloadJson?: StringFilter<"IngestionQueueJob"> | string
    status?: StringFilter<"IngestionQueueJob"> | string
    attemptCount?: IntFilter<"IngestionQueueJob"> | number
    lastError?: StringNullableFilter<"IngestionQueueJob"> | string | null
    createdAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    processedAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
    nextAttemptAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    deadLetteredAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_eventKey">

  export type IngestionQueueJobOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    nextAttemptAt?: SortOrder
    deadLetteredAt?: SortOrderInput | SortOrder
    _count?: IngestionQueueJobCountOrderByAggregateInput
    _avg?: IngestionQueueJobAvgOrderByAggregateInput
    _max?: IngestionQueueJobMaxOrderByAggregateInput
    _min?: IngestionQueueJobMinOrderByAggregateInput
    _sum?: IngestionQueueJobSumOrderByAggregateInput
  }

  export type IngestionQueueJobScalarWhereWithAggregatesInput = {
    AND?: IngestionQueueJobScalarWhereWithAggregatesInput | IngestionQueueJobScalarWhereWithAggregatesInput[]
    OR?: IngestionQueueJobScalarWhereWithAggregatesInput[]
    NOT?: IngestionQueueJobScalarWhereWithAggregatesInput | IngestionQueueJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    tenantId?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    eventType?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    eventKey?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    occurredAt?: DateTimeWithAggregatesFilter<"IngestionQueueJob"> | Date | string
    payloadJson?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    status?: StringWithAggregatesFilter<"IngestionQueueJob"> | string
    attemptCount?: IntWithAggregatesFilter<"IngestionQueueJob"> | number
    lastError?: StringNullableWithAggregatesFilter<"IngestionQueueJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IngestionQueueJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IngestionQueueJob"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"IngestionQueueJob"> | Date | string | null
    nextAttemptAt?: DateTimeWithAggregatesFilter<"IngestionQueueJob"> | Date | string
    deadLetteredAt?: DateTimeNullableWithAggregatesFilter<"IngestionQueueJob"> | Date | string | null
  }

  export type AdminAuditEventWhereInput = {
    AND?: AdminAuditEventWhereInput | AdminAuditEventWhereInput[]
    OR?: AdminAuditEventWhereInput[]
    NOT?: AdminAuditEventWhereInput | AdminAuditEventWhereInput[]
    id?: StringFilter<"AdminAuditEvent"> | string
    tenantId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    domainId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    action?: StringFilter<"AdminAuditEvent"> | string
    status?: StringFilter<"AdminAuditEvent"> | string
    actorId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    actorRole?: StringFilter<"AdminAuditEvent"> | string
    error?: StringNullableFilter<"AdminAuditEvent"> | string | null
    metadataJson?: StringNullableFilter<"AdminAuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditEvent"> | Date | string
  }

  export type AdminAuditEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    action?: SortOrder
    status?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actorRole?: SortOrder
    error?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditEventWhereInput | AdminAuditEventWhereInput[]
    OR?: AdminAuditEventWhereInput[]
    NOT?: AdminAuditEventWhereInput | AdminAuditEventWhereInput[]
    tenantId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    domainId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    action?: StringFilter<"AdminAuditEvent"> | string
    status?: StringFilter<"AdminAuditEvent"> | string
    actorId?: StringNullableFilter<"AdminAuditEvent"> | string | null
    actorRole?: StringFilter<"AdminAuditEvent"> | string
    error?: StringNullableFilter<"AdminAuditEvent"> | string | null
    metadataJson?: StringNullableFilter<"AdminAuditEvent"> | string | null
    createdAt?: DateTimeFilter<"AdminAuditEvent"> | Date | string
  }, "id">

  export type AdminAuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    action?: SortOrder
    status?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actorRole?: SortOrder
    error?: SortOrderInput | SortOrder
    metadataJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditEventCountOrderByAggregateInput
    _max?: AdminAuditEventMaxOrderByAggregateInput
    _min?: AdminAuditEventMinOrderByAggregateInput
  }

  export type AdminAuditEventScalarWhereWithAggregatesInput = {
    AND?: AdminAuditEventScalarWhereWithAggregatesInput | AdminAuditEventScalarWhereWithAggregatesInput[]
    OR?: AdminAuditEventScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditEventScalarWhereWithAggregatesInput | AdminAuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditEvent"> | string
    tenantId?: StringNullableWithAggregatesFilter<"AdminAuditEvent"> | string | null
    domainId?: StringNullableWithAggregatesFilter<"AdminAuditEvent"> | string | null
    action?: StringWithAggregatesFilter<"AdminAuditEvent"> | string
    status?: StringWithAggregatesFilter<"AdminAuditEvent"> | string
    actorId?: StringNullableWithAggregatesFilter<"AdminAuditEvent"> | string | null
    actorRole?: StringWithAggregatesFilter<"AdminAuditEvent"> | string
    error?: StringNullableWithAggregatesFilter<"AdminAuditEvent"> | string | null
    metadataJson?: StringNullableWithAggregatesFilter<"AdminAuditEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditEvent"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    leadId?: StringNullableFilter<"Transaction"> | string | null
    contactId?: StringNullableFilter<"Transaction"> | string | null
    propertyAddress?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    side?: StringFilter<"Transaction"> | string
    salePrice?: IntNullableFilter<"Transaction"> | number | null
    listPrice?: IntNullableFilter<"Transaction"> | number | null
    closingDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    contractDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    inspectionDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    appraisalDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    titleDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parties?: TransactionPartyListRelationFilter
    documents?: TransactionDocumentListRelationFilter
    milestones?: TransactionMilestoneListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    propertyAddress?: SortOrder
    status?: SortOrder
    side?: SortOrder
    salePrice?: SortOrderInput | SortOrder
    listPrice?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    contractDate?: SortOrderInput | SortOrder
    inspectionDate?: SortOrderInput | SortOrder
    appraisalDate?: SortOrderInput | SortOrder
    titleDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    parties?: TransactionPartyOrderByRelationAggregateInput
    documents?: TransactionDocumentOrderByRelationAggregateInput
    milestones?: TransactionMilestoneOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    tenantId?: StringFilter<"Transaction"> | string
    leadId?: StringNullableFilter<"Transaction"> | string | null
    contactId?: StringNullableFilter<"Transaction"> | string | null
    propertyAddress?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    side?: StringFilter<"Transaction"> | string
    salePrice?: IntNullableFilter<"Transaction"> | number | null
    listPrice?: IntNullableFilter<"Transaction"> | number | null
    closingDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    contractDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    inspectionDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    appraisalDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    titleDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    parties?: TransactionPartyListRelationFilter
    documents?: TransactionDocumentListRelationFilter
    milestones?: TransactionMilestoneListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    propertyAddress?: SortOrder
    status?: SortOrder
    side?: SortOrder
    salePrice?: SortOrderInput | SortOrder
    listPrice?: SortOrderInput | SortOrder
    closingDate?: SortOrderInput | SortOrder
    contractDate?: SortOrderInput | SortOrder
    inspectionDate?: SortOrderInput | SortOrder
    appraisalDate?: SortOrderInput | SortOrder
    titleDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    tenantId?: StringWithAggregatesFilter<"Transaction"> | string
    leadId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    propertyAddress?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    side?: StringWithAggregatesFilter<"Transaction"> | string
    salePrice?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    listPrice?: IntNullableWithAggregatesFilter<"Transaction"> | number | null
    closingDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    contractDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    inspectionDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    appraisalDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    titleDate?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransactionPartyWhereInput = {
    AND?: TransactionPartyWhereInput | TransactionPartyWhereInput[]
    OR?: TransactionPartyWhereInput[]
    NOT?: TransactionPartyWhereInput | TransactionPartyWhereInput[]
    id?: StringFilter<"TransactionParty"> | string
    transactionId?: StringFilter<"TransactionParty"> | string
    tenantId?: StringFilter<"TransactionParty"> | string
    role?: StringFilter<"TransactionParty"> | string
    name?: StringFilter<"TransactionParty"> | string
    email?: StringNullableFilter<"TransactionParty"> | string | null
    phone?: StringNullableFilter<"TransactionParty"> | string | null
    company?: StringNullableFilter<"TransactionParty"> | string | null
    createdAt?: DateTimeFilter<"TransactionParty"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionParty"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionPartyOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionPartyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionPartyWhereInput | TransactionPartyWhereInput[]
    OR?: TransactionPartyWhereInput[]
    NOT?: TransactionPartyWhereInput | TransactionPartyWhereInput[]
    transactionId?: StringFilter<"TransactionParty"> | string
    tenantId?: StringFilter<"TransactionParty"> | string
    role?: StringFilter<"TransactionParty"> | string
    name?: StringFilter<"TransactionParty"> | string
    email?: StringNullableFilter<"TransactionParty"> | string | null
    phone?: StringNullableFilter<"TransactionParty"> | string | null
    company?: StringNullableFilter<"TransactionParty"> | string | null
    createdAt?: DateTimeFilter<"TransactionParty"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionParty"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type TransactionPartyOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionPartyCountOrderByAggregateInput
    _max?: TransactionPartyMaxOrderByAggregateInput
    _min?: TransactionPartyMinOrderByAggregateInput
  }

  export type TransactionPartyScalarWhereWithAggregatesInput = {
    AND?: TransactionPartyScalarWhereWithAggregatesInput | TransactionPartyScalarWhereWithAggregatesInput[]
    OR?: TransactionPartyScalarWhereWithAggregatesInput[]
    NOT?: TransactionPartyScalarWhereWithAggregatesInput | TransactionPartyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionParty"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionParty"> | string
    tenantId?: StringWithAggregatesFilter<"TransactionParty"> | string
    role?: StringWithAggregatesFilter<"TransactionParty"> | string
    name?: StringWithAggregatesFilter<"TransactionParty"> | string
    email?: StringNullableWithAggregatesFilter<"TransactionParty"> | string | null
    phone?: StringNullableWithAggregatesFilter<"TransactionParty"> | string | null
    company?: StringNullableWithAggregatesFilter<"TransactionParty"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionParty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionParty"> | Date | string
  }

  export type TransactionDocumentWhereInput = {
    AND?: TransactionDocumentWhereInput | TransactionDocumentWhereInput[]
    OR?: TransactionDocumentWhereInput[]
    NOT?: TransactionDocumentWhereInput | TransactionDocumentWhereInput[]
    id?: StringFilter<"TransactionDocument"> | string
    transactionId?: StringFilter<"TransactionDocument"> | string
    tenantId?: StringFilter<"TransactionDocument"> | string
    documentType?: StringFilter<"TransactionDocument"> | string
    fileName?: StringFilter<"TransactionDocument"> | string
    status?: StringFilter<"TransactionDocument"> | string
    notes?: StringNullableFilter<"TransactionDocument"> | string | null
    createdAt?: DateTimeFilter<"TransactionDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionDocument"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionDocumentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionDocumentWhereInput | TransactionDocumentWhereInput[]
    OR?: TransactionDocumentWhereInput[]
    NOT?: TransactionDocumentWhereInput | TransactionDocumentWhereInput[]
    transactionId?: StringFilter<"TransactionDocument"> | string
    tenantId?: StringFilter<"TransactionDocument"> | string
    documentType?: StringFilter<"TransactionDocument"> | string
    fileName?: StringFilter<"TransactionDocument"> | string
    status?: StringFilter<"TransactionDocument"> | string
    notes?: StringNullableFilter<"TransactionDocument"> | string | null
    createdAt?: DateTimeFilter<"TransactionDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionDocument"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type TransactionDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionDocumentCountOrderByAggregateInput
    _max?: TransactionDocumentMaxOrderByAggregateInput
    _min?: TransactionDocumentMinOrderByAggregateInput
  }

  export type TransactionDocumentScalarWhereWithAggregatesInput = {
    AND?: TransactionDocumentScalarWhereWithAggregatesInput | TransactionDocumentScalarWhereWithAggregatesInput[]
    OR?: TransactionDocumentScalarWhereWithAggregatesInput[]
    NOT?: TransactionDocumentScalarWhereWithAggregatesInput | TransactionDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionDocument"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionDocument"> | string
    tenantId?: StringWithAggregatesFilter<"TransactionDocument"> | string
    documentType?: StringWithAggregatesFilter<"TransactionDocument"> | string
    fileName?: StringWithAggregatesFilter<"TransactionDocument"> | string
    status?: StringWithAggregatesFilter<"TransactionDocument"> | string
    notes?: StringNullableWithAggregatesFilter<"TransactionDocument"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionDocument"> | Date | string
  }

  export type TransactionMilestoneWhereInput = {
    AND?: TransactionMilestoneWhereInput | TransactionMilestoneWhereInput[]
    OR?: TransactionMilestoneWhereInput[]
    NOT?: TransactionMilestoneWhereInput | TransactionMilestoneWhereInput[]
    id?: StringFilter<"TransactionMilestone"> | string
    transactionId?: StringFilter<"TransactionMilestone"> | string
    tenantId?: StringFilter<"TransactionMilestone"> | string
    milestoneType?: StringFilter<"TransactionMilestone"> | string
    scheduledAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    createdAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    milestoneType?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionMilestoneWhereInput | TransactionMilestoneWhereInput[]
    OR?: TransactionMilestoneWhereInput[]
    NOT?: TransactionMilestoneWhereInput | TransactionMilestoneWhereInput[]
    transactionId?: StringFilter<"TransactionMilestone"> | string
    tenantId?: StringFilter<"TransactionMilestone"> | string
    milestoneType?: StringFilter<"TransactionMilestone"> | string
    scheduledAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    createdAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type TransactionMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    milestoneType?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionMilestoneCountOrderByAggregateInput
    _max?: TransactionMilestoneMaxOrderByAggregateInput
    _min?: TransactionMilestoneMinOrderByAggregateInput
  }

  export type TransactionMilestoneScalarWhereWithAggregatesInput = {
    AND?: TransactionMilestoneScalarWhereWithAggregatesInput | TransactionMilestoneScalarWhereWithAggregatesInput[]
    OR?: TransactionMilestoneScalarWhereWithAggregatesInput[]
    NOT?: TransactionMilestoneScalarWhereWithAggregatesInput | TransactionMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionMilestone"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionMilestone"> | string
    tenantId?: StringWithAggregatesFilter<"TransactionMilestone"> | string
    milestoneType?: StringWithAggregatesFilter<"TransactionMilestone"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"TransactionMilestone"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"TransactionMilestone"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionMilestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionMilestone"> | Date | string
  }

  export type TenantCreateInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDomainCreateInput = {
    id: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutDomainsInput
  }

  export type TenantDomainUncheckedCreateInput = {
    id: string
    tenantId: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDomainsNestedInput
  }

  export type TenantDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDomainCreateManyInput = {
    id: string
    tenantId: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteConfigCreateInput = {
    id: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutWebsiteConfigInput
    modules?: ModuleConfigCreateNestedManyWithoutWebsiteConfigInput
  }

  export type WebsiteConfigUncheckedCreateInput = {
    id: string
    tenantId: string
    createdAt: Date | string
    updatedAt: Date | string
    modules?: ModuleConfigUncheckedCreateNestedManyWithoutWebsiteConfigInput
  }

  export type WebsiteConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsiteConfigNestedInput
    modules?: ModuleConfigUpdateManyWithoutWebsiteConfigNestedInput
  }

  export type WebsiteConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleConfigUncheckedUpdateManyWithoutWebsiteConfigNestedInput
  }

  export type WebsiteConfigCreateManyInput = {
    id: string
    tenantId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type WebsiteConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlSettingsCreateInput = {
    id: string
    status?: string
    planCode?: string
    featureFlagsJson?: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutControlSettingsInput
  }

  export type TenantControlSettingsUncheckedCreateInput = {
    id: string
    tenantId: string
    status?: string
    planCode?: string
    featureFlagsJson?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutControlSettingsNestedInput
  }

  export type TenantControlSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlSettingsCreateManyInput = {
    id: string
    tenantId: string
    status?: string
    planCode?: string
    featureFlagsJson?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSubscriptionCreateInput = {
    id: string
    planCode?: string
    status?: string
    paymentStatus?: string
    billingProvider?: string
    billingCustomerId?: string | null
    billingSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    currentPeriodEndsAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutBillingSubscriptionInput
  }

  export type TenantBillingSubscriptionUncheckedCreateInput = {
    id: string
    tenantId: string
    planCode?: string
    status?: string
    paymentStatus?: string
    billingProvider?: string
    billingCustomerId?: string | null
    billingSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    currentPeriodEndsAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantBillingSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBillingSubscriptionNestedInput
  }

  export type TenantBillingSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSubscriptionCreateManyInput = {
    id: string
    tenantId: string
    planCode?: string
    status?: string
    paymentStatus?: string
    billingProvider?: string
    billingCustomerId?: string | null
    billingSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    currentPeriodEndsAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantBillingSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSyncEventCreateInput = {
    id: string
    tenantId?: string | null
    provider: string
    eventId: string
    eventType: string
    payloadJson: string
    resultStatus: string
    resultMessage?: string | null
    createdAt: Date | string
    processedAt: Date | string
  }

  export type TenantBillingSyncEventUncheckedCreateInput = {
    id: string
    tenantId?: string | null
    provider: string
    eventId: string
    eventType: string
    payloadJson: string
    resultStatus: string
    resultMessage?: string | null
    createdAt: Date | string
    processedAt: Date | string
  }

  export type TenantBillingSyncEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    resultStatus?: StringFieldUpdateOperationsInput | string
    resultMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSyncEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    resultStatus?: StringFieldUpdateOperationsInput | string
    resultMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSyncEventCreateManyInput = {
    id: string
    tenantId?: string | null
    provider: string
    eventId: string
    eventType: string
    payloadJson: string
    resultStatus: string
    resultMessage?: string | null
    createdAt: Date | string
    processedAt: Date | string
  }

  export type TenantBillingSyncEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    resultStatus?: StringFieldUpdateOperationsInput | string
    resultMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSyncEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    resultStatus?: StringFieldUpdateOperationsInput | string
    resultMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorCreateInput = {
    id: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutControlActorsInput
  }

  export type TenantControlActorUncheckedCreateInput = {
    id: string
    tenantId: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlActorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutControlActorsNestedInput
  }

  export type TenantControlActorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorCreateManyInput = {
    id: string
    tenantId: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlActorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingPlanCreateInput = {
    id: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutOnboardingPlansInput
    tasks?: TenantOnboardingTaskCreateNestedManyWithoutOnboardingPlanInput
  }

  export type TenantOnboardingPlanUncheckedCreateInput = {
    id: string
    tenantId: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutOnboardingPlanInput
  }

  export type TenantOnboardingPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOnboardingPlansNestedInput
    tasks?: TenantOnboardingTaskUpdateManyWithoutOnboardingPlanNestedInput
  }

  export type TenantOnboardingPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutOnboardingPlanNestedInput
  }

  export type TenantOnboardingPlanCreateManyInput = {
    id: string
    tenantId: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskCreateInput = {
    id: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutOnboardingTasksInput
    onboardingPlan: TenantOnboardingPlanCreateNestedOneWithoutTasksInput
  }

  export type TenantOnboardingTaskUncheckedCreateInput = {
    id: string
    tenantOnboardingPlanId: string
    tenantId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOnboardingTasksNestedInput
    onboardingPlan?: TenantOnboardingPlanUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TenantOnboardingTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantOnboardingPlanId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskCreateManyInput = {
    id: string
    tenantOnboardingPlanId: string
    tenantId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantOnboardingPlanId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigCreateInput = {
    id: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
    websiteConfig: WebsiteConfigCreateNestedOneWithoutModulesInput
  }

  export type ModuleConfigUncheckedCreateInput = {
    id: string
    websiteConfigId: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ModuleConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteConfig?: WebsiteConfigUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteConfigId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigCreateManyInput = {
    id: string
    websiteConfigId: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ModuleConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    websiteConfigId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id: string
    tenantId: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id: string
    tenantId: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    contact?: ContactCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id: string
    tenantId: string
    contactId?: string | null
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    contact?: ContactUpdateOneWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id: string
    tenantId: string
    contactId?: string | null
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id: string
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
    tenant: TenantCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id: string
    tenantId: string
    contactId?: string | null
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id: string
    tenantId: string
    contactId?: string | null
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventCreateInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
    tenant: TenantCreateNestedOneWithoutIngestedEventsInput
  }

  export type IngestedEventUncheckedCreateInput = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
  }

  export type IngestedEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIngestedEventsNestedInput
  }

  export type IngestedEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventCreateManyInput = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
  }

  export type IngestedEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionQueueJobCreateInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutIngestionQueueJobsInput
  }

  export type IngestionQueueJobUncheckedCreateInput = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
  }

  export type IngestionQueueJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutIngestionQueueJobsNestedInput
  }

  export type IngestionQueueJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IngestionQueueJobCreateManyInput = {
    id: string
    tenantId: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
  }

  export type IngestionQueueJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IngestionQueueJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdminAuditEventCreateInput = {
    id: string
    tenantId?: string | null
    domainId?: string | null
    action: string
    status: string
    actorId?: string | null
    actorRole: string
    error?: string | null
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type AdminAuditEventUncheckedCreateInput = {
    id: string
    tenantId?: string | null
    domainId?: string | null
    action: string
    status: string
    actorId?: string | null
    actorRole: string
    error?: string | null
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type AdminAuditEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorRole?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorRole?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditEventCreateManyInput = {
    id: string
    tenantId?: string | null
    domainId?: string | null
    action: string
    status: string
    actorId?: string | null
    actorRole: string
    error?: string | null
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type AdminAuditEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorRole?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actorRole?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    parties?: TransactionPartyCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id: string
    tenantId: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    parties?: TransactionPartyUncheckedCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentUncheckedCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    parties?: TransactionPartyUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parties?: TransactionPartyUncheckedUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUncheckedUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id: string
    tenantId: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyCreateInput = {
    id: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    transaction: TransactionCreateNestedOneWithoutPartiesInput
  }

  export type TransactionPartyUncheckedCreateInput = {
    id: string
    transactionId: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionPartyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutPartiesNestedInput
  }

  export type TransactionPartyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyCreateManyInput = {
    id: string
    transactionId: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionPartyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentCreateInput = {
    id: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    transaction: TransactionCreateNestedOneWithoutDocumentsInput
  }

  export type TransactionDocumentUncheckedCreateInput = {
    id: string
    transactionId: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type TransactionDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentCreateManyInput = {
    id: string
    transactionId: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneCreateInput = {
    id: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    transaction: TransactionCreateNestedOneWithoutMilestonesInput
  }

  export type TransactionMilestoneUncheckedCreateInput = {
    id: string
    transactionId: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionMilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type TransactionMilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneCreateManyInput = {
    id: string
    transactionId: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionMilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TenantDomainListRelationFilter = {
    every?: TenantDomainWhereInput
    some?: TenantDomainWhereInput
    none?: TenantDomainWhereInput
  }

  export type WebsiteConfigNullableScalarRelationFilter = {
    is?: WebsiteConfigWhereInput | null
    isNot?: WebsiteConfigWhereInput | null
  }

  export type TenantControlSettingsNullableScalarRelationFilter = {
    is?: TenantControlSettingsWhereInput | null
    isNot?: TenantControlSettingsWhereInput | null
  }

  export type TenantBillingSubscriptionNullableScalarRelationFilter = {
    is?: TenantBillingSubscriptionWhereInput | null
    isNot?: TenantBillingSubscriptionWhereInput | null
  }

  export type TenantControlActorListRelationFilter = {
    every?: TenantControlActorWhereInput
    some?: TenantControlActorWhereInput
    none?: TenantControlActorWhereInput
  }

  export type TenantOnboardingPlanListRelationFilter = {
    every?: TenantOnboardingPlanWhereInput
    some?: TenantOnboardingPlanWhereInput
    none?: TenantOnboardingPlanWhereInput
  }

  export type TenantOnboardingTaskListRelationFilter = {
    every?: TenantOnboardingTaskWhereInput
    some?: TenantOnboardingTaskWhereInput
    none?: TenantOnboardingTaskWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type IngestedEventListRelationFilter = {
    every?: IngestedEventWhereInput
    some?: IngestedEventWhereInput
    none?: IngestedEventWhereInput
  }

  export type IngestionQueueJobListRelationFilter = {
    every?: IngestionQueueJobWhereInput
    some?: IngestionQueueJobWhereInput
    none?: IngestionQueueJobWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TenantDomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantControlActorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOnboardingPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantOnboardingTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngestedEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngestionQueueJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TenantDomainCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hostname?: SortOrder
    hostnameNormalized?: SortOrder
    status?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hostname?: SortOrder
    hostnameNormalized?: SortOrder
    status?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantDomainMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    hostname?: SortOrder
    hostnameNormalized?: SortOrder
    status?: SortOrder
    isPrimary?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ModuleConfigListRelationFilter = {
    every?: ModuleConfigWhereInput
    some?: ModuleConfigWhereInput
    none?: ModuleConfigWhereInput
  }

  export type ModuleConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebsiteConfigCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebsiteConfigMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantControlSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    featureFlagsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantControlSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    featureFlagsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantControlSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    featureFlagsJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TenantBillingSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planCode?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    billingProvider?: SortOrder
    billingCustomerId?: SortOrder
    billingSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodEndsAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantBillingSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planCode?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    billingProvider?: SortOrder
    billingCustomerId?: SortOrder
    billingSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodEndsAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantBillingSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    planCode?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    billingProvider?: SortOrder
    billingCustomerId?: SortOrder
    billingSubscriptionId?: SortOrder
    trialEndsAt?: SortOrder
    currentPeriodEndsAt?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TenantBillingSyncEventProviderEventIdCompoundUniqueInput = {
    provider: string
    eventId: string
  }

  export type TenantBillingSyncEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payloadJson?: SortOrder
    resultStatus?: SortOrder
    resultMessage?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TenantBillingSyncEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payloadJson?: SortOrder
    resultStatus?: SortOrder
    resultMessage?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TenantBillingSyncEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    provider?: SortOrder
    eventId?: SortOrder
    eventType?: SortOrder
    payloadJson?: SortOrder
    resultStatus?: SortOrder
    resultMessage?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TenantControlActorTenantIdActorIdCompoundUniqueInput = {
    tenantId: string
    actorId: string
  }

  export type TenantControlActorCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorId?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissionsJson?: SortOrder
    supportSessionActive?: SortOrder
    supportSessionStartedAt?: SortOrder
    supportSessionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantControlActorMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorId?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissionsJson?: SortOrder
    supportSessionActive?: SortOrder
    supportSessionStartedAt?: SortOrder
    supportSessionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantControlActorMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    actorId?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    role?: SortOrder
    permissionsJson?: SortOrder
    supportSessionActive?: SortOrder
    supportSessionStartedAt?: SortOrder
    supportSessionExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingPlanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    startedAt?: SortOrder
    targetLaunchDate?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    startedAt?: SortOrder
    targetLaunchDate?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingPlanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    status?: SortOrder
    planCode?: SortOrder
    startedAt?: SortOrder
    targetLaunchDate?: SortOrder
    completedAt?: SortOrder
    pausedAt?: SortOrder
    pauseReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TenantOnboardingPlanScalarRelationFilter = {
    is?: TenantOnboardingPlanWhereInput
    isNot?: TenantOnboardingPlanWhereInput
  }

  export type TenantOnboardingTaskTenantOnboardingPlanIdTaskKeyCompoundUniqueInput = {
    tenantOnboardingPlanId: string
    taskKey: string
  }

  export type TenantOnboardingTaskCountOrderByAggregateInput = {
    id?: SortOrder
    tenantOnboardingPlanId?: SortOrder
    tenantId?: SortOrder
    taskKey?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    required?: SortOrder
    ownerRole?: SortOrder
    ownerActorId?: SortOrder
    dueAt?: SortOrder
    blockedByClient?: SortOrder
    blockerReason?: SortOrder
    sortOrder?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingTaskAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type TenantOnboardingTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantOnboardingPlanId?: SortOrder
    tenantId?: SortOrder
    taskKey?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    required?: SortOrder
    ownerRole?: SortOrder
    ownerActorId?: SortOrder
    dueAt?: SortOrder
    blockedByClient?: SortOrder
    blockerReason?: SortOrder
    sortOrder?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingTaskMinOrderByAggregateInput = {
    id?: SortOrder
    tenantOnboardingPlanId?: SortOrder
    tenantId?: SortOrder
    taskKey?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    required?: SortOrder
    ownerRole?: SortOrder
    ownerActorId?: SortOrder
    dueAt?: SortOrder
    blockedByClient?: SortOrder
    blockerReason?: SortOrder
    sortOrder?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantOnboardingTaskSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type WebsiteConfigScalarRelationFilter = {
    is?: WebsiteConfigWhereInput
    isNot?: WebsiteConfigWhereInput
  }

  export type ModuleConfigWebsiteConfigIdModuleKeyCompoundUniqueInput = {
    websiteConfigId: string
    moduleKey: string
  }

  export type ModuleConfigCountOrderByAggregateInput = {
    id?: SortOrder
    websiteConfigId?: SortOrder
    tenantId?: SortOrder
    moduleKey?: SortOrder
    enabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleConfigAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ModuleConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    websiteConfigId?: SortOrder
    tenantId?: SortOrder
    moduleKey?: SortOrder
    enabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleConfigMinOrderByAggregateInput = {
    id?: SortOrder
    websiteConfigId?: SortOrder
    tenantId?: SortOrder
    moduleKey?: SortOrder
    enabled?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleConfigSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ContactTenantIdEmailNormalizedCompoundUniqueInput = {
    tenantId: string
    emailNormalized: string
  }

  export type ContactTenantIdPhoneNormalizedCompoundUniqueInput = {
    tenantId: string
    phoneNormalized: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailNormalized?: SortOrder
    phone?: SortOrder
    phoneNormalized?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailNormalized?: SortOrder
    phone?: SortOrder
    phoneNormalized?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    emailNormalized?: SortOrder
    phone?: SortOrder
    phoneNormalized?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    status?: SortOrder
    leadType?: SortOrder
    source?: SortOrder
    timeframe?: SortOrder
    notes?: SortOrder
    listingId?: SortOrder
    listingUrl?: SortOrder
    listingAddress?: SortOrder
    propertyType?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    lastContactAt?: SortOrder
    nextActionAt?: SortOrder
    nextActionNote?: SortOrder
    nextActionChannel?: SortOrder
    reminderSnoozedUntil?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    tags?: SortOrder
    closeReason?: SortOrder
    closeNotes?: SortOrder
    closedAt?: SortOrder
    assignedTo?: SortOrder
    referredBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    status?: SortOrder
    leadType?: SortOrder
    source?: SortOrder
    timeframe?: SortOrder
    notes?: SortOrder
    listingId?: SortOrder
    listingUrl?: SortOrder
    listingAddress?: SortOrder
    propertyType?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    lastContactAt?: SortOrder
    nextActionAt?: SortOrder
    nextActionNote?: SortOrder
    nextActionChannel?: SortOrder
    reminderSnoozedUntil?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    tags?: SortOrder
    closeReason?: SortOrder
    closeNotes?: SortOrder
    closedAt?: SortOrder
    assignedTo?: SortOrder
    referredBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    status?: SortOrder
    leadType?: SortOrder
    source?: SortOrder
    timeframe?: SortOrder
    notes?: SortOrder
    listingId?: SortOrder
    listingUrl?: SortOrder
    listingAddress?: SortOrder
    propertyType?: SortOrder
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    lastContactAt?: SortOrder
    nextActionAt?: SortOrder
    nextActionNote?: SortOrder
    nextActionChannel?: SortOrder
    reminderSnoozedUntil?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
    tags?: SortOrder
    closeReason?: SortOrder
    closeNotes?: SortOrder
    closedAt?: SortOrder
    assignedTo?: SortOrder
    referredBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    beds?: SortOrder
    baths?: SortOrder
    sqft?: SortOrder
    priceMin?: SortOrder
    priceMax?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    activityType?: SortOrder
    occurredAt?: SortOrder
    summary?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    activityType?: SortOrder
    occurredAt?: SortOrder
    summary?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    activityType?: SortOrder
    occurredAt?: SortOrder
    summary?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type IngestedEventTenantIdEventKeyCompoundUniqueInput = {
    tenantId: string
    eventKey: string
  }

  export type IngestedEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IngestedEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IngestedEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type IngestionQueueJobTenantIdEventKeyCompoundUniqueInput = {
    tenantId: string
    eventKey: string
  }

  export type IngestionQueueJobCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    nextAttemptAt?: SortOrder
    deadLetteredAt?: SortOrder
  }

  export type IngestionQueueJobAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type IngestionQueueJobMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    nextAttemptAt?: SortOrder
    deadLetteredAt?: SortOrder
  }

  export type IngestionQueueJobMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    eventKey?: SortOrder
    occurredAt?: SortOrder
    payloadJson?: SortOrder
    status?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    nextAttemptAt?: SortOrder
    deadLetteredAt?: SortOrder
  }

  export type IngestionQueueJobSumOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type AdminAuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domainId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    error?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domainId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    error?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    domainId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    actorId?: SortOrder
    actorRole?: SortOrder
    error?: SortOrder
    metadataJson?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionPartyListRelationFilter = {
    every?: TransactionPartyWhereInput
    some?: TransactionPartyWhereInput
    none?: TransactionPartyWhereInput
  }

  export type TransactionDocumentListRelationFilter = {
    every?: TransactionDocumentWhereInput
    some?: TransactionDocumentWhereInput
    none?: TransactionDocumentWhereInput
  }

  export type TransactionMilestoneListRelationFilter = {
    every?: TransactionMilestoneWhereInput
    some?: TransactionMilestoneWhereInput
    none?: TransactionMilestoneWhereInput
  }

  export type TransactionPartyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionMilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    contactId?: SortOrder
    propertyAddress?: SortOrder
    status?: SortOrder
    side?: SortOrder
    salePrice?: SortOrder
    listPrice?: SortOrder
    closingDate?: SortOrder
    contractDate?: SortOrder
    inspectionDate?: SortOrder
    appraisalDate?: SortOrder
    titleDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    salePrice?: SortOrder
    listPrice?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    contactId?: SortOrder
    propertyAddress?: SortOrder
    status?: SortOrder
    side?: SortOrder
    salePrice?: SortOrder
    listPrice?: SortOrder
    closingDate?: SortOrder
    contractDate?: SortOrder
    inspectionDate?: SortOrder
    appraisalDate?: SortOrder
    titleDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    leadId?: SortOrder
    contactId?: SortOrder
    propertyAddress?: SortOrder
    status?: SortOrder
    side?: SortOrder
    salePrice?: SortOrder
    listPrice?: SortOrder
    closingDate?: SortOrder
    contractDate?: SortOrder
    inspectionDate?: SortOrder
    appraisalDate?: SortOrder
    titleDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    salePrice?: SortOrder
    listPrice?: SortOrder
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type TransactionPartyCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionPartyMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionPartyMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    documentType?: SortOrder
    fileName?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    milestoneType?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    milestoneType?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    tenantId?: SortOrder
    milestoneType?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantDomainCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput> | TenantDomainCreateWithoutTenantInput[] | TenantDomainUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDomainCreateOrConnectWithoutTenantInput | TenantDomainCreateOrConnectWithoutTenantInput[]
    createMany?: TenantDomainCreateManyTenantInputEnvelope
    connect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
  }

  export type WebsiteConfigCreateNestedOneWithoutTenantInput = {
    create?: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutTenantInput
    connect?: WebsiteConfigWhereUniqueInput
  }

  export type TenantControlSettingsCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantControlSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantControlSettingsWhereUniqueInput
  }

  export type TenantBillingSubscriptionCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBillingSubscriptionCreateOrConnectWithoutTenantInput
    connect?: TenantBillingSubscriptionWhereUniqueInput
  }

  export type TenantControlActorCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput> | TenantControlActorCreateWithoutTenantInput[] | TenantControlActorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantControlActorCreateOrConnectWithoutTenantInput | TenantControlActorCreateOrConnectWithoutTenantInput[]
    createMany?: TenantControlActorCreateManyTenantInputEnvelope
    connect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
  }

  export type TenantOnboardingPlanCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput> | TenantOnboardingPlanCreateWithoutTenantInput[] | TenantOnboardingPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTenantInput | TenantOnboardingPlanCreateOrConnectWithoutTenantInput[]
    createMany?: TenantOnboardingPlanCreateManyTenantInputEnvelope
    connect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
  }

  export type TenantOnboardingTaskCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput> | TenantOnboardingTaskCreateWithoutTenantInput[] | TenantOnboardingTaskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutTenantInput | TenantOnboardingTaskCreateOrConnectWithoutTenantInput[]
    createMany?: TenantOnboardingTaskCreateManyTenantInputEnvelope
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type IngestedEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput> | IngestedEventCreateWithoutTenantInput[] | IngestedEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestedEventCreateOrConnectWithoutTenantInput | IngestedEventCreateOrConnectWithoutTenantInput[]
    createMany?: IngestedEventCreateManyTenantInputEnvelope
    connect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
  }

  export type IngestionQueueJobCreateNestedManyWithoutTenantInput = {
    create?: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput> | IngestionQueueJobCreateWithoutTenantInput[] | IngestionQueueJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestionQueueJobCreateOrConnectWithoutTenantInput | IngestionQueueJobCreateOrConnectWithoutTenantInput[]
    createMany?: IngestionQueueJobCreateManyTenantInputEnvelope
    connect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TenantDomainUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput> | TenantDomainCreateWithoutTenantInput[] | TenantDomainUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDomainCreateOrConnectWithoutTenantInput | TenantDomainCreateOrConnectWithoutTenantInput[]
    createMany?: TenantDomainCreateManyTenantInputEnvelope
    connect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
  }

  export type WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutTenantInput
    connect?: WebsiteConfigWhereUniqueInput
  }

  export type TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantControlSettingsCreateOrConnectWithoutTenantInput
    connect?: TenantControlSettingsWhereUniqueInput
  }

  export type TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput = {
    create?: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBillingSubscriptionCreateOrConnectWithoutTenantInput
    connect?: TenantBillingSubscriptionWhereUniqueInput
  }

  export type TenantControlActorUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput> | TenantControlActorCreateWithoutTenantInput[] | TenantControlActorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantControlActorCreateOrConnectWithoutTenantInput | TenantControlActorCreateOrConnectWithoutTenantInput[]
    createMany?: TenantControlActorCreateManyTenantInputEnvelope
    connect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
  }

  export type TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput> | TenantOnboardingPlanCreateWithoutTenantInput[] | TenantOnboardingPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTenantInput | TenantOnboardingPlanCreateOrConnectWithoutTenantInput[]
    createMany?: TenantOnboardingPlanCreateManyTenantInputEnvelope
    connect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
  }

  export type TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput> | TenantOnboardingTaskCreateWithoutTenantInput[] | TenantOnboardingTaskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutTenantInput | TenantOnboardingTaskCreateOrConnectWithoutTenantInput[]
    createMany?: TenantOnboardingTaskCreateManyTenantInputEnvelope
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type IngestedEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput> | IngestedEventCreateWithoutTenantInput[] | IngestedEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestedEventCreateOrConnectWithoutTenantInput | IngestedEventCreateOrConnectWithoutTenantInput[]
    createMany?: IngestedEventCreateManyTenantInputEnvelope
    connect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
  }

  export type IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput> | IngestionQueueJobCreateWithoutTenantInput[] | IngestionQueueJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestionQueueJobCreateOrConnectWithoutTenantInput | IngestionQueueJobCreateOrConnectWithoutTenantInput[]
    createMany?: IngestionQueueJobCreateManyTenantInputEnvelope
    connect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TenantDomainUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput> | TenantDomainCreateWithoutTenantInput[] | TenantDomainUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDomainCreateOrConnectWithoutTenantInput | TenantDomainCreateOrConnectWithoutTenantInput[]
    upsert?: TenantDomainUpsertWithWhereUniqueWithoutTenantInput | TenantDomainUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantDomainCreateManyTenantInputEnvelope
    set?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    disconnect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    delete?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    connect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    update?: TenantDomainUpdateWithWhereUniqueWithoutTenantInput | TenantDomainUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantDomainUpdateManyWithWhereWithoutTenantInput | TenantDomainUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantDomainScalarWhereInput | TenantDomainScalarWhereInput[]
  }

  export type WebsiteConfigUpdateOneWithoutTenantNestedInput = {
    create?: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutTenantInput
    upsert?: WebsiteConfigUpsertWithoutTenantInput
    disconnect?: WebsiteConfigWhereInput | boolean
    delete?: WebsiteConfigWhereInput | boolean
    connect?: WebsiteConfigWhereUniqueInput
    update?: XOR<XOR<WebsiteConfigUpdateToOneWithWhereWithoutTenantInput, WebsiteConfigUpdateWithoutTenantInput>, WebsiteConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlSettingsUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantControlSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantControlSettingsUpsertWithoutTenantInput
    disconnect?: TenantControlSettingsWhereInput | boolean
    delete?: TenantControlSettingsWhereInput | boolean
    connect?: TenantControlSettingsWhereUniqueInput
    update?: XOR<XOR<TenantControlSettingsUpdateToOneWithWhereWithoutTenantInput, TenantControlSettingsUpdateWithoutTenantInput>, TenantControlSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBillingSubscriptionCreateOrConnectWithoutTenantInput
    upsert?: TenantBillingSubscriptionUpsertWithoutTenantInput
    disconnect?: TenantBillingSubscriptionWhereInput | boolean
    delete?: TenantBillingSubscriptionWhereInput | boolean
    connect?: TenantBillingSubscriptionWhereUniqueInput
    update?: XOR<XOR<TenantBillingSubscriptionUpdateToOneWithWhereWithoutTenantInput, TenantBillingSubscriptionUpdateWithoutTenantInput>, TenantBillingSubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlActorUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput> | TenantControlActorCreateWithoutTenantInput[] | TenantControlActorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantControlActorCreateOrConnectWithoutTenantInput | TenantControlActorCreateOrConnectWithoutTenantInput[]
    upsert?: TenantControlActorUpsertWithWhereUniqueWithoutTenantInput | TenantControlActorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantControlActorCreateManyTenantInputEnvelope
    set?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    disconnect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    delete?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    connect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    update?: TenantControlActorUpdateWithWhereUniqueWithoutTenantInput | TenantControlActorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantControlActorUpdateManyWithWhereWithoutTenantInput | TenantControlActorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantControlActorScalarWhereInput | TenantControlActorScalarWhereInput[]
  }

  export type TenantOnboardingPlanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput> | TenantOnboardingPlanCreateWithoutTenantInput[] | TenantOnboardingPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTenantInput | TenantOnboardingPlanCreateOrConnectWithoutTenantInput[]
    upsert?: TenantOnboardingPlanUpsertWithWhereUniqueWithoutTenantInput | TenantOnboardingPlanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantOnboardingPlanCreateManyTenantInputEnvelope
    set?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    disconnect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    delete?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    connect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    update?: TenantOnboardingPlanUpdateWithWhereUniqueWithoutTenantInput | TenantOnboardingPlanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantOnboardingPlanUpdateManyWithWhereWithoutTenantInput | TenantOnboardingPlanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantOnboardingPlanScalarWhereInput | TenantOnboardingPlanScalarWhereInput[]
  }

  export type TenantOnboardingTaskUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput> | TenantOnboardingTaskCreateWithoutTenantInput[] | TenantOnboardingTaskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutTenantInput | TenantOnboardingTaskCreateOrConnectWithoutTenantInput[]
    upsert?: TenantOnboardingTaskUpsertWithWhereUniqueWithoutTenantInput | TenantOnboardingTaskUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantOnboardingTaskCreateManyTenantInputEnvelope
    set?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    disconnect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    delete?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    update?: TenantOnboardingTaskUpdateWithWhereUniqueWithoutTenantInput | TenantOnboardingTaskUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantOnboardingTaskUpdateManyWithWhereWithoutTenantInput | TenantOnboardingTaskUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenantInput | ActivityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenantInput | ActivityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenantInput | ActivityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type IngestedEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput> | IngestedEventCreateWithoutTenantInput[] | IngestedEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestedEventCreateOrConnectWithoutTenantInput | IngestedEventCreateOrConnectWithoutTenantInput[]
    upsert?: IngestedEventUpsertWithWhereUniqueWithoutTenantInput | IngestedEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IngestedEventCreateManyTenantInputEnvelope
    set?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    disconnect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    delete?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    connect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    update?: IngestedEventUpdateWithWhereUniqueWithoutTenantInput | IngestedEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IngestedEventUpdateManyWithWhereWithoutTenantInput | IngestedEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IngestedEventScalarWhereInput | IngestedEventScalarWhereInput[]
  }

  export type IngestionQueueJobUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput> | IngestionQueueJobCreateWithoutTenantInput[] | IngestionQueueJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestionQueueJobCreateOrConnectWithoutTenantInput | IngestionQueueJobCreateOrConnectWithoutTenantInput[]
    upsert?: IngestionQueueJobUpsertWithWhereUniqueWithoutTenantInput | IngestionQueueJobUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IngestionQueueJobCreateManyTenantInputEnvelope
    set?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    disconnect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    delete?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    connect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    update?: IngestionQueueJobUpdateWithWhereUniqueWithoutTenantInput | IngestionQueueJobUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IngestionQueueJobUpdateManyWithWhereWithoutTenantInput | IngestionQueueJobUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IngestionQueueJobScalarWhereInput | IngestionQueueJobScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TenantDomainUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput> | TenantDomainCreateWithoutTenantInput[] | TenantDomainUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantDomainCreateOrConnectWithoutTenantInput | TenantDomainCreateOrConnectWithoutTenantInput[]
    upsert?: TenantDomainUpsertWithWhereUniqueWithoutTenantInput | TenantDomainUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantDomainCreateManyTenantInputEnvelope
    set?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    disconnect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    delete?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    connect?: TenantDomainWhereUniqueInput | TenantDomainWhereUniqueInput[]
    update?: TenantDomainUpdateWithWhereUniqueWithoutTenantInput | TenantDomainUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantDomainUpdateManyWithWhereWithoutTenantInput | TenantDomainUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantDomainScalarWhereInput | TenantDomainScalarWhereInput[]
  }

  export type WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutTenantInput
    upsert?: WebsiteConfigUpsertWithoutTenantInput
    disconnect?: WebsiteConfigWhereInput | boolean
    delete?: WebsiteConfigWhereInput | boolean
    connect?: WebsiteConfigWhereUniqueInput
    update?: XOR<XOR<WebsiteConfigUpdateToOneWithWhereWithoutTenantInput, WebsiteConfigUpdateWithoutTenantInput>, WebsiteConfigUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantControlSettingsCreateOrConnectWithoutTenantInput
    upsert?: TenantControlSettingsUpsertWithoutTenantInput
    disconnect?: TenantControlSettingsWhereInput | boolean
    delete?: TenantControlSettingsWhereInput | boolean
    connect?: TenantControlSettingsWhereUniqueInput
    update?: XOR<XOR<TenantControlSettingsUpdateToOneWithWhereWithoutTenantInput, TenantControlSettingsUpdateWithoutTenantInput>, TenantControlSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput = {
    create?: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
    connectOrCreate?: TenantBillingSubscriptionCreateOrConnectWithoutTenantInput
    upsert?: TenantBillingSubscriptionUpsertWithoutTenantInput
    disconnect?: TenantBillingSubscriptionWhereInput | boolean
    delete?: TenantBillingSubscriptionWhereInput | boolean
    connect?: TenantBillingSubscriptionWhereUniqueInput
    update?: XOR<XOR<TenantBillingSubscriptionUpdateToOneWithWhereWithoutTenantInput, TenantBillingSubscriptionUpdateWithoutTenantInput>, TenantBillingSubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput> | TenantControlActorCreateWithoutTenantInput[] | TenantControlActorUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantControlActorCreateOrConnectWithoutTenantInput | TenantControlActorCreateOrConnectWithoutTenantInput[]
    upsert?: TenantControlActorUpsertWithWhereUniqueWithoutTenantInput | TenantControlActorUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantControlActorCreateManyTenantInputEnvelope
    set?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    disconnect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    delete?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    connect?: TenantControlActorWhereUniqueInput | TenantControlActorWhereUniqueInput[]
    update?: TenantControlActorUpdateWithWhereUniqueWithoutTenantInput | TenantControlActorUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantControlActorUpdateManyWithWhereWithoutTenantInput | TenantControlActorUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantControlActorScalarWhereInput | TenantControlActorScalarWhereInput[]
  }

  export type TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput> | TenantOnboardingPlanCreateWithoutTenantInput[] | TenantOnboardingPlanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTenantInput | TenantOnboardingPlanCreateOrConnectWithoutTenantInput[]
    upsert?: TenantOnboardingPlanUpsertWithWhereUniqueWithoutTenantInput | TenantOnboardingPlanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantOnboardingPlanCreateManyTenantInputEnvelope
    set?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    disconnect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    delete?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    connect?: TenantOnboardingPlanWhereUniqueInput | TenantOnboardingPlanWhereUniqueInput[]
    update?: TenantOnboardingPlanUpdateWithWhereUniqueWithoutTenantInput | TenantOnboardingPlanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantOnboardingPlanUpdateManyWithWhereWithoutTenantInput | TenantOnboardingPlanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantOnboardingPlanScalarWhereInput | TenantOnboardingPlanScalarWhereInput[]
  }

  export type TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput> | TenantOnboardingTaskCreateWithoutTenantInput[] | TenantOnboardingTaskUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutTenantInput | TenantOnboardingTaskCreateOrConnectWithoutTenantInput[]
    upsert?: TenantOnboardingTaskUpsertWithWhereUniqueWithoutTenantInput | TenantOnboardingTaskUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantOnboardingTaskCreateManyTenantInputEnvelope
    set?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    disconnect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    delete?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    update?: TenantOnboardingTaskUpdateWithWhereUniqueWithoutTenantInput | TenantOnboardingTaskUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantOnboardingTaskUpdateManyWithWhereWithoutTenantInput | TenantOnboardingTaskUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput> | ActivityCreateWithoutTenantInput[] | ActivityUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenantInput | ActivityCreateOrConnectWithoutTenantInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenantInput | ActivityUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ActivityCreateManyTenantInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenantInput | ActivityUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenantInput | ActivityUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type IngestedEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput> | IngestedEventCreateWithoutTenantInput[] | IngestedEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestedEventCreateOrConnectWithoutTenantInput | IngestedEventCreateOrConnectWithoutTenantInput[]
    upsert?: IngestedEventUpsertWithWhereUniqueWithoutTenantInput | IngestedEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IngestedEventCreateManyTenantInputEnvelope
    set?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    disconnect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    delete?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    connect?: IngestedEventWhereUniqueInput | IngestedEventWhereUniqueInput[]
    update?: IngestedEventUpdateWithWhereUniqueWithoutTenantInput | IngestedEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IngestedEventUpdateManyWithWhereWithoutTenantInput | IngestedEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IngestedEventScalarWhereInput | IngestedEventScalarWhereInput[]
  }

  export type IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput> | IngestionQueueJobCreateWithoutTenantInput[] | IngestionQueueJobUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IngestionQueueJobCreateOrConnectWithoutTenantInput | IngestionQueueJobCreateOrConnectWithoutTenantInput[]
    upsert?: IngestionQueueJobUpsertWithWhereUniqueWithoutTenantInput | IngestionQueueJobUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IngestionQueueJobCreateManyTenantInputEnvelope
    set?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    disconnect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    delete?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    connect?: IngestionQueueJobWhereUniqueInput | IngestionQueueJobWhereUniqueInput[]
    update?: IngestionQueueJobUpdateWithWhereUniqueWithoutTenantInput | IngestionQueueJobUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IngestionQueueJobUpdateManyWithWhereWithoutTenantInput | IngestionQueueJobUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IngestionQueueJobScalarWhereInput | IngestionQueueJobScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput> | TransactionCreateWithoutTenantInput[] | TransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutTenantInput | TransactionCreateOrConnectWithoutTenantInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutTenantInput | TransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TransactionCreateManyTenantInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutTenantInput | TransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutTenantInput | TransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDomainsInput = {
    create?: XOR<TenantCreateWithoutDomainsInput, TenantUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDomainsInput
    connect?: TenantWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutDomainsNestedInput = {
    create?: XOR<TenantCreateWithoutDomainsInput, TenantUncheckedCreateWithoutDomainsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDomainsInput
    upsert?: TenantUpsertWithoutDomainsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDomainsInput, TenantUpdateWithoutDomainsInput>, TenantUncheckedUpdateWithoutDomainsInput>
  }

  export type TenantCreateNestedOneWithoutWebsiteConfigInput = {
    create?: XOR<TenantCreateWithoutWebsiteConfigInput, TenantUncheckedCreateWithoutWebsiteConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebsiteConfigInput
    connect?: TenantWhereUniqueInput
  }

  export type ModuleConfigCreateNestedManyWithoutWebsiteConfigInput = {
    create?: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput> | ModuleConfigCreateWithoutWebsiteConfigInput[] | ModuleConfigUncheckedCreateWithoutWebsiteConfigInput[]
    connectOrCreate?: ModuleConfigCreateOrConnectWithoutWebsiteConfigInput | ModuleConfigCreateOrConnectWithoutWebsiteConfigInput[]
    createMany?: ModuleConfigCreateManyWebsiteConfigInputEnvelope
    connect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
  }

  export type ModuleConfigUncheckedCreateNestedManyWithoutWebsiteConfigInput = {
    create?: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput> | ModuleConfigCreateWithoutWebsiteConfigInput[] | ModuleConfigUncheckedCreateWithoutWebsiteConfigInput[]
    connectOrCreate?: ModuleConfigCreateOrConnectWithoutWebsiteConfigInput | ModuleConfigCreateOrConnectWithoutWebsiteConfigInput[]
    createMany?: ModuleConfigCreateManyWebsiteConfigInputEnvelope
    connect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWebsiteConfigNestedInput = {
    create?: XOR<TenantCreateWithoutWebsiteConfigInput, TenantUncheckedCreateWithoutWebsiteConfigInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebsiteConfigInput
    upsert?: TenantUpsertWithoutWebsiteConfigInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWebsiteConfigInput, TenantUpdateWithoutWebsiteConfigInput>, TenantUncheckedUpdateWithoutWebsiteConfigInput>
  }

  export type ModuleConfigUpdateManyWithoutWebsiteConfigNestedInput = {
    create?: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput> | ModuleConfigCreateWithoutWebsiteConfigInput[] | ModuleConfigUncheckedCreateWithoutWebsiteConfigInput[]
    connectOrCreate?: ModuleConfigCreateOrConnectWithoutWebsiteConfigInput | ModuleConfigCreateOrConnectWithoutWebsiteConfigInput[]
    upsert?: ModuleConfigUpsertWithWhereUniqueWithoutWebsiteConfigInput | ModuleConfigUpsertWithWhereUniqueWithoutWebsiteConfigInput[]
    createMany?: ModuleConfigCreateManyWebsiteConfigInputEnvelope
    set?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    disconnect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    delete?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    connect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    update?: ModuleConfigUpdateWithWhereUniqueWithoutWebsiteConfigInput | ModuleConfigUpdateWithWhereUniqueWithoutWebsiteConfigInput[]
    updateMany?: ModuleConfigUpdateManyWithWhereWithoutWebsiteConfigInput | ModuleConfigUpdateManyWithWhereWithoutWebsiteConfigInput[]
    deleteMany?: ModuleConfigScalarWhereInput | ModuleConfigScalarWhereInput[]
  }

  export type ModuleConfigUncheckedUpdateManyWithoutWebsiteConfigNestedInput = {
    create?: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput> | ModuleConfigCreateWithoutWebsiteConfigInput[] | ModuleConfigUncheckedCreateWithoutWebsiteConfigInput[]
    connectOrCreate?: ModuleConfigCreateOrConnectWithoutWebsiteConfigInput | ModuleConfigCreateOrConnectWithoutWebsiteConfigInput[]
    upsert?: ModuleConfigUpsertWithWhereUniqueWithoutWebsiteConfigInput | ModuleConfigUpsertWithWhereUniqueWithoutWebsiteConfigInput[]
    createMany?: ModuleConfigCreateManyWebsiteConfigInputEnvelope
    set?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    disconnect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    delete?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    connect?: ModuleConfigWhereUniqueInput | ModuleConfigWhereUniqueInput[]
    update?: ModuleConfigUpdateWithWhereUniqueWithoutWebsiteConfigInput | ModuleConfigUpdateWithWhereUniqueWithoutWebsiteConfigInput[]
    updateMany?: ModuleConfigUpdateManyWithWhereWithoutWebsiteConfigInput | ModuleConfigUpdateManyWithWhereWithoutWebsiteConfigInput[]
    deleteMany?: ModuleConfigScalarWhereInput | ModuleConfigScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutControlSettingsInput = {
    create?: XOR<TenantCreateWithoutControlSettingsInput, TenantUncheckedCreateWithoutControlSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutControlSettingsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutControlSettingsNestedInput = {
    create?: XOR<TenantCreateWithoutControlSettingsInput, TenantUncheckedCreateWithoutControlSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutControlSettingsInput
    upsert?: TenantUpsertWithoutControlSettingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutControlSettingsInput, TenantUpdateWithoutControlSettingsInput>, TenantUncheckedUpdateWithoutControlSettingsInput>
  }

  export type TenantCreateNestedOneWithoutBillingSubscriptionInput = {
    create?: XOR<TenantCreateWithoutBillingSubscriptionInput, TenantUncheckedCreateWithoutBillingSubscriptionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingSubscriptionInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TenantUpdateOneRequiredWithoutBillingSubscriptionNestedInput = {
    create?: XOR<TenantCreateWithoutBillingSubscriptionInput, TenantUncheckedCreateWithoutBillingSubscriptionInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBillingSubscriptionInput
    upsert?: TenantUpsertWithoutBillingSubscriptionInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBillingSubscriptionInput, TenantUpdateWithoutBillingSubscriptionInput>, TenantUncheckedUpdateWithoutBillingSubscriptionInput>
  }

  export type TenantCreateNestedOneWithoutControlActorsInput = {
    create?: XOR<TenantCreateWithoutControlActorsInput, TenantUncheckedCreateWithoutControlActorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutControlActorsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutControlActorsNestedInput = {
    create?: XOR<TenantCreateWithoutControlActorsInput, TenantUncheckedCreateWithoutControlActorsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutControlActorsInput
    upsert?: TenantUpsertWithoutControlActorsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutControlActorsInput, TenantUpdateWithoutControlActorsInput>, TenantUncheckedUpdateWithoutControlActorsInput>
  }

  export type TenantCreateNestedOneWithoutOnboardingPlansInput = {
    create?: XOR<TenantCreateWithoutOnboardingPlansInput, TenantUncheckedCreateWithoutOnboardingPlansInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOnboardingPlansInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantOnboardingTaskCreateNestedManyWithoutOnboardingPlanInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput> | TenantOnboardingTaskCreateWithoutOnboardingPlanInput[] | TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput | TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput[]
    createMany?: TenantOnboardingTaskCreateManyOnboardingPlanInputEnvelope
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
  }

  export type TenantOnboardingTaskUncheckedCreateNestedManyWithoutOnboardingPlanInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput> | TenantOnboardingTaskCreateWithoutOnboardingPlanInput[] | TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput | TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput[]
    createMany?: TenantOnboardingTaskCreateManyOnboardingPlanInputEnvelope
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutOnboardingPlansNestedInput = {
    create?: XOR<TenantCreateWithoutOnboardingPlansInput, TenantUncheckedCreateWithoutOnboardingPlansInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOnboardingPlansInput
    upsert?: TenantUpsertWithoutOnboardingPlansInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOnboardingPlansInput, TenantUpdateWithoutOnboardingPlansInput>, TenantUncheckedUpdateWithoutOnboardingPlansInput>
  }

  export type TenantOnboardingTaskUpdateManyWithoutOnboardingPlanNestedInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput> | TenantOnboardingTaskCreateWithoutOnboardingPlanInput[] | TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput | TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput[]
    upsert?: TenantOnboardingTaskUpsertWithWhereUniqueWithoutOnboardingPlanInput | TenantOnboardingTaskUpsertWithWhereUniqueWithoutOnboardingPlanInput[]
    createMany?: TenantOnboardingTaskCreateManyOnboardingPlanInputEnvelope
    set?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    disconnect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    delete?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    update?: TenantOnboardingTaskUpdateWithWhereUniqueWithoutOnboardingPlanInput | TenantOnboardingTaskUpdateWithWhereUniqueWithoutOnboardingPlanInput[]
    updateMany?: TenantOnboardingTaskUpdateManyWithWhereWithoutOnboardingPlanInput | TenantOnboardingTaskUpdateManyWithWhereWithoutOnboardingPlanInput[]
    deleteMany?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
  }

  export type TenantOnboardingTaskUncheckedUpdateManyWithoutOnboardingPlanNestedInput = {
    create?: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput> | TenantOnboardingTaskCreateWithoutOnboardingPlanInput[] | TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput[]
    connectOrCreate?: TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput | TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput[]
    upsert?: TenantOnboardingTaskUpsertWithWhereUniqueWithoutOnboardingPlanInput | TenantOnboardingTaskUpsertWithWhereUniqueWithoutOnboardingPlanInput[]
    createMany?: TenantOnboardingTaskCreateManyOnboardingPlanInputEnvelope
    set?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    disconnect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    delete?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    connect?: TenantOnboardingTaskWhereUniqueInput | TenantOnboardingTaskWhereUniqueInput[]
    update?: TenantOnboardingTaskUpdateWithWhereUniqueWithoutOnboardingPlanInput | TenantOnboardingTaskUpdateWithWhereUniqueWithoutOnboardingPlanInput[]
    updateMany?: TenantOnboardingTaskUpdateManyWithWhereWithoutOnboardingPlanInput | TenantOnboardingTaskUpdateManyWithWhereWithoutOnboardingPlanInput[]
    deleteMany?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutOnboardingTasksInput = {
    create?: XOR<TenantCreateWithoutOnboardingTasksInput, TenantUncheckedCreateWithoutOnboardingTasksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOnboardingTasksInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantOnboardingPlanCreateNestedOneWithoutTasksInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTasksInput, TenantOnboardingPlanUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTasksInput
    connect?: TenantOnboardingPlanWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutOnboardingTasksNestedInput = {
    create?: XOR<TenantCreateWithoutOnboardingTasksInput, TenantUncheckedCreateWithoutOnboardingTasksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutOnboardingTasksInput
    upsert?: TenantUpsertWithoutOnboardingTasksInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutOnboardingTasksInput, TenantUpdateWithoutOnboardingTasksInput>, TenantUncheckedUpdateWithoutOnboardingTasksInput>
  }

  export type TenantOnboardingPlanUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TenantOnboardingPlanCreateWithoutTasksInput, TenantOnboardingPlanUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TenantOnboardingPlanCreateOrConnectWithoutTasksInput
    upsert?: TenantOnboardingPlanUpsertWithoutTasksInput
    connect?: TenantOnboardingPlanWhereUniqueInput
    update?: XOR<XOR<TenantOnboardingPlanUpdateToOneWithWhereWithoutTasksInput, TenantOnboardingPlanUpdateWithoutTasksInput>, TenantOnboardingPlanUncheckedUpdateWithoutTasksInput>
  }

  export type WebsiteConfigCreateNestedOneWithoutModulesInput = {
    create?: XOR<WebsiteConfigCreateWithoutModulesInput, WebsiteConfigUncheckedCreateWithoutModulesInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutModulesInput
    connect?: WebsiteConfigWhereUniqueInput
  }

  export type WebsiteConfigUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<WebsiteConfigCreateWithoutModulesInput, WebsiteConfigUncheckedCreateWithoutModulesInput>
    connectOrCreate?: WebsiteConfigCreateOrConnectWithoutModulesInput
    upsert?: WebsiteConfigUpsertWithoutModulesInput
    connect?: WebsiteConfigWhereUniqueInput
    update?: XOR<XOR<WebsiteConfigUpdateToOneWithWhereWithoutModulesInput, WebsiteConfigUpdateWithoutModulesInput>, WebsiteConfigUncheckedUpdateWithoutModulesInput>
  }

  export type TenantCreateNestedOneWithoutContactsInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedManyWithoutContactInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    upsert?: TenantUpsertWithoutContactsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutContactsInput, TenantUpdateWithoutContactsInput>, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type LeadUpdateManyWithoutContactNestedInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutContactInput | LeadUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutContactInput | LeadUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutContactInput | LeadUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutContactInput | LeadUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutContactInput | LeadUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutContactInput | LeadUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutLeadsInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutLeadsInput = {
    create?: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutLeadsInput
    connect?: ContactWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    upsert?: TenantUpsertWithoutLeadsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeadsInput, TenantUpdateWithoutLeadsInput>, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type ContactUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutLeadsInput
    upsert?: ContactUpsertWithoutLeadsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutLeadsInput, ContactUpdateWithoutLeadsInput>, ContactUncheckedUpdateWithoutLeadsInput>
  }

  export type ActivityUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput> | ActivityCreateWithoutLeadInput[] | ActivityUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutLeadInput | ActivityCreateOrConnectWithoutLeadInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutLeadInput | ActivityUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ActivityCreateManyLeadInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutLeadInput | ActivityUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutLeadInput | ActivityUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActivitiesInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    connect?: LeadWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutActivitiesInput
    upsert?: TenantUpsertWithoutActivitiesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutActivitiesInput, TenantUpdateWithoutActivitiesInput>, TenantUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    upsert?: ContactUpsertWithoutActivitiesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivitiesInput, ContactUpdateWithoutActivitiesInput>, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: LeadCreateOrConnectWithoutActivitiesInput
    upsert?: LeadUpsertWithoutActivitiesInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutActivitiesInput, LeadUpdateWithoutActivitiesInput>, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type TenantCreateNestedOneWithoutIngestedEventsInput = {
    create?: XOR<TenantCreateWithoutIngestedEventsInput, TenantUncheckedCreateWithoutIngestedEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIngestedEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutIngestedEventsNestedInput = {
    create?: XOR<TenantCreateWithoutIngestedEventsInput, TenantUncheckedCreateWithoutIngestedEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIngestedEventsInput
    upsert?: TenantUpsertWithoutIngestedEventsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIngestedEventsInput, TenantUpdateWithoutIngestedEventsInput>, TenantUncheckedUpdateWithoutIngestedEventsInput>
  }

  export type TenantCreateNestedOneWithoutIngestionQueueJobsInput = {
    create?: XOR<TenantCreateWithoutIngestionQueueJobsInput, TenantUncheckedCreateWithoutIngestionQueueJobsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIngestionQueueJobsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutIngestionQueueJobsNestedInput = {
    create?: XOR<TenantCreateWithoutIngestionQueueJobsInput, TenantUncheckedCreateWithoutIngestionQueueJobsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIngestionQueueJobsInput
    upsert?: TenantUpsertWithoutIngestionQueueJobsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIngestionQueueJobsInput, TenantUpdateWithoutIngestionQueueJobsInput>, TenantUncheckedUpdateWithoutIngestionQueueJobsInput>
  }

  export type TenantCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type TransactionPartyCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput> | TransactionPartyCreateWithoutTransactionInput[] | TransactionPartyUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionPartyCreateOrConnectWithoutTransactionInput | TransactionPartyCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionPartyCreateManyTransactionInputEnvelope
    connect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
  }

  export type TransactionDocumentCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput> | TransactionDocumentCreateWithoutTransactionInput[] | TransactionDocumentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionDocumentCreateOrConnectWithoutTransactionInput | TransactionDocumentCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionDocumentCreateManyTransactionInputEnvelope
    connect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
  }

  export type TransactionMilestoneCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput> | TransactionMilestoneCreateWithoutTransactionInput[] | TransactionMilestoneUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionMilestoneCreateOrConnectWithoutTransactionInput | TransactionMilestoneCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionMilestoneCreateManyTransactionInputEnvelope
    connect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
  }

  export type TransactionPartyUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput> | TransactionPartyCreateWithoutTransactionInput[] | TransactionPartyUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionPartyCreateOrConnectWithoutTransactionInput | TransactionPartyCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionPartyCreateManyTransactionInputEnvelope
    connect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
  }

  export type TransactionDocumentUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput> | TransactionDocumentCreateWithoutTransactionInput[] | TransactionDocumentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionDocumentCreateOrConnectWithoutTransactionInput | TransactionDocumentCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionDocumentCreateManyTransactionInputEnvelope
    connect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
  }

  export type TransactionMilestoneUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput> | TransactionMilestoneCreateWithoutTransactionInput[] | TransactionMilestoneUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionMilestoneCreateOrConnectWithoutTransactionInput | TransactionMilestoneCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionMilestoneCreateManyTransactionInputEnvelope
    connect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTransactionsInput
    upsert?: TenantUpsertWithoutTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTransactionsInput, TenantUpdateWithoutTransactionsInput>, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionPartyUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput> | TransactionPartyCreateWithoutTransactionInput[] | TransactionPartyUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionPartyCreateOrConnectWithoutTransactionInput | TransactionPartyCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionPartyUpsertWithWhereUniqueWithoutTransactionInput | TransactionPartyUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionPartyCreateManyTransactionInputEnvelope
    set?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    disconnect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    delete?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    connect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    update?: TransactionPartyUpdateWithWhereUniqueWithoutTransactionInput | TransactionPartyUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionPartyUpdateManyWithWhereWithoutTransactionInput | TransactionPartyUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionPartyScalarWhereInput | TransactionPartyScalarWhereInput[]
  }

  export type TransactionDocumentUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput> | TransactionDocumentCreateWithoutTransactionInput[] | TransactionDocumentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionDocumentCreateOrConnectWithoutTransactionInput | TransactionDocumentCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionDocumentUpsertWithWhereUniqueWithoutTransactionInput | TransactionDocumentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionDocumentCreateManyTransactionInputEnvelope
    set?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    disconnect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    delete?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    connect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    update?: TransactionDocumentUpdateWithWhereUniqueWithoutTransactionInput | TransactionDocumentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionDocumentUpdateManyWithWhereWithoutTransactionInput | TransactionDocumentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionDocumentScalarWhereInput | TransactionDocumentScalarWhereInput[]
  }

  export type TransactionMilestoneUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput> | TransactionMilestoneCreateWithoutTransactionInput[] | TransactionMilestoneUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionMilestoneCreateOrConnectWithoutTransactionInput | TransactionMilestoneCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionMilestoneUpsertWithWhereUniqueWithoutTransactionInput | TransactionMilestoneUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionMilestoneCreateManyTransactionInputEnvelope
    set?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    disconnect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    delete?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    connect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    update?: TransactionMilestoneUpdateWithWhereUniqueWithoutTransactionInput | TransactionMilestoneUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionMilestoneUpdateManyWithWhereWithoutTransactionInput | TransactionMilestoneUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionMilestoneScalarWhereInput | TransactionMilestoneScalarWhereInput[]
  }

  export type TransactionPartyUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput> | TransactionPartyCreateWithoutTransactionInput[] | TransactionPartyUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionPartyCreateOrConnectWithoutTransactionInput | TransactionPartyCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionPartyUpsertWithWhereUniqueWithoutTransactionInput | TransactionPartyUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionPartyCreateManyTransactionInputEnvelope
    set?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    disconnect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    delete?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    connect?: TransactionPartyWhereUniqueInput | TransactionPartyWhereUniqueInput[]
    update?: TransactionPartyUpdateWithWhereUniqueWithoutTransactionInput | TransactionPartyUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionPartyUpdateManyWithWhereWithoutTransactionInput | TransactionPartyUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionPartyScalarWhereInput | TransactionPartyScalarWhereInput[]
  }

  export type TransactionDocumentUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput> | TransactionDocumentCreateWithoutTransactionInput[] | TransactionDocumentUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionDocumentCreateOrConnectWithoutTransactionInput | TransactionDocumentCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionDocumentUpsertWithWhereUniqueWithoutTransactionInput | TransactionDocumentUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionDocumentCreateManyTransactionInputEnvelope
    set?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    disconnect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    delete?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    connect?: TransactionDocumentWhereUniqueInput | TransactionDocumentWhereUniqueInput[]
    update?: TransactionDocumentUpdateWithWhereUniqueWithoutTransactionInput | TransactionDocumentUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionDocumentUpdateManyWithWhereWithoutTransactionInput | TransactionDocumentUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionDocumentScalarWhereInput | TransactionDocumentScalarWhereInput[]
  }

  export type TransactionMilestoneUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput> | TransactionMilestoneCreateWithoutTransactionInput[] | TransactionMilestoneUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionMilestoneCreateOrConnectWithoutTransactionInput | TransactionMilestoneCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionMilestoneUpsertWithWhereUniqueWithoutTransactionInput | TransactionMilestoneUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionMilestoneCreateManyTransactionInputEnvelope
    set?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    disconnect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    delete?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    connect?: TransactionMilestoneWhereUniqueInput | TransactionMilestoneWhereUniqueInput[]
    update?: TransactionMilestoneUpdateWithWhereUniqueWithoutTransactionInput | TransactionMilestoneUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionMilestoneUpdateManyWithWhereWithoutTransactionInput | TransactionMilestoneUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionMilestoneScalarWhereInput | TransactionMilestoneScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutPartiesInput = {
    create?: XOR<TransactionCreateWithoutPartiesInput, TransactionUncheckedCreateWithoutPartiesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPartiesInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutPartiesNestedInput = {
    create?: XOR<TransactionCreateWithoutPartiesInput, TransactionUncheckedCreateWithoutPartiesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPartiesInput
    upsert?: TransactionUpsertWithoutPartiesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPartiesInput, TransactionUpdateWithoutPartiesInput>, TransactionUncheckedUpdateWithoutPartiesInput>
  }

  export type TransactionCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<TransactionCreateWithoutDocumentsInput, TransactionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDocumentsInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<TransactionCreateWithoutDocumentsInput, TransactionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutDocumentsInput
    upsert?: TransactionUpsertWithoutDocumentsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutDocumentsInput, TransactionUpdateWithoutDocumentsInput>, TransactionUncheckedUpdateWithoutDocumentsInput>
  }

  export type TransactionCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<TransactionCreateWithoutMilestonesInput, TransactionUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutMilestonesInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<TransactionCreateWithoutMilestonesInput, TransactionUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutMilestonesInput
    upsert?: TransactionUpsertWithoutMilestonesInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutMilestonesInput, TransactionUpdateWithoutMilestonesInput>, TransactionUncheckedUpdateWithoutMilestonesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TenantDomainCreateWithoutTenantInput = {
    id: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantDomainUncheckedCreateWithoutTenantInput = {
    id: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantDomainCreateOrConnectWithoutTenantInput = {
    where: TenantDomainWhereUniqueInput
    create: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput>
  }

  export type TenantDomainCreateManyTenantInputEnvelope = {
    data: TenantDomainCreateManyTenantInput | TenantDomainCreateManyTenantInput[]
  }

  export type WebsiteConfigCreateWithoutTenantInput = {
    id: string
    createdAt: Date | string
    updatedAt: Date | string
    modules?: ModuleConfigCreateNestedManyWithoutWebsiteConfigInput
  }

  export type WebsiteConfigUncheckedCreateWithoutTenantInput = {
    id: string
    createdAt: Date | string
    updatedAt: Date | string
    modules?: ModuleConfigUncheckedCreateNestedManyWithoutWebsiteConfigInput
  }

  export type WebsiteConfigCreateOrConnectWithoutTenantInput = {
    where: WebsiteConfigWhereUniqueInput
    create: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
  }

  export type TenantControlSettingsCreateWithoutTenantInput = {
    id: string
    status?: string
    planCode?: string
    featureFlagsJson?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlSettingsUncheckedCreateWithoutTenantInput = {
    id: string
    status?: string
    planCode?: string
    featureFlagsJson?: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlSettingsCreateOrConnectWithoutTenantInput = {
    where: TenantControlSettingsWhereUniqueInput
    create: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
  }

  export type TenantBillingSubscriptionCreateWithoutTenantInput = {
    id: string
    planCode?: string
    status?: string
    paymentStatus?: string
    billingProvider?: string
    billingCustomerId?: string | null
    billingSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    currentPeriodEndsAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantBillingSubscriptionUncheckedCreateWithoutTenantInput = {
    id: string
    planCode?: string
    status?: string
    paymentStatus?: string
    billingProvider?: string
    billingCustomerId?: string | null
    billingSubscriptionId?: string | null
    trialEndsAt?: Date | string | null
    currentPeriodEndsAt?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantBillingSubscriptionCreateOrConnectWithoutTenantInput = {
    where: TenantBillingSubscriptionWhereUniqueInput
    create: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
  }

  export type TenantControlActorCreateWithoutTenantInput = {
    id: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlActorUncheckedCreateWithoutTenantInput = {
    id: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlActorCreateOrConnectWithoutTenantInput = {
    where: TenantControlActorWhereUniqueInput
    create: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput>
  }

  export type TenantControlActorCreateManyTenantInputEnvelope = {
    data: TenantControlActorCreateManyTenantInput | TenantControlActorCreateManyTenantInput[]
  }

  export type TenantOnboardingPlanCreateWithoutTenantInput = {
    id: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tasks?: TenantOnboardingTaskCreateNestedManyWithoutOnboardingPlanInput
  }

  export type TenantOnboardingPlanUncheckedCreateWithoutTenantInput = {
    id: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutOnboardingPlanInput
  }

  export type TenantOnboardingPlanCreateOrConnectWithoutTenantInput = {
    where: TenantOnboardingPlanWhereUniqueInput
    create: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput>
  }

  export type TenantOnboardingPlanCreateManyTenantInputEnvelope = {
    data: TenantOnboardingPlanCreateManyTenantInput | TenantOnboardingPlanCreateManyTenantInput[]
  }

  export type TenantOnboardingTaskCreateWithoutTenantInput = {
    id: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    onboardingPlan: TenantOnboardingPlanCreateNestedOneWithoutTasksInput
  }

  export type TenantOnboardingTaskUncheckedCreateWithoutTenantInput = {
    id: string
    tenantOnboardingPlanId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskCreateOrConnectWithoutTenantInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    create: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput>
  }

  export type TenantOnboardingTaskCreateManyTenantInputEnvelope = {
    data: TenantOnboardingTaskCreateManyTenantInput | TenantOnboardingTaskCreateManyTenantInput[]
  }

  export type ContactCreateWithoutTenantInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    leads?: LeadCreateNestedManyWithoutContactInput
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTenantInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTenantInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactCreateManyTenantInputEnvelope = {
    data: ContactCreateManyTenantInput | ContactCreateManyTenantInput[]
  }

  export type LeadCreateWithoutTenantInput = {
    id: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    contact?: ContactCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutTenantInput = {
    id: string
    contactId?: string | null
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTenantInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadCreateManyTenantInputEnvelope = {
    data: LeadCreateManyTenantInput | LeadCreateManyTenantInput[]
  }

  export type ActivityCreateWithoutTenantInput = {
    id: string
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
    contact?: ContactCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutTenantInput = {
    id: string
    contactId?: string | null
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityCreateOrConnectWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput>
  }

  export type ActivityCreateManyTenantInputEnvelope = {
    data: ActivityCreateManyTenantInput | ActivityCreateManyTenantInput[]
  }

  export type IngestedEventCreateWithoutTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
  }

  export type IngestedEventUncheckedCreateWithoutTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
  }

  export type IngestedEventCreateOrConnectWithoutTenantInput = {
    where: IngestedEventWhereUniqueInput
    create: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput>
  }

  export type IngestedEventCreateManyTenantInputEnvelope = {
    data: IngestedEventCreateManyTenantInput | IngestedEventCreateManyTenantInput[]
  }

  export type IngestionQueueJobCreateWithoutTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
  }

  export type IngestionQueueJobUncheckedCreateWithoutTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
  }

  export type IngestionQueueJobCreateOrConnectWithoutTenantInput = {
    where: IngestionQueueJobWhereUniqueInput
    create: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput>
  }

  export type IngestionQueueJobCreateManyTenantInputEnvelope = {
    data: IngestionQueueJobCreateManyTenantInput | IngestionQueueJobCreateManyTenantInput[]
  }

  export type TransactionCreateWithoutTenantInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    parties?: TransactionPartyCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutTenantInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    parties?: TransactionPartyUncheckedCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentUncheckedCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionCreateManyTenantInputEnvelope = {
    data: TransactionCreateManyTenantInput | TransactionCreateManyTenantInput[]
  }

  export type TenantDomainUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantDomainWhereUniqueInput
    update: XOR<TenantDomainUpdateWithoutTenantInput, TenantDomainUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantDomainCreateWithoutTenantInput, TenantDomainUncheckedCreateWithoutTenantInput>
  }

  export type TenantDomainUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantDomainWhereUniqueInput
    data: XOR<TenantDomainUpdateWithoutTenantInput, TenantDomainUncheckedUpdateWithoutTenantInput>
  }

  export type TenantDomainUpdateManyWithWhereWithoutTenantInput = {
    where: TenantDomainScalarWhereInput
    data: XOR<TenantDomainUpdateManyMutationInput, TenantDomainUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantDomainScalarWhereInput = {
    AND?: TenantDomainScalarWhereInput | TenantDomainScalarWhereInput[]
    OR?: TenantDomainScalarWhereInput[]
    NOT?: TenantDomainScalarWhereInput | TenantDomainScalarWhereInput[]
    id?: StringFilter<"TenantDomain"> | string
    tenantId?: StringFilter<"TenantDomain"> | string
    hostname?: StringFilter<"TenantDomain"> | string
    hostnameNormalized?: StringFilter<"TenantDomain"> | string
    status?: StringFilter<"TenantDomain"> | string
    isPrimary?: BoolFilter<"TenantDomain"> | boolean
    isVerified?: BoolFilter<"TenantDomain"> | boolean
    verifiedAt?: DateTimeNullableFilter<"TenantDomain"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantDomain"> | Date | string
    updatedAt?: DateTimeFilter<"TenantDomain"> | Date | string
  }

  export type WebsiteConfigUpsertWithoutTenantInput = {
    update: XOR<WebsiteConfigUpdateWithoutTenantInput, WebsiteConfigUncheckedUpdateWithoutTenantInput>
    create: XOR<WebsiteConfigCreateWithoutTenantInput, WebsiteConfigUncheckedCreateWithoutTenantInput>
    where?: WebsiteConfigWhereInput
  }

  export type WebsiteConfigUpdateToOneWithWhereWithoutTenantInput = {
    where?: WebsiteConfigWhereInput
    data: XOR<WebsiteConfigUpdateWithoutTenantInput, WebsiteConfigUncheckedUpdateWithoutTenantInput>
  }

  export type WebsiteConfigUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleConfigUpdateManyWithoutWebsiteConfigNestedInput
  }

  export type WebsiteConfigUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleConfigUncheckedUpdateManyWithoutWebsiteConfigNestedInput
  }

  export type TenantControlSettingsUpsertWithoutTenantInput = {
    update: XOR<TenantControlSettingsUpdateWithoutTenantInput, TenantControlSettingsUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantControlSettingsCreateWithoutTenantInput, TenantControlSettingsUncheckedCreateWithoutTenantInput>
    where?: TenantControlSettingsWhereInput
  }

  export type TenantControlSettingsUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantControlSettingsWhereInput
    data: XOR<TenantControlSettingsUpdateWithoutTenantInput, TenantControlSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlSettingsUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlSettingsUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    featureFlagsJson?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSubscriptionUpsertWithoutTenantInput = {
    update: XOR<TenantBillingSubscriptionUpdateWithoutTenantInput, TenantBillingSubscriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantBillingSubscriptionCreateWithoutTenantInput, TenantBillingSubscriptionUncheckedCreateWithoutTenantInput>
    where?: TenantBillingSubscriptionWhereInput
  }

  export type TenantBillingSubscriptionUpdateToOneWithWhereWithoutTenantInput = {
    where?: TenantBillingSubscriptionWhereInput
    data: XOR<TenantBillingSubscriptionUpdateWithoutTenantInput, TenantBillingSubscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type TenantBillingSubscriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantBillingSubscriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    billingProvider?: StringFieldUpdateOperationsInput | string
    billingCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    billingSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    trialEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantControlActorWhereUniqueInput
    update: XOR<TenantControlActorUpdateWithoutTenantInput, TenantControlActorUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantControlActorCreateWithoutTenantInput, TenantControlActorUncheckedCreateWithoutTenantInput>
  }

  export type TenantControlActorUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantControlActorWhereUniqueInput
    data: XOR<TenantControlActorUpdateWithoutTenantInput, TenantControlActorUncheckedUpdateWithoutTenantInput>
  }

  export type TenantControlActorUpdateManyWithWhereWithoutTenantInput = {
    where: TenantControlActorScalarWhereInput
    data: XOR<TenantControlActorUpdateManyMutationInput, TenantControlActorUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantControlActorScalarWhereInput = {
    AND?: TenantControlActorScalarWhereInput | TenantControlActorScalarWhereInput[]
    OR?: TenantControlActorScalarWhereInput[]
    NOT?: TenantControlActorScalarWhereInput | TenantControlActorScalarWhereInput[]
    id?: StringFilter<"TenantControlActor"> | string
    tenantId?: StringFilter<"TenantControlActor"> | string
    actorId?: StringFilter<"TenantControlActor"> | string
    displayName?: StringNullableFilter<"TenantControlActor"> | string | null
    email?: StringNullableFilter<"TenantControlActor"> | string | null
    role?: StringFilter<"TenantControlActor"> | string
    permissionsJson?: StringFilter<"TenantControlActor"> | string
    supportSessionActive?: BoolFilter<"TenantControlActor"> | boolean
    supportSessionStartedAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    supportSessionExpiresAt?: DateTimeNullableFilter<"TenantControlActor"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantControlActor"> | Date | string
    updatedAt?: DateTimeFilter<"TenantControlActor"> | Date | string
  }

  export type TenantOnboardingPlanUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantOnboardingPlanWhereUniqueInput
    update: XOR<TenantOnboardingPlanUpdateWithoutTenantInput, TenantOnboardingPlanUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantOnboardingPlanCreateWithoutTenantInput, TenantOnboardingPlanUncheckedCreateWithoutTenantInput>
  }

  export type TenantOnboardingPlanUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantOnboardingPlanWhereUniqueInput
    data: XOR<TenantOnboardingPlanUpdateWithoutTenantInput, TenantOnboardingPlanUncheckedUpdateWithoutTenantInput>
  }

  export type TenantOnboardingPlanUpdateManyWithWhereWithoutTenantInput = {
    where: TenantOnboardingPlanScalarWhereInput
    data: XOR<TenantOnboardingPlanUpdateManyMutationInput, TenantOnboardingPlanUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantOnboardingPlanScalarWhereInput = {
    AND?: TenantOnboardingPlanScalarWhereInput | TenantOnboardingPlanScalarWhereInput[]
    OR?: TenantOnboardingPlanScalarWhereInput[]
    NOT?: TenantOnboardingPlanScalarWhereInput | TenantOnboardingPlanScalarWhereInput[]
    id?: StringFilter<"TenantOnboardingPlan"> | string
    tenantId?: StringFilter<"TenantOnboardingPlan"> | string
    status?: StringFilter<"TenantOnboardingPlan"> | string
    planCode?: StringFilter<"TenantOnboardingPlan"> | string
    startedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    targetLaunchDate?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pausedAt?: DateTimeNullableFilter<"TenantOnboardingPlan"> | Date | string | null
    pauseReason?: StringNullableFilter<"TenantOnboardingPlan"> | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingPlan"> | Date | string
  }

  export type TenantOnboardingTaskUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    update: XOR<TenantOnboardingTaskUpdateWithoutTenantInput, TenantOnboardingTaskUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantOnboardingTaskCreateWithoutTenantInput, TenantOnboardingTaskUncheckedCreateWithoutTenantInput>
  }

  export type TenantOnboardingTaskUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    data: XOR<TenantOnboardingTaskUpdateWithoutTenantInput, TenantOnboardingTaskUncheckedUpdateWithoutTenantInput>
  }

  export type TenantOnboardingTaskUpdateManyWithWhereWithoutTenantInput = {
    where: TenantOnboardingTaskScalarWhereInput
    data: XOR<TenantOnboardingTaskUpdateManyMutationInput, TenantOnboardingTaskUncheckedUpdateManyWithoutTenantInput>
  }

  export type TenantOnboardingTaskScalarWhereInput = {
    AND?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
    OR?: TenantOnboardingTaskScalarWhereInput[]
    NOT?: TenantOnboardingTaskScalarWhereInput | TenantOnboardingTaskScalarWhereInput[]
    id?: StringFilter<"TenantOnboardingTask"> | string
    tenantOnboardingPlanId?: StringFilter<"TenantOnboardingTask"> | string
    tenantId?: StringFilter<"TenantOnboardingTask"> | string
    taskKey?: StringFilter<"TenantOnboardingTask"> | string
    title?: StringFilter<"TenantOnboardingTask"> | string
    description?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    status?: StringFilter<"TenantOnboardingTask"> | string
    priority?: StringFilter<"TenantOnboardingTask"> | string
    required?: BoolFilter<"TenantOnboardingTask"> | boolean
    ownerRole?: StringFilter<"TenantOnboardingTask"> | string
    ownerActorId?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    dueAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    blockedByClient?: BoolFilter<"TenantOnboardingTask"> | boolean
    blockerReason?: StringNullableFilter<"TenantOnboardingTask"> | string | null
    sortOrder?: IntFilter<"TenantOnboardingTask"> | number
    completedAt?: DateTimeNullableFilter<"TenantOnboardingTask"> | Date | string | null
    createdAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
    updatedAt?: DateTimeFilter<"TenantOnboardingTask"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
  }

  export type ContactUpdateManyWithWhereWithoutTenantInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    tenantId?: StringFilter<"Contact"> | string
    fullName?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    emailNormalized?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    phoneNormalized?: StringNullableFilter<"Contact"> | string | null
    source?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
  }

  export type LeadUpdateManyWithWhereWithoutTenantInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    status?: StringFilter<"Lead"> | string
    leadType?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    timeframe?: StringNullableFilter<"Lead"> | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    listingId?: StringNullableFilter<"Lead"> | string | null
    listingUrl?: StringNullableFilter<"Lead"> | string | null
    listingAddress?: StringNullableFilter<"Lead"> | string | null
    propertyType?: StringNullableFilter<"Lead"> | string | null
    beds?: IntNullableFilter<"Lead"> | number | null
    baths?: IntNullableFilter<"Lead"> | number | null
    sqft?: IntNullableFilter<"Lead"> | number | null
    lastContactAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    nextActionNote?: StringNullableFilter<"Lead"> | string | null
    nextActionChannel?: StringNullableFilter<"Lead"> | string | null
    reminderSnoozedUntil?: DateTimeNullableFilter<"Lead"> | Date | string | null
    priceMin?: IntNullableFilter<"Lead"> | number | null
    priceMax?: IntNullableFilter<"Lead"> | number | null
    tags?: StringFilter<"Lead"> | string
    closeReason?: StringNullableFilter<"Lead"> | string | null
    closeNotes?: StringNullableFilter<"Lead"> | string | null
    closedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    assignedTo?: StringNullableFilter<"Lead"> | string | null
    referredBy?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTenantInput, ActivityUncheckedUpdateWithoutTenantInput>
    create: XOR<ActivityCreateWithoutTenantInput, ActivityUncheckedCreateWithoutTenantInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTenantInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTenantInput, ActivityUncheckedUpdateWithoutTenantInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTenantInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTenantInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    tenantId?: StringFilter<"Activity"> | string
    contactId?: StringNullableFilter<"Activity"> | string | null
    leadId?: StringNullableFilter<"Activity"> | string | null
    activityType?: StringFilter<"Activity"> | string
    occurredAt?: DateTimeFilter<"Activity"> | Date | string
    summary?: StringFilter<"Activity"> | string
    metadataJson?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type IngestedEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: IngestedEventWhereUniqueInput
    update: XOR<IngestedEventUpdateWithoutTenantInput, IngestedEventUncheckedUpdateWithoutTenantInput>
    create: XOR<IngestedEventCreateWithoutTenantInput, IngestedEventUncheckedCreateWithoutTenantInput>
  }

  export type IngestedEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: IngestedEventWhereUniqueInput
    data: XOR<IngestedEventUpdateWithoutTenantInput, IngestedEventUncheckedUpdateWithoutTenantInput>
  }

  export type IngestedEventUpdateManyWithWhereWithoutTenantInput = {
    where: IngestedEventScalarWhereInput
    data: XOR<IngestedEventUpdateManyMutationInput, IngestedEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type IngestedEventScalarWhereInput = {
    AND?: IngestedEventScalarWhereInput | IngestedEventScalarWhereInput[]
    OR?: IngestedEventScalarWhereInput[]
    NOT?: IngestedEventScalarWhereInput | IngestedEventScalarWhereInput[]
    id?: StringFilter<"IngestedEvent"> | string
    tenantId?: StringFilter<"IngestedEvent"> | string
    eventType?: StringFilter<"IngestedEvent"> | string
    eventKey?: StringFilter<"IngestedEvent"> | string
    occurredAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    payloadJson?: StringFilter<"IngestedEvent"> | string
    processedAt?: DateTimeFilter<"IngestedEvent"> | Date | string
    createdAt?: DateTimeFilter<"IngestedEvent"> | Date | string
  }

  export type IngestionQueueJobUpsertWithWhereUniqueWithoutTenantInput = {
    where: IngestionQueueJobWhereUniqueInput
    update: XOR<IngestionQueueJobUpdateWithoutTenantInput, IngestionQueueJobUncheckedUpdateWithoutTenantInput>
    create: XOR<IngestionQueueJobCreateWithoutTenantInput, IngestionQueueJobUncheckedCreateWithoutTenantInput>
  }

  export type IngestionQueueJobUpdateWithWhereUniqueWithoutTenantInput = {
    where: IngestionQueueJobWhereUniqueInput
    data: XOR<IngestionQueueJobUpdateWithoutTenantInput, IngestionQueueJobUncheckedUpdateWithoutTenantInput>
  }

  export type IngestionQueueJobUpdateManyWithWhereWithoutTenantInput = {
    where: IngestionQueueJobScalarWhereInput
    data: XOR<IngestionQueueJobUpdateManyMutationInput, IngestionQueueJobUncheckedUpdateManyWithoutTenantInput>
  }

  export type IngestionQueueJobScalarWhereInput = {
    AND?: IngestionQueueJobScalarWhereInput | IngestionQueueJobScalarWhereInput[]
    OR?: IngestionQueueJobScalarWhereInput[]
    NOT?: IngestionQueueJobScalarWhereInput | IngestionQueueJobScalarWhereInput[]
    id?: StringFilter<"IngestionQueueJob"> | string
    tenantId?: StringFilter<"IngestionQueueJob"> | string
    eventType?: StringFilter<"IngestionQueueJob"> | string
    eventKey?: StringFilter<"IngestionQueueJob"> | string
    occurredAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    payloadJson?: StringFilter<"IngestionQueueJob"> | string
    status?: StringFilter<"IngestionQueueJob"> | string
    attemptCount?: IntFilter<"IngestionQueueJob"> | number
    lastError?: StringNullableFilter<"IngestionQueueJob"> | string | null
    createdAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    updatedAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    processedAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
    nextAttemptAt?: DateTimeFilter<"IngestionQueueJob"> | Date | string
    deadLetteredAt?: DateTimeNullableFilter<"IngestionQueueJob"> | Date | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<TransactionCreateWithoutTenantInput, TransactionUncheckedCreateWithoutTenantInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutTenantInput, TransactionUncheckedUpdateWithoutTenantInput>
  }

  export type TransactionUpdateManyWithWhereWithoutTenantInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    tenantId?: StringFilter<"Transaction"> | string
    leadId?: StringNullableFilter<"Transaction"> | string | null
    contactId?: StringNullableFilter<"Transaction"> | string | null
    propertyAddress?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    side?: StringFilter<"Transaction"> | string
    salePrice?: IntNullableFilter<"Transaction"> | number | null
    listPrice?: IntNullableFilter<"Transaction"> | number | null
    closingDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    contractDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    inspectionDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    appraisalDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    titleDate?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type TenantCreateWithoutDomainsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDomainsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDomainsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDomainsInput, TenantUncheckedCreateWithoutDomainsInput>
  }

  export type TenantUpsertWithoutDomainsInput = {
    update: XOR<TenantUpdateWithoutDomainsInput, TenantUncheckedUpdateWithoutDomainsInput>
    create: XOR<TenantCreateWithoutDomainsInput, TenantUncheckedCreateWithoutDomainsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDomainsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDomainsInput, TenantUncheckedUpdateWithoutDomainsInput>
  }

  export type TenantUpdateWithoutDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutWebsiteConfigInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWebsiteConfigInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWebsiteConfigInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWebsiteConfigInput, TenantUncheckedCreateWithoutWebsiteConfigInput>
  }

  export type ModuleConfigCreateWithoutWebsiteConfigInput = {
    id: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ModuleConfigUncheckedCreateWithoutWebsiteConfigInput = {
    id: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ModuleConfigCreateOrConnectWithoutWebsiteConfigInput = {
    where: ModuleConfigWhereUniqueInput
    create: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput>
  }

  export type ModuleConfigCreateManyWebsiteConfigInputEnvelope = {
    data: ModuleConfigCreateManyWebsiteConfigInput | ModuleConfigCreateManyWebsiteConfigInput[]
  }

  export type TenantUpsertWithoutWebsiteConfigInput = {
    update: XOR<TenantUpdateWithoutWebsiteConfigInput, TenantUncheckedUpdateWithoutWebsiteConfigInput>
    create: XOR<TenantCreateWithoutWebsiteConfigInput, TenantUncheckedCreateWithoutWebsiteConfigInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWebsiteConfigInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWebsiteConfigInput, TenantUncheckedUpdateWithoutWebsiteConfigInput>
  }

  export type TenantUpdateWithoutWebsiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWebsiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ModuleConfigUpsertWithWhereUniqueWithoutWebsiteConfigInput = {
    where: ModuleConfigWhereUniqueInput
    update: XOR<ModuleConfigUpdateWithoutWebsiteConfigInput, ModuleConfigUncheckedUpdateWithoutWebsiteConfigInput>
    create: XOR<ModuleConfigCreateWithoutWebsiteConfigInput, ModuleConfigUncheckedCreateWithoutWebsiteConfigInput>
  }

  export type ModuleConfigUpdateWithWhereUniqueWithoutWebsiteConfigInput = {
    where: ModuleConfigWhereUniqueInput
    data: XOR<ModuleConfigUpdateWithoutWebsiteConfigInput, ModuleConfigUncheckedUpdateWithoutWebsiteConfigInput>
  }

  export type ModuleConfigUpdateManyWithWhereWithoutWebsiteConfigInput = {
    where: ModuleConfigScalarWhereInput
    data: XOR<ModuleConfigUpdateManyMutationInput, ModuleConfigUncheckedUpdateManyWithoutWebsiteConfigInput>
  }

  export type ModuleConfigScalarWhereInput = {
    AND?: ModuleConfigScalarWhereInput | ModuleConfigScalarWhereInput[]
    OR?: ModuleConfigScalarWhereInput[]
    NOT?: ModuleConfigScalarWhereInput | ModuleConfigScalarWhereInput[]
    id?: StringFilter<"ModuleConfig"> | string
    websiteConfigId?: StringFilter<"ModuleConfig"> | string
    tenantId?: StringFilter<"ModuleConfig"> | string
    moduleKey?: StringFilter<"ModuleConfig"> | string
    enabled?: BoolFilter<"ModuleConfig"> | boolean
    sortOrder?: IntFilter<"ModuleConfig"> | number
    createdAt?: DateTimeFilter<"ModuleConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleConfig"> | Date | string
  }

  export type TenantCreateWithoutControlSettingsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutControlSettingsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutControlSettingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutControlSettingsInput, TenantUncheckedCreateWithoutControlSettingsInput>
  }

  export type TenantUpsertWithoutControlSettingsInput = {
    update: XOR<TenantUpdateWithoutControlSettingsInput, TenantUncheckedUpdateWithoutControlSettingsInput>
    create: XOR<TenantCreateWithoutControlSettingsInput, TenantUncheckedCreateWithoutControlSettingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutControlSettingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutControlSettingsInput, TenantUncheckedUpdateWithoutControlSettingsInput>
  }

  export type TenantUpdateWithoutControlSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutControlSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutBillingSubscriptionInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBillingSubscriptionInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBillingSubscriptionInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBillingSubscriptionInput, TenantUncheckedCreateWithoutBillingSubscriptionInput>
  }

  export type TenantUpsertWithoutBillingSubscriptionInput = {
    update: XOR<TenantUpdateWithoutBillingSubscriptionInput, TenantUncheckedUpdateWithoutBillingSubscriptionInput>
    create: XOR<TenantCreateWithoutBillingSubscriptionInput, TenantUncheckedCreateWithoutBillingSubscriptionInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBillingSubscriptionInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBillingSubscriptionInput, TenantUncheckedUpdateWithoutBillingSubscriptionInput>
  }

  export type TenantUpdateWithoutBillingSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBillingSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutControlActorsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutControlActorsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutControlActorsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutControlActorsInput, TenantUncheckedCreateWithoutControlActorsInput>
  }

  export type TenantUpsertWithoutControlActorsInput = {
    update: XOR<TenantUpdateWithoutControlActorsInput, TenantUncheckedUpdateWithoutControlActorsInput>
    create: XOR<TenantCreateWithoutControlActorsInput, TenantUncheckedCreateWithoutControlActorsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutControlActorsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutControlActorsInput, TenantUncheckedUpdateWithoutControlActorsInput>
  }

  export type TenantUpdateWithoutControlActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutControlActorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutOnboardingPlansInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOnboardingPlansInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOnboardingPlansInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOnboardingPlansInput, TenantUncheckedCreateWithoutOnboardingPlansInput>
  }

  export type TenantOnboardingTaskCreateWithoutOnboardingPlanInput = {
    id: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutOnboardingTasksInput
  }

  export type TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput = {
    id: string
    tenantId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskCreateOrConnectWithoutOnboardingPlanInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    create: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput>
  }

  export type TenantOnboardingTaskCreateManyOnboardingPlanInputEnvelope = {
    data: TenantOnboardingTaskCreateManyOnboardingPlanInput | TenantOnboardingTaskCreateManyOnboardingPlanInput[]
  }

  export type TenantUpsertWithoutOnboardingPlansInput = {
    update: XOR<TenantUpdateWithoutOnboardingPlansInput, TenantUncheckedUpdateWithoutOnboardingPlansInput>
    create: XOR<TenantCreateWithoutOnboardingPlansInput, TenantUncheckedCreateWithoutOnboardingPlansInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOnboardingPlansInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOnboardingPlansInput, TenantUncheckedUpdateWithoutOnboardingPlansInput>
  }

  export type TenantUpdateWithoutOnboardingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOnboardingPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantOnboardingTaskUpsertWithWhereUniqueWithoutOnboardingPlanInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    update: XOR<TenantOnboardingTaskUpdateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedUpdateWithoutOnboardingPlanInput>
    create: XOR<TenantOnboardingTaskCreateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedCreateWithoutOnboardingPlanInput>
  }

  export type TenantOnboardingTaskUpdateWithWhereUniqueWithoutOnboardingPlanInput = {
    where: TenantOnboardingTaskWhereUniqueInput
    data: XOR<TenantOnboardingTaskUpdateWithoutOnboardingPlanInput, TenantOnboardingTaskUncheckedUpdateWithoutOnboardingPlanInput>
  }

  export type TenantOnboardingTaskUpdateManyWithWhereWithoutOnboardingPlanInput = {
    where: TenantOnboardingTaskScalarWhereInput
    data: XOR<TenantOnboardingTaskUpdateManyMutationInput, TenantOnboardingTaskUncheckedUpdateManyWithoutOnboardingPlanInput>
  }

  export type TenantCreateWithoutOnboardingTasksInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutOnboardingTasksInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutOnboardingTasksInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutOnboardingTasksInput, TenantUncheckedCreateWithoutOnboardingTasksInput>
  }

  export type TenantOnboardingPlanCreateWithoutTasksInput = {
    id: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutOnboardingPlansInput
  }

  export type TenantOnboardingPlanUncheckedCreateWithoutTasksInput = {
    id: string
    tenantId: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingPlanCreateOrConnectWithoutTasksInput = {
    where: TenantOnboardingPlanWhereUniqueInput
    create: XOR<TenantOnboardingPlanCreateWithoutTasksInput, TenantOnboardingPlanUncheckedCreateWithoutTasksInput>
  }

  export type TenantUpsertWithoutOnboardingTasksInput = {
    update: XOR<TenantUpdateWithoutOnboardingTasksInput, TenantUncheckedUpdateWithoutOnboardingTasksInput>
    create: XOR<TenantCreateWithoutOnboardingTasksInput, TenantUncheckedCreateWithoutOnboardingTasksInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutOnboardingTasksInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutOnboardingTasksInput, TenantUncheckedUpdateWithoutOnboardingTasksInput>
  }

  export type TenantUpdateWithoutOnboardingTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutOnboardingTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantOnboardingPlanUpsertWithoutTasksInput = {
    update: XOR<TenantOnboardingPlanUpdateWithoutTasksInput, TenantOnboardingPlanUncheckedUpdateWithoutTasksInput>
    create: XOR<TenantOnboardingPlanCreateWithoutTasksInput, TenantOnboardingPlanUncheckedCreateWithoutTasksInput>
    where?: TenantOnboardingPlanWhereInput
  }

  export type TenantOnboardingPlanUpdateToOneWithWhereWithoutTasksInput = {
    where?: TenantOnboardingPlanWhereInput
    data: XOR<TenantOnboardingPlanUpdateWithoutTasksInput, TenantOnboardingPlanUncheckedUpdateWithoutTasksInput>
  }

  export type TenantOnboardingPlanUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOnboardingPlansNestedInput
  }

  export type TenantOnboardingPlanUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsiteConfigCreateWithoutModulesInput = {
    id: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutWebsiteConfigInput
  }

  export type WebsiteConfigUncheckedCreateWithoutModulesInput = {
    id: string
    tenantId: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type WebsiteConfigCreateOrConnectWithoutModulesInput = {
    where: WebsiteConfigWhereUniqueInput
    create: XOR<WebsiteConfigCreateWithoutModulesInput, WebsiteConfigUncheckedCreateWithoutModulesInput>
  }

  export type WebsiteConfigUpsertWithoutModulesInput = {
    update: XOR<WebsiteConfigUpdateWithoutModulesInput, WebsiteConfigUncheckedUpdateWithoutModulesInput>
    create: XOR<WebsiteConfigCreateWithoutModulesInput, WebsiteConfigUncheckedCreateWithoutModulesInput>
    where?: WebsiteConfigWhereInput
  }

  export type WebsiteConfigUpdateToOneWithWhereWithoutModulesInput = {
    where?: WebsiteConfigWhereInput
    data: XOR<WebsiteConfigUpdateWithoutModulesInput, WebsiteConfigUncheckedUpdateWithoutModulesInput>
  }

  export type WebsiteConfigUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWebsiteConfigNestedInput
  }

  export type WebsiteConfigUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutContactsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutContactsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutContactsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
  }

  export type LeadCreateWithoutContactInput = {
    id: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    activities?: ActivityCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutContactInput = {
    id: string
    tenantId: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutContactInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput>
  }

  export type LeadCreateManyContactInputEnvelope = {
    data: LeadCreateManyContactInput | LeadCreateManyContactInput[]
  }

  export type ActivityCreateWithoutContactInput = {
    id: string
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
    tenant: TenantCreateNestedOneWithoutActivitiesInput
    lead?: LeadCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactInput = {
    id: string
    tenantId: string
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityCreateOrConnectWithoutContactInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityCreateManyContactInputEnvelope = {
    data: ActivityCreateManyContactInput | ActivityCreateManyContactInput[]
  }

  export type TenantUpsertWithoutContactsInput = {
    update: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutContactsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type TenantUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithWhereUniqueWithoutContactInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutContactInput, LeadUncheckedUpdateWithoutContactInput>
    create: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutContactInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutContactInput, LeadUncheckedUpdateWithoutContactInput>
  }

  export type LeadUpdateManyWithWhereWithoutContactInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutContactInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
  }

  export type ActivityUpdateManyWithWhereWithoutContactInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type TenantCreateWithoutLeadsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeadsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeadsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
  }

  export type ContactCreateWithoutLeadsInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutLeadsInput = {
    id: string
    tenantId: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutLeadsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
  }

  export type ActivityCreateWithoutLeadInput = {
    id: string
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
    tenant: TenantCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutLeadInput = {
    id: string
    tenantId: string
    contactId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityCreateOrConnectWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityCreateManyLeadInputEnvelope = {
    data: ActivityCreateManyLeadInput | ActivityCreateManyLeadInput[]
  }

  export type TenantUpsertWithoutLeadsInput = {
    update: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeadsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type TenantUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutLeadsInput = {
    update: XOR<ContactUpdateWithoutLeadsInput, ContactUncheckedUpdateWithoutLeadsInput>
    create: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutLeadsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutLeadsInput, ContactUncheckedUpdateWithoutLeadsInput>
  }

  export type ContactUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
    create: XOR<ActivityCreateWithoutLeadInput, ActivityUncheckedCreateWithoutLeadInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutLeadInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutLeadInput, ActivityUncheckedUpdateWithoutLeadInput>
  }

  export type ActivityUpdateManyWithWhereWithoutLeadInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutLeadInput>
  }

  export type TenantCreateWithoutActivitiesInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutActivitiesInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutActivitiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutActivitiesInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutActivitiesInput = {
    id: string
    tenantId: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
  }

  export type LeadCreateWithoutActivitiesInput = {
    id: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    contact?: ContactCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutActivitiesInput = {
    id: string
    tenantId: string
    contactId?: string | null
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LeadCreateOrConnectWithoutActivitiesInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
  }

  export type TenantUpsertWithoutActivitiesInput = {
    update: XOR<TenantUpdateWithoutActivitiesInput, TenantUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TenantCreateWithoutActivitiesInput, TenantUncheckedCreateWithoutActivitiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutActivitiesInput, TenantUncheckedUpdateWithoutActivitiesInput>
  }

  export type TenantUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutActivitiesInput = {
    update: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
  }

  export type LeadUpsertWithoutActivitiesInput = {
    update: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
    create: XOR<LeadCreateWithoutActivitiesInput, LeadUncheckedCreateWithoutActivitiesInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutActivitiesInput, LeadUncheckedUpdateWithoutActivitiesInput>
  }

  export type LeadUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    contact?: ContactUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutIngestedEventsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIngestedEventsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIngestedEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIngestedEventsInput, TenantUncheckedCreateWithoutIngestedEventsInput>
  }

  export type TenantUpsertWithoutIngestedEventsInput = {
    update: XOR<TenantUpdateWithoutIngestedEventsInput, TenantUncheckedUpdateWithoutIngestedEventsInput>
    create: XOR<TenantCreateWithoutIngestedEventsInput, TenantUncheckedCreateWithoutIngestedEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIngestedEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIngestedEventsInput, TenantUncheckedUpdateWithoutIngestedEventsInput>
  }

  export type TenantUpdateWithoutIngestedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIngestedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutIngestionQueueJobsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    transactions?: TransactionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIngestionQueueJobsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIngestionQueueJobsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIngestionQueueJobsInput, TenantUncheckedCreateWithoutIngestionQueueJobsInput>
  }

  export type TenantUpsertWithoutIngestionQueueJobsInput = {
    update: XOR<TenantUpdateWithoutIngestionQueueJobsInput, TenantUncheckedUpdateWithoutIngestionQueueJobsInput>
    create: XOR<TenantCreateWithoutIngestionQueueJobsInput, TenantUncheckedCreateWithoutIngestionQueueJobsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIngestionQueueJobsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIngestionQueueJobsInput, TenantUncheckedUpdateWithoutIngestionQueueJobsInput>
  }

  export type TenantUpdateWithoutIngestionQueueJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIngestionQueueJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTransactionsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    activities?: ActivityCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTransactionsInput = {
    id: string
    slug: string
    name: string
    status: string
    createdAt: Date | string
    updatedAt: Date | string
    domains?: TenantDomainUncheckedCreateNestedManyWithoutTenantInput
    websiteConfig?: WebsiteConfigUncheckedCreateNestedOneWithoutTenantInput
    controlSettings?: TenantControlSettingsUncheckedCreateNestedOneWithoutTenantInput
    billingSubscription?: TenantBillingSubscriptionUncheckedCreateNestedOneWithoutTenantInput
    controlActors?: TenantControlActorUncheckedCreateNestedManyWithoutTenantInput
    onboardingPlans?: TenantOnboardingPlanUncheckedCreateNestedManyWithoutTenantInput
    onboardingTasks?: TenantOnboardingTaskUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenantInput
    ingestedEvents?: IngestedEventUncheckedCreateNestedManyWithoutTenantInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionPartyCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionPartyUncheckedCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionPartyCreateOrConnectWithoutTransactionInput = {
    where: TransactionPartyWhereUniqueInput
    create: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionPartyCreateManyTransactionInputEnvelope = {
    data: TransactionPartyCreateManyTransactionInput | TransactionPartyCreateManyTransactionInput[]
  }

  export type TransactionDocumentCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionDocumentUncheckedCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionDocumentCreateOrConnectWithoutTransactionInput = {
    where: TransactionDocumentWhereUniqueInput
    create: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionDocumentCreateManyTransactionInputEnvelope = {
    data: TransactionDocumentCreateManyTransactionInput | TransactionDocumentCreateManyTransactionInput[]
  }

  export type TransactionMilestoneCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionMilestoneUncheckedCreateWithoutTransactionInput = {
    id: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionMilestoneCreateOrConnectWithoutTransactionInput = {
    where: TransactionMilestoneWhereUniqueInput
    create: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionMilestoneCreateManyTransactionInputEnvelope = {
    data: TransactionMilestoneCreateManyTransactionInput | TransactionMilestoneCreateManyTransactionInput[]
  }

  export type TenantUpsertWithoutTransactionsInput = {
    update: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TenantCreateWithoutTransactionsInput, TenantUncheckedCreateWithoutTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTransactionsInput, TenantUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    activities?: ActivityUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domains?: TenantDomainUncheckedUpdateManyWithoutTenantNestedInput
    websiteConfig?: WebsiteConfigUncheckedUpdateOneWithoutTenantNestedInput
    controlSettings?: TenantControlSettingsUncheckedUpdateOneWithoutTenantNestedInput
    billingSubscription?: TenantBillingSubscriptionUncheckedUpdateOneWithoutTenantNestedInput
    controlActors?: TenantControlActorUncheckedUpdateManyWithoutTenantNestedInput
    onboardingPlans?: TenantOnboardingPlanUncheckedUpdateManyWithoutTenantNestedInput
    onboardingTasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenantNestedInput
    ingestedEvents?: IngestedEventUncheckedUpdateManyWithoutTenantNestedInput
    ingestionQueueJobs?: IngestionQueueJobUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TransactionPartyUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionPartyWhereUniqueInput
    update: XOR<TransactionPartyUpdateWithoutTransactionInput, TransactionPartyUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionPartyCreateWithoutTransactionInput, TransactionPartyUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionPartyUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionPartyWhereUniqueInput
    data: XOR<TransactionPartyUpdateWithoutTransactionInput, TransactionPartyUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionPartyUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionPartyScalarWhereInput
    data: XOR<TransactionPartyUpdateManyMutationInput, TransactionPartyUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionPartyScalarWhereInput = {
    AND?: TransactionPartyScalarWhereInput | TransactionPartyScalarWhereInput[]
    OR?: TransactionPartyScalarWhereInput[]
    NOT?: TransactionPartyScalarWhereInput | TransactionPartyScalarWhereInput[]
    id?: StringFilter<"TransactionParty"> | string
    transactionId?: StringFilter<"TransactionParty"> | string
    tenantId?: StringFilter<"TransactionParty"> | string
    role?: StringFilter<"TransactionParty"> | string
    name?: StringFilter<"TransactionParty"> | string
    email?: StringNullableFilter<"TransactionParty"> | string | null
    phone?: StringNullableFilter<"TransactionParty"> | string | null
    company?: StringNullableFilter<"TransactionParty"> | string | null
    createdAt?: DateTimeFilter<"TransactionParty"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionParty"> | Date | string
  }

  export type TransactionDocumentUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionDocumentWhereUniqueInput
    update: XOR<TransactionDocumentUpdateWithoutTransactionInput, TransactionDocumentUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionDocumentCreateWithoutTransactionInput, TransactionDocumentUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionDocumentUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionDocumentWhereUniqueInput
    data: XOR<TransactionDocumentUpdateWithoutTransactionInput, TransactionDocumentUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionDocumentUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionDocumentScalarWhereInput
    data: XOR<TransactionDocumentUpdateManyMutationInput, TransactionDocumentUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionDocumentScalarWhereInput = {
    AND?: TransactionDocumentScalarWhereInput | TransactionDocumentScalarWhereInput[]
    OR?: TransactionDocumentScalarWhereInput[]
    NOT?: TransactionDocumentScalarWhereInput | TransactionDocumentScalarWhereInput[]
    id?: StringFilter<"TransactionDocument"> | string
    transactionId?: StringFilter<"TransactionDocument"> | string
    tenantId?: StringFilter<"TransactionDocument"> | string
    documentType?: StringFilter<"TransactionDocument"> | string
    fileName?: StringFilter<"TransactionDocument"> | string
    status?: StringFilter<"TransactionDocument"> | string
    notes?: StringNullableFilter<"TransactionDocument"> | string | null
    createdAt?: DateTimeFilter<"TransactionDocument"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionDocument"> | Date | string
  }

  export type TransactionMilestoneUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionMilestoneWhereUniqueInput
    update: XOR<TransactionMilestoneUpdateWithoutTransactionInput, TransactionMilestoneUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionMilestoneCreateWithoutTransactionInput, TransactionMilestoneUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionMilestoneUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionMilestoneWhereUniqueInput
    data: XOR<TransactionMilestoneUpdateWithoutTransactionInput, TransactionMilestoneUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionMilestoneUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionMilestoneScalarWhereInput
    data: XOR<TransactionMilestoneUpdateManyMutationInput, TransactionMilestoneUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionMilestoneScalarWhereInput = {
    AND?: TransactionMilestoneScalarWhereInput | TransactionMilestoneScalarWhereInput[]
    OR?: TransactionMilestoneScalarWhereInput[]
    NOT?: TransactionMilestoneScalarWhereInput | TransactionMilestoneScalarWhereInput[]
    id?: StringFilter<"TransactionMilestone"> | string
    transactionId?: StringFilter<"TransactionMilestone"> | string
    tenantId?: StringFilter<"TransactionMilestone"> | string
    milestoneType?: StringFilter<"TransactionMilestone"> | string
    scheduledAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"TransactionMilestone"> | Date | string | null
    createdAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionMilestone"> | Date | string
  }

  export type TransactionCreateWithoutPartiesInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    documents?: TransactionDocumentCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPartiesInput = {
    id: string
    tenantId: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    documents?: TransactionDocumentUncheckedCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPartiesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPartiesInput, TransactionUncheckedCreateWithoutPartiesInput>
  }

  export type TransactionUpsertWithoutPartiesInput = {
    update: XOR<TransactionUpdateWithoutPartiesInput, TransactionUncheckedUpdateWithoutPartiesInput>
    create: XOR<TransactionCreateWithoutPartiesInput, TransactionUncheckedCreateWithoutPartiesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPartiesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPartiesInput, TransactionUncheckedUpdateWithoutPartiesInput>
  }

  export type TransactionUpdateWithoutPartiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    documents?: TransactionDocumentUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPartiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: TransactionDocumentUncheckedUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateWithoutDocumentsInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    parties?: TransactionPartyCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutDocumentsInput = {
    id: string
    tenantId: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    parties?: TransactionPartyUncheckedCreateNestedManyWithoutTransactionInput
    milestones?: TransactionMilestoneUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutDocumentsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutDocumentsInput, TransactionUncheckedCreateWithoutDocumentsInput>
  }

  export type TransactionUpsertWithoutDocumentsInput = {
    update: XOR<TransactionUpdateWithoutDocumentsInput, TransactionUncheckedUpdateWithoutDocumentsInput>
    create: XOR<TransactionCreateWithoutDocumentsInput, TransactionUncheckedCreateWithoutDocumentsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutDocumentsInput, TransactionUncheckedUpdateWithoutDocumentsInput>
  }

  export type TransactionUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    parties?: TransactionPartyUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parties?: TransactionPartyUncheckedUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateWithoutMilestonesInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tenant: TenantCreateNestedOneWithoutTransactionsInput
    parties?: TransactionPartyCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutMilestonesInput = {
    id: string
    tenantId: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    parties?: TransactionPartyUncheckedCreateNestedManyWithoutTransactionInput
    documents?: TransactionDocumentUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutMilestonesInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutMilestonesInput, TransactionUncheckedCreateWithoutMilestonesInput>
  }

  export type TransactionUpsertWithoutMilestonesInput = {
    update: XOR<TransactionUpdateWithoutMilestonesInput, TransactionUncheckedUpdateWithoutMilestonesInput>
    create: XOR<TransactionCreateWithoutMilestonesInput, TransactionUncheckedCreateWithoutMilestonesInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutMilestonesInput, TransactionUncheckedUpdateWithoutMilestonesInput>
  }

  export type TransactionUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTransactionsNestedInput
    parties?: TransactionPartyUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parties?: TransactionPartyUncheckedUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TenantDomainCreateManyTenantInput = {
    id: string
    hostname: string
    hostnameNormalized: string
    status?: string
    isPrimary?: boolean
    isVerified?: boolean
    verifiedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantControlActorCreateManyTenantInput = {
    id: string
    actorId: string
    displayName?: string | null
    email?: string | null
    role: string
    permissionsJson?: string
    supportSessionActive?: boolean
    supportSessionStartedAt?: Date | string | null
    supportSessionExpiresAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingPlanCreateManyTenantInput = {
    id: string
    status?: string
    planCode: string
    startedAt?: Date | string | null
    targetLaunchDate?: Date | string | null
    completedAt?: Date | string | null
    pausedAt?: Date | string | null
    pauseReason?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskCreateManyTenantInput = {
    id: string
    tenantOnboardingPlanId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ContactCreateManyTenantInput = {
    id: string
    fullName?: string | null
    email?: string | null
    emailNormalized?: string | null
    phone?: string | null
    phoneNormalized?: string | null
    source: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LeadCreateManyTenantInput = {
    id: string
    contactId?: string | null
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ActivityCreateManyTenantInput = {
    id: string
    contactId?: string | null
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type IngestedEventCreateManyTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    processedAt: Date | string
    createdAt: Date | string
  }

  export type IngestionQueueJobCreateManyTenantInput = {
    id: string
    eventType: string
    eventKey: string
    occurredAt: Date | string
    payloadJson: string
    status: string
    attemptCount?: number
    lastError?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    processedAt?: Date | string | null
    nextAttemptAt?: Date | string
    deadLetteredAt?: Date | string | null
  }

  export type TransactionCreateManyTenantInput = {
    id: string
    leadId?: string | null
    contactId?: string | null
    propertyAddress: string
    status: string
    side: string
    salePrice?: number | null
    listPrice?: number | null
    closingDate?: Date | string | null
    contractDate?: Date | string | null
    inspectionDate?: Date | string | null
    appraisalDate?: Date | string | null
    titleDate?: Date | string | null
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantDomainUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDomainUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantDomainUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    hostnameNormalized?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantControlActorUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    permissionsJson?: StringFieldUpdateOperationsInput | string
    supportSessionActive?: BoolFieldUpdateOperationsInput | boolean
    supportSessionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supportSessionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingPlanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TenantOnboardingTaskUpdateManyWithoutOnboardingPlanNestedInput
  }

  export type TenantOnboardingPlanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TenantOnboardingTaskUncheckedUpdateManyWithoutOnboardingPlanNestedInput
  }

  export type TenantOnboardingPlanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    planCode?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetLaunchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pausedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pauseReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    onboardingPlan?: TenantOnboardingPlanUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TenantOnboardingTaskUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantOnboardingPlanId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantOnboardingPlanId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUpdateManyWithoutContactNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNormalized?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestedEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionQueueJobUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IngestionQueueJobUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IngestionQueueJobUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventKey?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payloadJson?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextAttemptAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deadLetteredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parties?: TransactionPartyUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parties?: TransactionPartyUncheckedUpdateManyWithoutTransactionNestedInput
    documents?: TransactionDocumentUncheckedUpdateManyWithoutTransactionNestedInput
    milestones?: TransactionMilestoneUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    propertyAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    side?: StringFieldUpdateOperationsInput | string
    salePrice?: NullableIntFieldUpdateOperationsInput | number | null
    listPrice?: NullableIntFieldUpdateOperationsInput | number | null
    closingDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inspectionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appraisalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    titleDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigCreateManyWebsiteConfigInput = {
    id: string
    tenantId: string
    moduleKey: string
    enabled?: boolean
    sortOrder?: number
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ModuleConfigUpdateWithoutWebsiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigUncheckedUpdateWithoutWebsiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleConfigUncheckedUpdateManyWithoutWebsiteConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    moduleKey?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskCreateManyOnboardingPlanInput = {
    id: string
    tenantId: string
    taskKey: string
    title: string
    description?: string | null
    status?: string
    priority?: string
    required?: boolean
    ownerRole?: string
    ownerActorId?: string | null
    dueAt?: Date | string | null
    blockedByClient?: boolean
    blockerReason?: string | null
    sortOrder?: number
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TenantOnboardingTaskUpdateWithoutOnboardingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutOnboardingTasksNestedInput
  }

  export type TenantOnboardingTaskUncheckedUpdateWithoutOnboardingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantOnboardingTaskUncheckedUpdateManyWithoutOnboardingPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    taskKey?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    ownerRole?: StringFieldUpdateOperationsInput | string
    ownerActorId?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blockedByClient?: BoolFieldUpdateOperationsInput | boolean
    blockerReason?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyContactInput = {
    id: string
    tenantId: string
    status: string
    leadType: string
    source: string
    timeframe?: string | null
    notes?: string | null
    listingId?: string | null
    listingUrl?: string | null
    listingAddress?: string | null
    propertyType?: string | null
    beds?: number | null
    baths?: number | null
    sqft?: number | null
    lastContactAt?: Date | string | null
    nextActionAt?: Date | string | null
    nextActionNote?: string | null
    nextActionChannel?: string | null
    reminderSnoozedUntil?: Date | string | null
    priceMin?: number | null
    priceMax?: number | null
    tags?: string
    closeReason?: string | null
    closeNotes?: string | null
    closedAt?: Date | string | null
    assignedTo?: string | null
    referredBy?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ActivityCreateManyContactInput = {
    id: string
    tenantId: string
    leadId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type LeadUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    activities?: ActivityUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    leadType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    timeframe?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    listingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    beds?: NullableIntFieldUpdateOperationsInput | number | null
    baths?: NullableIntFieldUpdateOperationsInput | number | null
    sqft?: NullableIntFieldUpdateOperationsInput | number | null
    lastContactAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextActionNote?: NullableStringFieldUpdateOperationsInput | string | null
    nextActionChannel?: NullableStringFieldUpdateOperationsInput | string | null
    reminderSnoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceMin?: NullableIntFieldUpdateOperationsInput | number | null
    priceMax?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: StringFieldUpdateOperationsInput | string
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    closeNotes?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    referredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutActivitiesNestedInput
    lead?: LeadUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyLeadInput = {
    id: string
    tenantId: string
    contactId?: string | null
    activityType: string
    occurredAt: Date | string
    summary: string
    metadataJson?: string | null
    createdAt: Date | string
  }

  export type ActivityUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    activityType?: StringFieldUpdateOperationsInput | string
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    metadataJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyCreateManyTransactionInput = {
    id: string
    tenantId: string
    role: string
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionDocumentCreateManyTransactionInput = {
    id: string
    tenantId: string
    documentType: string
    fileName: string
    status?: string
    notes?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionMilestoneCreateManyTransactionInput = {
    id: string
    tenantId: string
    milestoneType: string
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TransactionPartyUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionPartyUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionDocumentUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionMilestoneUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    milestoneType?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}